/*
 *
 * Copyright (c) 2004, 2005 Ansgar Konermann
 * Contact: <konermann@itikko.net>
 *
 * This file is part of the OCL2.0 parser and compiler libraries
 * created at Technische Universitaet Dresden (TUD), Germany.
 * Visit http://dresden-ocl.sourceforge.net/ for details.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA  02111-1307  USA
 *
 */
 
 /*
 * This grammar file was changed by Nils (s0006383@inf.tu-dresden.de)
 * in 2007 (from May till November).
 *
 */

Package tudresden.ocl20.pivot.ocl2parser.gen.parserfiles;


Helpers

all					  = [0..0xffff];
lf					  = 10;
cr					  = 13;
input_character		  = [all - [lf + cr]];
character			  = ['a'..'z'] | ['A'..'Z'];
digit				  = ['0'..'9'];
ndigit				  = ['1'..'9'];
tab					  = 9;
ident				  = character (((character)|(digit))* '_'? ((character)|(digit)))*;
number 				  = ['1'..'9'] digit* | '0';
line_terminator       = cr | lf | cr lf ;
space                 = ' ';
whitespace			  = tab | space;
commentblock_start    = '/*';
commentblock_end	  = '*/';
realnumber			  = ((ndigit digit*)|'0')? '.' (digit)+ (('e'|'E') ('+'|'-')? (digit)*)?;
sliteral			  = ''' ident '''; 
slog				  = 'and' | 'or' | 'xor';

noasterisk			  = [all - '*'];
asterisk			  = '*';
noslash				  = [all - '/'];
string_not_unescaped  = [''' + ['\' + [cr + lf ]]];
string_literal_parts  = [all - string_not_unescaped];

States
initial_state, iterator_state;

Tokens
{initial_state, iterator_state} new_line 				= line_terminator;
{initial_state, iterator_state} blank 					= whitespace+;

// ----------------------------------------------- Limiter --------------------------------------------------------
{initial_state} 				!open_paren 				=	'(';
{initial_state} 				!close_paren 			=	')';
{initial_state} 				!comma 					=	',';
/* If an arrow is seen then the following token is either an iterate, iterator or collection operation */
{initial_state->iterator_state} !arrowright 				=	'->';
{initial_state} 				!dot 					= 	'.';
{initial_state}					!dbldot 					= 	'..';
{initial_state} 				!colon 					= 	':';
{initial_state} 				!dblcolon 				= 	'::';
{initial_state} 				!semicolon 				= 	';';
{initial_state} 				equals<TokenAS>			= 	'=';
{initial_state} 				!questionmark 			= 	'?';
{initial_state} 				!bracketopen 			=	'[';
{initial_state} 				!bracketclose 			= 	']';
{initial_state} 				!caret 					= 	'^';
{initial_state} 				!dblcaret 				= 	'^^';
{initial_state} 				!braceopen 				=	'{';
{initial_state} 				!braceclose 				= 	'}';
{initial_state} 				!verticalbar 			= 	'|';


// ----------------------------------------------- Reserved words -----------------------------------------------------------------
{initial_state} 				atpre<TokenAS>			= 	'@pre';
{initial_state} 				bag<TokenAS>			= 	'Bag';
{initial_state} 				collection<TokenAS>		=	'Collection';
{initial_state} 				orderedset <TokenAS>	=	'OrderedSet';
{initial_state} 				sequence<TokenAS>		= 	'Sequence';
{initial_state} 				set<TokenAS>			=	'Set';
{initial_state} 				!tuple 					= 	'Tuple';
{initial_state} 				!tupletype 				= 	'TupleType';
{initial_state} 				body<TokenAS>			= 	'body';
{initial_state} 				!context 				= 	'context';
{initial_state} 				!def 					=	'def';
{initial_state} 				!derive 				= 	'derive';
{initial_state} 				!else 					= 	'else';
{initial_state} 				!endif 					= 	'endif';
{initial_state} 				!endpackage 			= 	'endpackage';
{initial_state} 				false<TokenAS>			= 	'false';
{initial_state} 				!if 					= 	'if';
{initial_state} 				!in 					= 	'in';
{initial_state}					!init 					= 	'init';
{initial_state} 				!inv 					= 	'inv';
{initial_state} 				!let 					= 	'let';
{initial_state} 				!package 				=	'package';
{initial_state} 				pre<TokenAS>			= 	'pre';
{initial_state} 				post<TokenAS>			=	'post';
{initial_state} 				!then 					= 	'then';
{initial_state} 				true<TokenAS>			= 	'true';

// -------------------------------------- Iterate -----------------------------------------------------
{iterator_state->initial_state} !iterate 				= 	'iterate';

// ------------------------------------- Collection and iterator operations
{iterator_state->initial_state} iterator_operation<TokenAS>	= 	'select' | 'reject' | 'collect' | 'forAll' | 'any' | 'exists' | 'one' | 'isUnique' | 'collectNested' | 'sortedBy' ;
{iterator_state->initial_state} collection_operation<TokenAS> = 	ident;

// ------------------------------------- Type casting reserved words -----------------------------------	
{initial_state} 				ocl_is_type_of<TokenAS>	= 	'oclIsTypeOf';
{initial_state} 				ocl_is_kind_of<TokenAS>	=	'oclIsKindOf';
{initial_state} 				ocl_as_type<TokenAS>	= 	'oclAsType';

// ------------------------------------------- Arithmethic symbols -------------------------------------	
{initial_state} 				aop<TokenAS>			= 	'+' | '-';
{initial_state} 				mop<TokenAS>			= 	'*' | '/';
{initial_state} 				relop<TokenAS>			= 	'<' | '>' | '<=' | '>='| '<>';
{initial_state} 				simple_log<TokenAS>		= 	slog;
{initial_state} 				implies<TokenAS>		= 	'implies';
{initial_state}					not<TokenAS>			= 	'not';

// ----------------------------------------------- Numbers, real numbers, comments, string literals and identfier -----------------------
{initial_state} 				integer_literal<TokenAS> 	= 	number;
{initial_state} 				real_literal<TokenAS>		=	realnumber;
{initial_state} 				commentblock 				= 	commentblock_start (noasterisk | asterisk noslash)* commentblock_end;
{initial_state}					commentline					=	'--' input_character* line_terminator;
{initial_state} 				string_literal<TokenAS>		= 	''' string_literal_parts* ''';
{initial_state} 				simple_name<TokenAS>		= 	ident;

	

Ignored Tokens
new_line, blank, commentblock, commentline;

Productions
// The whole ocl file
ocl_file<OclFileAS>											= packaged_constraint_list_cs+;

// The package declaration
packaged_constraint_list_cs<PackagedConstraintAS>			= package path_name_cs context_declaration_cs* endpackage;

// The context declaration list that contains all ocl expressions of the file
//context_declaration_list_cs 								= context_declaration_cs context_declaration_list_cs?;

// One context declaration. A context declaration can refers to a classifier, an operation or an attribute/ association
context_declaration_cs<ContextAS>	 					= {attr_or_assoc}<AttrOrAssocContextAS> context path_name_cs context_type? init_or_der_value_cs+
    														| {classifier}<ClassifierContextAS> context path_name_cs classifier_constraint_cs+
    														| {operation}<OperationContextAS> context path_name_cs operation_signature_cs operation_constraint_cs+;

context_type<TypeAS> = colon type_specifier#chain;
// A path name is a list of identifier separated by a double colon. The path name is also used for an enumeration literal.
path_name_enum_cs<PathNameAS>								= colon path_name_cs#chain;
path_name_cs<PathNameAS>									= identifier_cs identifier_enum_cs*;
identifier_enum_cs<TokenAS>									= dblcolon identifier_cs#chain;

// An init or derive can only be used with an operation. It can have a name and must have an expression.
init_or_der_value_cs<AttrOrAssocConstraintAS> 				= {init}<InitAttrOrAssocConstraintAS> init colon ocl_expression_cs            
    														| {derive}<DeriveAttrOrAssocConstraintAS> derive colon ocl_expression_cs;

// An inv or def can only be used with a classifier. It can have a name and must have an expression.
classifier_constraint_cs<ClassifierConstraintAS>  			= {inv}<InvClassifierConstraintAS> inv simple_name? colon ocl_expression_cs
    	| {def_attribute}<DefAttributeConstraintAS> def [name]:simple_name? [first]:colon  [attribute_name]:simple_name [second]:colon type_specifier equals ocl_expression_cs
    	| {def_operation}<DefOperationConstraintAS> def [name]:simple_name? colon  [operation_name]:simple_name operation_signature_cs equals ocl_expression_cs;

// The operation signature that is used for operation definitions and context declarations.
operation_signature_cs<OperationSignatureAS> 				= open_paren formal_parameter_list_cs? close_paren operation_return_type_specifier_cs?;
operation_return_type_specifier_cs<TypeAS> 					= colon type_specifier#chain;
operation_constraint_cs<OperationConstraintAS>				= {full}op_constraint_stereotype_cs simple_name? colon ocl_expression_cs
															| {empty} op_constraint_stereotype_cs colon;
															
op_constraint_stereotype_cs<TokenAS> 						= {pre} pre #chain| {post} post#chain | {body} body#chain;

// ********************************************************* Collection literal expression ********************************************
collection_literal_exp_cs<CollectionLiteralExpAS> 			= collection_type_identifier_cs braceopen collection_literal_parts_cs? braceclose;
collection_literal_parts_cs<tudresden.ocl20.pivot.ocl2parser.gen.ocl2as.List>					= collection_literal_part_cs collection_literal_part_enum_cs*;
collection_literal_part_enum_cs<CollectionLiteralPartAS> 	= comma collection_literal_part_cs#chain;
collection_literal_part_cs<CollectionLiteralPartAS> 		= {range}<CollectionRangeAS> collection_range_cs #chain | {single_exp}<CollectionItemAS> ocl_expression_cs;
collection_range_cs<CollectionRangeAS>						= [left]:ocl_expression_cs dbldot [right]:ocl_expression_cs;

collection_type_specifier_cs<CollectionTypeAS>				= collection_type_identifier_cs open_paren type_specifier close_paren;
collection_type_identifier_cs<TokenAS> 	 					= {set} set#chain | {bag} bag#chain | {sequence} sequence#chain| {collection} collection#chain | {orderedset} orderedset#chain;

type_specifier<TypeAS>										= {simple}<PathNameAS> path_name_cs#chain
     														| {collection_type}<CollectionTypeAS> collection_type_specifier_cs#chain
     														| {tuple_type}<TupleTypeAS> tuple_type_specifier_cs#chain;

tuple_type_specifier_cs<TupleTypeAS> 						= tupletype open_paren formal_parameter_list_cs? close_paren;

identifier_cs<TokenAS>										= {simple} simple_name#chain | {ocl_op_name} ocl_op_name#chain | collection_type_identifier_cs#chain;

ocl_op_name<TokenAS>										= {kind_of} ocl_is_kind_of #chain | {type_of} ocl_is_type_of#chain | {as_type} ocl_as_type#chain;


// ****************************************** Literal-Expression *******************************************************************

literal_exp_cs<LiteralExpAS>					= {collection_literal}<CollectionLiteralExpAS> collection_literal_exp_cs#chain
												| {tuple}<TupleLiteralExpAS> tuple_literal_exp_cs#chain
												| {primitive}<PrimitiveLiteralExpAS> primitive_literal_exp_cs#chain;
									
primitive_literal_exp_cs<PrimitiveLiteralExpAS>	= {numeric}<NumericalLiteralExpAS> numeric_literal_exp_cs#chain
												| {string}<StringLiteralExpAS> string_literal_exp_cs#chain
												| {boolean}<BooleanLiteralExpAS> boolean_literal_exp_cs#chain;
									
numeric_literal_exp_cs<NumericalLiteralExpAS> 	= {integer}<IntegerLiteralExpAS> integer_literal
												| {real}<RealLiteralExpAS> real_literal;
											
string_literal_exp_cs<StringLiteralExpAS> 		= string_literal;
boolean_literal_exp_cs<BooleanLiteralExpAS>		= {false} false | {true} true;
tuple_literal_exp_cs<TupleLiteralExpAS>			= {tuple} tuple braceopen initialized_variable_list_cs braceclose;
  
initialized_variable_list_cs<tudresden.ocl20.pivot.ocl2parser.gen.ocl2as.List>		= initialized_variable_cs initialized_variable_enum_cs*;
initialized_variable_enum_cs<VariableAS>		= comma initialized_variable_cs#chain;

initialized_variable_cs<VariableAS>				= initialized_parameter_cs equals ocl_expression_cs#nocreate;
initialized_parameter_cs<VariableAS>			= {formal} formal_parameter_cs#nocreate | {simple} simple_name;

// ********************************************* OCL-Expression ************************************************************************

//expression 							= ocl_expression_cs;

ocl_expression_cs<OclExpressionAS> 		= {let}<LetExpAS> let_exp_cs#chain | {logical}<OclExpressionAS>  logical_exp_cs#chain;

let_exp_cs<LetExpAS>					= let initialized_variable_list_cs in ocl_expression_cs;


// --------------------------------------------- arithmetical expression ---------------------------------------------------------
logical_exp_cs<OclExpressionAS>				= {logical}<OperationCallExpAS> logical_exp_cs implies simple_logical_exp_cs
											| {simple_logical}<OclExpressionAS> simple_logical_exp_cs#chain;

simple_logical_exp_cs<OclExpressionAS> 		= {simple_logical}<OperationCallExpAS> simple_logical_exp_cs simple_log relational_exp_cs
											| {relational}<OclExpressionAS> relational_exp_cs#chain;

relational_exp_cs<OclExpressionAS> 			= {relational}<OperationCallExpAS> relational_exp_cs relational_operator additive_exp_cs
											| {additive}<OclExpressionAS> additive_exp_cs#chain;

relational_operator<TokenAS>				= {relop} relop #chain| {equals} equals#chain;

additive_exp_cs<OclExpressionAS>			= {additive}<OperationCallExpAS> additive_exp_cs aop multiplicative_exp_cs
											| {multiplicative}<OclExpressionAS> multiplicative_exp_cs#chain;

multiplicative_exp_cs<OclExpressionAS> 		= {multiplicative}<OperationCallExpAS> multiplicative_exp_cs mop unary_exp_cs
											| {unary}<OclExpressionAS> unary_exp_cs#chain;

unary_exp_cs<OclExpressionAS>				= {unary}<OperationCallExpAS> unary_operator postfix_exp_cs
											| {postfix}<OclExpressionAS> postfix_exp_cs#chain;

unary_operator<TokenAS>						= {aop} aop #chain| {not} not#chain;

// --------------------------------------------- operation, if, literal, message and collection expression ---------------------------
postfix_exp_cs<OclExpressionAS>			= {dot_property_call}<PropertyCallExpAS> postfix_exp_cs dot identifier_cs atpre?
										| {dot_operation_call}<OperationCallExpAS> postfix_exp_cs dot identifier_cs atpre? open_paren actual_parameter_list_cs? close_paren
										| {dot_property_assoc_call}<PropertyCallExpAS> postfix_exp_cs dot identifier_cs bracketopen actual_parameter_list_cs bracketclose atpre?
										| {arrowright_iterate}<IterateExpAS> postfix_exp_cs arrowright iterate open_paren iterate_var_cs? initialized_variable_cs verticalbar ocl_expression_cs close_paren
										| {arrowright_operation_call}<OperationCallExpAS> postfix_exp_cs arrowright collection_operation open_paren actual_parameter_list_cs? close_paren
										| {arrowright_iterator}<IteratorExpAS> postfix_exp_cs arrowright iterator_operation open_paren iterator_var_cs? ocl_expression_cs close_paren
										| {msg} postfix_exp_cs msg_operator_cs signal_spec_exp_cs
										| {literal}<LiteralExpAS> literal_exp_cs#chain
										| {parens}<OclExpressionAS> open_paren ocl_expression_cs close_paren#chain
										| {if}<IfExpAS> if_exp_cs#chain
										| {property}<FeatureCallExpAS> property_call_exp_cs#chain;
				
//if_exp_cs<IfExpAS>						= if logical_exp_cs then [body]:ocl_expression_cs else [elsebody]:ocl_expression_cs endif;
if_exp_cs<IfExpAS>						= if ocl_expression_cs then [body]:ocl_expression_cs else [elsebody]:ocl_expression_cs endif;

property_call_exp_cs<FeatureCallExpAS>	= {simple}<PropertyCallExpAS> path_name_cs atpre?
										| {parameter}<OperationCallExpAS> path_name_cs atpre? open_paren actual_parameter_list_cs? close_paren
										| {association}<PropertyCallExpAS> path_name_cs bracketopen actual_parameter_list_cs bracketclose atpre?;
										
iterate_var_cs<VariableAS>				= formal_parameter_cs semicolon#nocreate;

// must return list of VariableDclaration instances
iterator_var_cs<tudresden.ocl20.pivot.ocl2parser.gen.ocl2as.List>			= parameter_list_cs verticalbar#chain;

parameter_list_cs<tudresden.ocl20.pivot.ocl2parser.gen.ocl2as.List>			= parameter_cs parameter_enum*;
parameter_enum<VariableAS>				= comma parameter_cs#chain;
parameter_cs<VariableAS>				= {formal_parameter}<VariableAS> formal_parameter_cs
										| {simple_name}<VariableAS> simple_name;

// ---------------------------------------------------- message expression ------------------------------------------------------
msg_operator_cs 					= {caret} caret | {dblcaret} dblcaret;
signal_spec_exp_cs 					= simple_name open_paren message_argument_list_cs? close_paren;

// list of message arguments
message_argument_list_cs 			= message_arg_cs message_arg_enum_cs*;
message_arg_enum_cs 				= comma message_arg_cs;

// constructs which are syntactically valid as message argument
message_arg_cs 						= {questionmark_parameter} questionmark formal_parameter_type_specifier ? | {expression_parameter} ocl_expression_cs;


// ***************************************************** Parameter ********************************************************************
formal_parameter_type_specifier<TypeAS> 			= colon type_specifier#chain;


actual_parameter_list_cs<tudresden.ocl20.pivot.ocl2parser.gen.ocl2as.List> 				= actual_parameter_list_element_cs actual_parameter_enum_cs*;
actual_parameter_enum_cs<OclExpressionAS>			= comma actual_parameter_list_element_cs#chain;
actual_parameter_list_element_cs<OclExpressionAS> 	= {expression}<OclExpressionAS> ocl_expression_cs#chain
													| {formal_parameter}<VariableExpAS> formal_parameter_cs#chain;


formal_parameter_list_cs<tudresden.ocl20.pivot.ocl2parser.gen.ocl2as.List>				= formal_parameter_cs formal_parameter_enum_cs*;
formal_parameter_enum_cs<VariableExpAS> 			= comma formal_parameter_cs#chain;
formal_parameter_cs<VariableExpAS>					= simple_name formal_parameter_type_specifier;