/*
    Copyright (C) 2008  Nils (s0006383@inf.tu-dresden.de)

    This file is part of the OCL parser of the Dresden OCL2 for Eclipse.

    The OCL parser is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The OCL parser is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with the OCL parser.  If not, see <http://www.gnu.org/licenses/>.
.
*/

public aspect IteratorExpASTComputation {
	/*
	 * OCL Specification:
	 * [A] IteratorExpCs ::= OclExpressionCs[1] '->' simpleNameCs '(' ( VariableDeclarationCs[1], (',' VariableDeclarationCs[2])? '|' )? OclExpressionCs[2] ')'
	 * [B] IteratorExpCs ::= OclExpressionCs '.' simpleNameCs '(' argumentsCs? ')'
	 * [C] IteratorExpCs ::= OclExpressionCs '.' simpleNameCs
	 * [D] IteratorExpCs ::= OclExpressionCs '.' simpleNameCs ('[' argumentsCs ']')?
	 * [E] IteratorExpCs ::= OclExpressionCs '.' simpleNameCs ('[' argumentsCs ']')?
	 * 
	 * Meaning:
	 * [A] It is a normal iterator expression. If the source OclExpression[1] is not a
	 *     collection type it becomes one. The iterator variables are optional.
	 * 
	 * [B] The OclExpression[1] is of type collection type. simpleName is an operation name.
	 *     This is converted to OclExpression[1]->collect(simpleName(arguments))
	 * 
	 * [C] The OclExpression[1] is of type collection type. simpleName is a property name.
	 *     This is converted to OclExpression[1]->collect(simpleName)
	 *     
	 * [D] This case stands for the property case with qualifiers. Through the pivot model, it is equal to case C.
	 * 
	 */
	
	// This is case [A]
	public IteratorExp IteratorExpAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		IModelFactory factory = env.getExpFactory();
		
		/* If this expression has no source, it is an error. The grammar assures that the iterator expression has one source
		 * but it is saver if we examine this (the grammar can be changed in future when the ocl standard is changed).
		 */
		if (!hasSource()) throw new BuildingASMException("The iterator expression has no source.", getOperation());
		
		// Get the source.
		OclExpression sourceExpression = getSource().computeASM(env);

		/*
		 * The sourceExpression can be null. This happens if the source expression denotes a type. But
		 * in an iterator expression this is strange because an iterator expression refers to a collection not to
		 * a type.
		 */
		if (sourceExpression == null) {
			TokenAS errorToken = null;
			try {
				errorToken = getSource().computeErrorToken();
			} catch(ErrorTokenComputationException ex) {
				String message = ex.getMessage() + " An internal error occured.";
				throw new BuildingASMException(message, null);
			}
			
			throw new BuildingASMException("An iterator expression max not have a type as source.", errorToken);
		}
		
		/* If the source is no collection type then pack this simple element into a set.
		 * This is NOT documented in the ocl specification.
		 */
		if (!(sourceExpression.getType() instanceof CollectionType)) {
			sourceExpression = sourceExpression.withAsSet();
		}
		
		// Get the operation name.
		String operationName = getOperation().getValue();
		
		// Create an inner environment for the body expression.
		Environment innerEnv = env.nestedEnvironment();
		
		// Get the element type of the source expression.
		Type sourceElementType = ((CollectionType)sourceExpression.getType()).getElementType();
		
		// Get the number of iterator variables.
		int numberIterator = getNumIterators();
		
		Variable[] iterators = null;
		
		// If the number of iterator variables is zero, we must create an implicit iterator variable.
		if (numberIterator == 0) {
			Variable implicitIterator = factory.createVariable(VariableNameGenerator.getDefault().getVariableName(), sourceElementType, null);
			iterators = new Variable[1];
			iterators[0] = implicitIterator;
			innerEnv.addImplicitVariable(implicitIterator);
		}
		else { // The iterator expression has at least one interator variable.
			
			// Iterate over all iterator variables.
			iterators = new Variable[numberIterator];
			
			// The role of this list is only to make it easier to examine whether a variable is declared twice. 
			java.util.List iteratorList = new ArrayList();
			for(int i = 0; i < numberIterator; i++) {
				
				// Get the original variable as instance.
				VariableAS varAS = getIterators(i);
				
				/* If the variable has an init expression, it is an error.
				 * OCL Specification page 76, disambiguating rule [1].
				 */
				if (varAS.hasExpression() == true) throw new BuildingASMException("The iterator must not have an init expression.", varAS.getName());
				
				/*
				
				// If the variable has an init expression, it is an error.
				// OCL Specification page 76, disambiguating rule [1].
				//
				if (var.getInitExpression() != null) throw new BuildingASMException("The iterator must not have an init expression.", varAS.getName());
				
				*/
				
				Variable var = null;
				
				/* If the variable has no type, then take the element type of the source expression.
				 * OCL Specification page 73,  the third rule of the synthesised attributes.
				 */
				if (!varAS.hasType()) {
					var = env.getExpFactory().createVariable(varAS.getName().getValue(), sourceElementType, null);
				} else { // The user has specified a type for the iterator variable.
					var = varAS.computeASM(env);
					/*
					 * This user specified type must match the element type of the collection that
					 * is involved iterator expression.
					 */
					Type iteratorType = var.getType();
					if (iteratorType.conformsTo(sourceElementType) == false) throw new BuildingASMException("The specified" +
							" type doesn't match with the element type of the collection" +
							" type which is source of the iterator expression.", varAS.getName());
				}
				
				// Here we examine whether the iterator variable is declared twice. If so, it is an error.
				if (iteratorList.contains(var)) throw new BuildingASMException("The iterator variable is declared twice.", varAS.getName());
				iteratorList.add(var);
				iterators[i] = var;
				innerEnv.addExplicitVariable(var);
				innerEnv.addExplicitVariable(var);
			}
		}
				
		
		
		// Add all iterator variables to the inner environment. We have assured that the variables are all different.
		//numberIterator = iterators.length;
		//for(int i = 0; i < numberIterator; i++) {
		//	innerEnv.addImplicitVariable(iterators[i]);
		//}
		
		// We must set the contextial classifer type of the inner environment.
		//innerEnv.setContextualClassifier(sourceElementType);
		
		// Compute the body with the inner environment.
		OclExpression bodyExpression = getBody().computeASM(innerEnv);
		
		// Create the iterator expression with the elements we have computed before.
		IteratorExp resultExpression = factory.createIteratorExp(sourceExpression, operationName, bodyExpression, iterators);
		
		// If the factory returns null, it is a little bit strange, then it is an error.
		if (resultExpression == null) throw new BuildingASMException("An internal error occured.", getOperation());
		
		return resultExpression;
	}
	
	// This is case [C] and [D] 
	public IteratorExp PropertyCallExpAS.computeIteratorASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		IModelFactory factory = env.getExpFactory();
		
		// Compute the source expression.
		OclExpression sourceExpression = getSource().computeASM(env);
		
		/*
		 * Normally the class 'PropertyCallExpAS' checks whether the source expression is a collection.
		 * If so it calls this method 'computeIteratorAST'. So we need not to check this here. But we
		 * go for sure.
		 */
		if (sourceExpression == null) {
			TokenAS errorToken = null;
			try {
				errorToken = getSource().computeErrorToken();
			}
			catch(ErrorTokenComputationException ex) {
				String message = ex.getMessage() + " An internal error occured, a ErrorTokenComputationException was thrown.";
				throw new BuildingASMException(message, null);
			}
			throw new BuildingASMException("An internal error occured." +
					" A property call expression must have a collection as source not a type.", errorToken);
		}
		
		// Examine whether the source expression is of type collection type.
		if (!(sourceExpression.getType() instanceof CollectionType))
			throw new BuildingASMException("The source must be of type collection type.", getPathName().getTokenAS(0));
		
		// Get the element type of the source collection.
		Type sourceElementType = ((CollectionType) sourceExpression.getType()).getElementType();
		
		// The operation name of this iterator expression becomes 'collect'.
		String iteratorOperationName = "collect";
		
		// If the name of the property is a full qualified path name, it is an error.
		if (getPathName().getNumTokenAS() > 1) throw new BuildingASMException("Here must stand a simple name not a full qualified path name.", getPathName().getTokenAS(0));
		
		// Get the property name.
		String simpleName = getPathName().getTokenAS(0).getValue();
		
		// Transform the qualifier as elements into ocl expressions and put them in a array.
		int numberQualifier = getNumQualifier();
		OclExpression[] qualifiers = new OclExpression[numberQualifier];
		
		for(int i = 0; i < numberQualifier; i++) {
			qualifiers[i] = getQualifier(i).computeASM(env);
		}
		
		// Search for the property name in the element type.
		Property prop = sourceElementType.lookupProperty(simpleName);
		
		// If no property exists, it is an error.
		if (prop == null) throw new BuildingASMException("The property does not exists for the source.", getPathName().getTokenAS(0));
		
		/* Create a new iterator variable with the element type and the name of the source, but first we must examine
		 * whether a the source expression has a name. If not we create a new variable name for the new iterator variable.
		 */
		/*String iteratorVariableName = sourceExpression.getName();
		if ((iteratorVariableName == null) || (iteratorVariableName.equals(""))) {
			iteratorVariableName = VariableNameGenerator.getDefault().getVariableName();
		}*/
		
		String iteratorVariableName = VariableNameGenerator.getDefault().getVariableName();
		Variable iterator = factory.createVariable(iteratorVariableName, sourceElementType, null);
		
		// Build a variable expression at top of the iterator variable.
		VariableExp variableExp = factory.createVariableExp(iterator);
		
		// Create a property call expression. This becomes the body of the iterator expression.
		PropertyCallExp body = factory.createPropertyCallExp(variableExp, simpleName, qualifiers);
		
		// Create a little array to put the only one iterator into it.
		Variable[] iteratorArray = new Variable[1];
		iteratorArray[0] = iterator;
		
		// Create finally the iterator expression with the elements created before.
		IteratorExp result = factory.createIteratorExp(sourceExpression, iteratorOperationName, body, iteratorArray);
		
		// If the factory returns null, it is a bit strange, then it is an error.
		if (result == null) throw new BuildingASMException("An internal error occured.", getPathName().getTokenAS(0));
		
		return result;
	}
	
	// This is case [B].
	public CallExp OperationCallExpAS.computeIteratorASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		IModelFactory factory = env.getExpFactory();
		
		// Get the first string of the path name as error token to locate the error.
		TokenAS token = getName().getTokenAS(0);
		
		// If the operation call expression has no type, it is an error.
		if (!hasSource()) throw new BuildingASMException("The iterator expression to be built must have a source expression.", token);
		OclExpression sourceExpression = getSource().computeASM(env);
		
		/*
		 * Normally the class 'OperationCallExpAS' checks whether the source expression is a collection.
		 * If so it calls this method 'computeIteratorAST'. So we need not to check this here. But we
		 * go for sure.
		 */
		if (sourceExpression == null) {
			TokenAS errorToken = null;
			try {
				errorToken = getSource().computeErrorToken();
			} catch(ErrorTokenComputationException ex) {
				String message = ex.getMessage() + " An internal error occured. A ErrorTokenComputationException was thrown.";
				throw new BuildingASMException(message, null);
			}
			throw new BuildingASMException("An internal error occured." +
					" An operation call expression must have a collection as source not a type.", errorToken);
		}
		
		// If the operation was denoted by a full qualified name, it is an error.
		if (getName().getNumTokenAS() > 1)
			throw new BuildingASMException("The operation name must be a simple name not a full qualified operation.", token);
		
		// If the source expression is not of type collection type, it is an error.
		if (!(sourceExpression.getType() instanceof CollectionType))
			throw new BuildingASMException("The source expression must be of type collection type.", token);
		
		// Get the operation name.
		String operationName = getName().getTokenAS(0).getValue();
		
		
		
		/* Get the element type of the collection. If this operation call expression denotes a
		 * collection operation (this means that the 'getArrowRightExpression' method will return true)
		 * then we must lookup for the operation in the collection type. If the operation call
		 * expression denotes a simple operation call (that means that the 'getArrowRightExpression' method
		 * will return false), then we must take the element type of the operation and sourrend it with
		 * a collect-operation.
		 */
		Type sourceType = null;
		// We have a collection operation.
		if (getArrowRightExpression()) {
			// We can use the computeAS method.
			return computeOperationASM(env);
		}
		else { // We have no collection operation.
			
			/* Transforms the arguments of the collection call into an array and a list of ocl expression.
			 * Both will be used.
			 */
			int numberArgument = getNumArgument();
			OclExpression[] arguments = new OclExpression[numberArgument];
			java.util.List argumentList = new ArrayList();
			
			for (int i = 0; i < numberArgument; i++) {
				OclExpression argument = getArgument(i).computeASM(env);
				arguments[i] = argument;
				argumentList.add(argument);
			}
			
			// Take the element type.
			sourceType = ((CollectionType) sourceExpression.getType()).getElementType();
			
			// Look for the operation name in the element type.
			Operation operation = sourceType.lookupOperation(operationName, argumentList);
			
			// Create an iterator variable with the name of the source expression or if no one
			// exists, generate a new name, and the element type of the source expression.
			/*String iteratorVariableName = sourceExpression.getName();
			if ((iteratorVariableName == null) || (iteratorVariableName.equals(""))) {
				iteratorVariableName = VariableNameGenerator.getDefault().getVariableName();
			}*/
			String iteratorVariableName = VariableNameGenerator.getDefault().getVariableName();
			Variable iterator = factory.createVariable(iteratorVariableName, sourceType, null);
			
			// Build on top of the variable a variable expression.
			VariableExp variableExp = factory.createVariableExp(iterator);
			
			// The iterator operation becomes collect.
			String iteratorOperation = "collect";
			
			// Create an operation call expression with the computed variable expression, the operation name and the arguments.
			OperationCallExp operationCallExp = factory.createOperationCallExp(variableExp, operationName, arguments);
			
			// If the factory return null, it is a little bit strange, it is an error.
			if (operationCallExp == null) throw new BuildingASMException("An internal error occured.", token);
			
			// Create finally the iterator expression with the elements computed so far.
			IteratorExp result = factory.createIteratorExp(sourceExpression, iteratorOperation, operationCallExp, iterator);
			
			// If no operation name with this name is found, it is an error.
			if (operation == null) throw new BuildingASMException("The operation was not found for the source type.", token);
			
			// If the factory returns null, that is a little bit strange, it is an error.
			if (result == null) throw new BuildingASMException("An internal error occured.", token);
			
			return result;
		}
	}
}