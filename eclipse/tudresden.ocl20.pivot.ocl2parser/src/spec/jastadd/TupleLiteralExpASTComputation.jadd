/*
    Copyright (C) 2007  Nils (s0006383@inf.tu-dresden.de)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

public aspect TupleLiteralExpASMComputation {
	/*
	 * OCL-Specification:
	 * 
	 * TupleLiteralExpCS ::= 'Tuple' '{' variableDeclarationCS '}'
	 */
	public TupleLiteralExp TupleLiteralExpAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		IModelFactory factory = env.getExpFactory();
		
		// Create a new list for the tupel literal parts.
		java.util.List partList = new ArrayList();
		
		// Get the number of tuple literal parts.
		int numberParts = getNumParts();
		
		// Iterate over all tuple literal parts of the abstract syntax.
		for(int i = 0; i < numberParts; i++) {
			
			// Get the variable token for localization purpose.
			TokenAS variableToken = getParts(i).getVariable().getName();
			
			// Compute the tuple literal part.
			TupleLiteralPart part = getParts(i).computeASM(env);
			
			// Examine whether the part has a type (OCL Spec., page 70, Disambiguating rule 1).
			if (part.getProperty() == null) throw new BuildingASMException("The variable must have a type.", variableToken);
			
			// Examine whether the part has an ocl expression (OCL Spec., page 70, Disambiguating rule 1).
			if (part.getValue() == null) throw new BuildingASMException("The variable must have an init expression.", variableToken);
			
			// Add the part to the list.
			partList.add(part);
		}
		
		// Create an array that is big enough to store all tuple literal parts.
		TupleLiteralPart[] parts = new TupleLiteralPart[numberParts];
		
		// Transform the list into the array.
		parts = (TupleLiteralPart[]) partList.toArray(parts);
		
		// Create a new tuple literal expression.
		return factory.createTupleLiteralExp(parts);
	}
	
	public TupleLiteralPart TupleLiteralPartAS.computeASM(Environment env) throws BuildingASMException {
		// Get the factory.
		IModelFactory factory = env.getExpFactory();
		
		// Get the token of the variable. It is need when an error occured to make lokalization information.
		TokenAS token = getVariable().getName();
		
		// Transform the VariableAS instance into the corresponding essential ocl instance.
		Variable variable = getVariable().computeASM(env);
		
		// Transform the OclExpressionAS instance into the corresponding esstential ocl instance.
		OclExpression expression = getExpression().computeASM(env);
		
		// Set the ocl expression as init expression.
		variable.setInitExpression(expression);
		
		// Try to create a tuple literal instance. If something go wrong
		// throw an exception. But we don't know which error occured.
		TupleLiteralPart part = null;
		try {
			part = factory.createTupleLiteralPart(variable);
		}
		catch (FactoryException ex) {
			throw new BuildingASMException("An internal error occured.", token);
		}
		
		// Return the tuple literal part.
		return part; 
		
		
	}
}