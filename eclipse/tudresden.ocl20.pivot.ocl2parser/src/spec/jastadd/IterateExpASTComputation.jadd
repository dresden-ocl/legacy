/*
    Copyright (C) 2007  Nils (s0006383@inf.tu-dresden.de)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

public aspect IterateExpASMComputation {
	/*
	 * Concrete syntax:
	 * IterateExpCs ::= OclExpressionCs[1] '->' 'iterate' '(' (VariableDeclarationCs[1] ';' )? VariableDeclarationCs[2] '|' OclExpressionCs[2] ')'
	 */
	public IterateExp IterateExpAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		IModelFactory factory = env.getExpFactory();
		
		// The iterate expression musst have a source.
		if (!hasSource()) throw new BuildingASMException("The iterate expression has no source, it is unusual, maybe it is an internal error.", null);
		
		// Compute the source expression.
		OclExpression sourceExpression = getSource().computeASM(env);
		
		Variable iterator = null;
		
		// Iterate expression an interator
		if (hasIterator()) {
			// Compute the iterator variable.
			iterator = getIterator().computeASM(env);
			
			// The iterator varaible must not have an init expression
			// OCL-specification page 77, Disambuating rule [2]
			if (iterator.getInitExpression() != null) throw new BuildingASMException("The iterator variable of the" +
					" iterate expression must have an empty init epxression. This error occurs if the parser build" +
					" the iterator variable of the iterate expression with an init expression. This is an error.", null);
			
			
		}
		else {// Iterate expression no iterator
			Type iteratorType = null;
			
			// Examine whether the soure expression is of type collection type.
			if (sourceExpression.getType() instanceof CollectionType) {
				iteratorType = ((CollectionType)sourceExpression.getType()).getElementType();
			}
			else { // The source expression is not of type collection type.
				
				// If the source expression is not a collection type then take this type and pack into a collecton.
				// This behavior is NOT part of the ocl specification.
				sourceExpression = sourceExpression.withAsSet();
				//throw new BuildingASMException("The source expression is not of type collection type.", null);
			}
			
			// Create an empty iterator variable with the type of the element type of source expression.
			iterator = factory.createVariable(VariableNameGenerator.getDefault().getVariableName(), iteratorType, null);
		}
		
		// Pack the only iterator variable in an array because the factory method exspect an array.
		Variable[] iteratorVariables = new Variable[1];
		iteratorVariables[0] = iterator;
		
		// Compute the result variable.
		Variable resultVariable = getResult().computeASM(env);
		
		// The result variable must have a type.
		// OCL-specification, page 77, disambuationg rule [1]
		if (resultVariable.getType() == null) throw new BuildingASMException("The result variable has no type.", null);
		
		// The result variable must have an initial expression.
		// OCL-specification, page 77, disambuationg rule [1]
		if (resultVariable.getInitExpression() == null) throw new BuildingASMException("The result variable has no init expression.", null);
		
		
		/* To compute the body expression, we must build a nested environment with the result
		 * and iterator variable. Because both variable can be used to find implicit
		 * properties or operations it must be added as implicit variable.
		 */
		Environment nestedEnvironment = env.nestedEnvironment();
		nestedEnvironment.addImplicitVariable(resultVariable);
		nestedEnvironment.addImplicitVariable(iterator);
		
		// Compute the body with the nested environment.
		OclExpression bodyExpression = getBody().computeASM(nestedEnvironment);
		
		// Create the iterate expression with the factory.
		IterateExp iterateExpression = factory.createIterateExp(sourceExpression, bodyExpression, resultVariable, iteratorVariables);
		
		// If the factory returns null, it is an internal error.
		if (iterateExpression == null) throw new BuildingASMException("An internal error occured.", null);
		
		return iterateExpression;
	}
}