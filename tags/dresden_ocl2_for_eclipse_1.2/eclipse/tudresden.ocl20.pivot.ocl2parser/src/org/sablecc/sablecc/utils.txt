/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * This file is part of SableCC.                             *
 * See the file "LICENSE" for copyright information and the  *
 * terms and conditions for copying, distribution and        *
 * modification of SableCC.                                  *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * Enhanced by Ansgar Konermann to support generation of
 * attribute evaluation skeletons for L-attributed grammars.
 * Enhancements (c) 2004, 2005 Ansgar Konermann
 * Contact: <konermann@itikko.net>
 */

Macro:Start
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

import $1$.*;

public final class Start extends Node
{
    private $2$ _$3$_;
    private EOF _eof_;

    public Start()
    {
    }

    public Start(
        $2$ _$3$_,
        EOF _eof_)
    {
        set$2$(_$3$_);
        setEOF(_eof_);
    }

    public Object clone()
    {
        return new Start(
            ($2$) cloneNode(_$3$_),
            (EOF) cloneNode(_eof_));
    }

    public void apply(Switch sw) {
        ((Analysis) sw).caseStart(this);
    }

    public Object apply(SwitchWithReturn sw, Object param) throws AttrEvalException {
        return ((AnalysisWithReturn) sw).caseStart(this, param);
    }


    public $2$ get$2$()
    {
        return _$3$_;
    }

    public void set$2$($2$ node)
    {
        if(_$3$_ != null)
        {
            _$3$_.parent(null);
        }

        if(node != null)
        {
            if(node.parent() != null)
            {
                node.parent().removeChild(node);
            }

            node.parent(this);
        }

        _$3$_ = node;
    }

    public EOF getEOF()
    {
        return _eof_;
    }

    public void setEOF(EOF node)
    {
        if(_eof_ != null)
        {
            _eof_.parent(null);
        }

        if(node != null)
        {
            if(node.parent() != null)
            {
                node.parent().removeChild(node);
            }

            node.parent(this);
        }

        _eof_ = node;
    }

    void removeChild(Node child)
    {
        if(_$3$_ == child)
        {
            _$3$_ = null;
            return;
        }

        if(_eof_ == child)
        {
            _eof_ = null;
            return;
        }
    }

    void replaceChild(Node oldChild, Node newChild)
    {
        if(_$3$_ == oldChild)
        {
            set$2$(($2$) newChild);
            return;
        }

        if(_eof_ == oldChild)
        {
            setEOF((EOF) newChild);
            return;
        }
    }

    public String toString()
    {
        return "" +
            toString(_$3$_) +
            toString(_eof_);
    }
}

$

Macro:EOF
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

import $1$.*;

public final class EOF extends Token
{
    public EOF()
    {
        setText("");
    }

    public EOF(int line, int pos)
    {
        setText("");
        setLine(line);
        setPos(pos);
    }

    public Object clone()
    {
        return new EOF(getLine(), getPos());
    }

    public void apply(Switch sw) {
        ((Analysis) sw).caseEOF(this);
    }

    public Object apply(SwitchWithReturn sw, Object param) throws AttrEvalException {
        return ((AnalysisWithReturn) sw).caseEOF(this, param);
    }

}

$

Macro:Token
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

public abstract class Token extends Node
{
    private String text;
    private int line;
    private int pos;

    public String getText()
    {
        return text;
    }

    public void setText(String text)
    {
        this.text = text;
    }

    public int getLine()
    {
        return line;
    }

    public void setLine(int line)
    {
        this.line = line;
    }

    public int getPos()
    {
        return pos;
    }

    public void setPos(int pos)
    {
        this.pos = pos;
    }

    public String toString()
    {
        return text + " ";
    }

    void removeChild(Node child)
    {
    }

    void replaceChild(Node oldChild, Node newChild)
    {
    }
}

$

Macro:Node
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

import java.util.*;
import $1$.*;

public abstract class Node implements Switchable, SwitchableWithReturn, Cloneable
{
    private Node parent;

    public abstract Object clone();

    public Node parent()
    {
        return parent;
    }

    void parent(Node parent)
    {
        this.parent = parent;
    }

    abstract void removeChild(Node child);
    abstract void replaceChild(Node oldChild, Node newChild);

    public void replaceBy(Node node)
    {
        if(parent != null)
        {
            parent.replaceChild(this, node);
        }
    }

    protected String toString(Node node)
    {
        if(node != null)
        {
            return node.toString();
        }

        return "";
    }

    protected String toString(List list)
    {
        StringBuffer s = new StringBuffer();

        for(Iterator i = list.iterator(); i.hasNext();)
        {
            s.append(i.next());
        }

        return s.toString();
    }

    protected Node cloneNode(Node node)
    {
        if(node != null)
        {
            return (Node) node.clone();
        }

        return null;
    }

    protected List cloneList(List list)
    {
        List clone = new LinkedList();

        for(Iterator i = list.iterator(); i.hasNext();)
        {
            clone.add(((Node) i.next()).clone());
        }

        return clone;
    }
}

$

Macro:NodeCast
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;


public class NodeCast implements Cast
{
    public final static NodeCast instance = new NodeCast();

    private NodeCast()
    {
    }

    public Object cast(Object o)
    {
        return (Node) o;
    }
}

$

Macro:Switch
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

public interface Switch
{
}

$

Macro:SwitchWithReturn
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

public interface SwitchWithReturn
{
}

$

Macro:Switchable
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

public interface Switchable {
    void apply(Switch sw);
}

$


Macro:SwitchableWithReturn
/* This file was generated by SableCC (http://www.sablecc.org/). */
/*
 * Generator for L-attributed grammar attribute evaluators
 * (c) 2004, 2005 Ansgar Konermann.
 * Contact: <konermann@itikko.net>
 */

package $0$;

import $1$.*;

public interface SwitchableWithReturn {
    Object apply(SwitchWithReturn sw, Object param) throws AttrEvalException;
}

$


Macro:TypedLinkedList
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

import java.util.*;

public class TypedLinkedList extends LinkedList
{
    Cast cast;

    public TypedLinkedList()
    {
        super();

        cast = NoCast.instance;
    }

    public TypedLinkedList(Collection c)
    {
        super();
        cast = NoCast.instance;
        this.addAll(c);
    }

    public TypedLinkedList(Cast cast)
    {
        super();

        this.cast = cast;
    }

    public TypedLinkedList(Collection c, Cast cast)
    {
        super();
        this.cast = cast;
        this.addAll(c);
    }

    public Cast getCast()
    {
        return cast;
    }

    public void add(int index, Object element)
    {
        super.add(index, cast.cast(element));
    }

    public boolean add(Object o)
    {
        return super.add(cast.cast(o));
    }

    public boolean addAll(Collection c)
    {
        for(Iterator i = c.iterator(); i.hasNext(); )
        {
            super.add(cast.cast(i.next()));
        }
        return true;
    }

    public boolean addAll(int index, Collection c)
    {
        int pos = index;
        for(Iterator i = c.iterator(); i.hasNext(); )
        {
            super.add(pos++, cast.cast(i.next()));
        }
        return true;
    }

    public void addFirst(Object o)
    {
        super.addFirst(cast.cast(o));
    }

    public void addLast(Object o)
    {
        super.addLast(cast.cast(o));
    }

    public ListIterator listIterator(int index)
    {
        return new TypedLinkedListIterator(super.listIterator(index));
    }

    private class TypedLinkedListIterator implements ListIterator
    {
        ListIterator iterator;

        TypedLinkedListIterator(ListIterator iterator)
        {
            this.iterator = iterator;
        }

        public boolean hasNext()
        {
            return iterator.hasNext();
        }

        public Object next()
        {
            return iterator.next();
        }

        public boolean hasPrevious()
        {
            return iterator.hasPrevious();
        }

        public Object previous()
        {
            return iterator.previous();
        }

        public int nextIndex()
        {
            return iterator.nextIndex();
        }

        public int previousIndex()
        {
            return iterator.previousIndex();
        }

        public void remove()
        {
            iterator.remove();
        }

        public void set(Object o)
        {
            iterator.set(cast.cast(o));
        }

        public void add(Object o)
        {
            iterator.add(cast.cast(o));
        }
    }
}

$

Macro:Cast
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

public interface Cast
{
    Object cast(Object o);
}

$

Macro:NoCast
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

public class NoCast implements Cast
{
    public final static NoCast instance = new NoCast();

    private NoCast()
    {
    }

    public Object cast(Object o)
    {
        return o;
    }
}

$
