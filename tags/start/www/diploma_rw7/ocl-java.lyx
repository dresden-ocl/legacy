#This file was created by <rw7> Wed May 31 20:55:25 2000
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass report
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Diploma Thesis:
\newline 
Utility Support for Checking OCL Business Rules in Java Programs
\layout Author

Ralf Wiebicke
\layout Date

May 2000
\layout Section*

Copyright
\layout Standard

Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke.
\layout Standard

Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.1 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is available at http://www.gnu.org/copyleft/fdl.html.
\layout Section*

Availability
\layout Standard

This document is available at http://www.inf.tu-dresden.de/~rw7/diplom00/ in
 several electronic forms including PostScript, PDF, Html and the original
 kLyx version.
\layout Chapter

Introduction
\layout Section

OCL and Extreme Programming
\layout Chapter

Code Generation
\layout Section

Representation Of Associations
\layout Subsection

Possibilities
\layout Itemize

Collections named by the role name (maps for qualified associations)
\layout Itemize

Methods (isEmployed)
\layout Subsection

CASE-Tools
\layout Subsection

Net-Linx
\layout Standard

Anpassbarkeit an vorhandenen Quellcode.
\layout Section

Model Information
\layout Standard

Needed for Type Checking.
\layout Standard

There is already the Reflection Facade, which is pretty cool with two exception:
 
\layout Enumerate

no element types of associations.
 
\layout Enumerate

no isquery tag
\layout Standard

Solution: extend the java language.
 The new tag has a syntax like @see, but restricted to classes only.
\layout LyX-Code

class Person
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
All persons which are currently employed 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
by this person.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Collection employees;
\newline 
}
\layout Standard

Cool implementation: an extension of the reflection api and the java compiler.
\layout Standard

My implementation: A skript scanning the source code for these comments,
 and an extension of the reflection facade to use this information.
 (royloy.Person#employees=Person)
\layout Paragraph

Where comes the tag?
\layout Itemize

CASE-Tools
\layout Itemize

handmade: good-practice of programming.
 Should be there already in the comments, the tag makes it available formally.
\layout Itemize

reverse enginieering.
 see chapter [reverse enginieering]
\layout Standard

Will be tested automatically by the injected code.
\layout Standard

Is a good help for further reengineering from Java to UML (Diplomarbeit
 Stefan Frisch?)
\layout Chapter

Code Injection
\layout Section

Major Decisions
\layout Itemize

Reversable Transformation: 
\begin_deeper 
\layout Itemize

Must be possible to clean the code from all injected fragments.
\layout Itemize

Must be possible to edit the transformed source code without losing all
 changes at the next injection.
\layout Itemize

Major reasons: 
\begin_deeper 
\layout Itemize

the error messages pointing to the source code.
\layout Itemize

injection must be done only when the contraints heve been changed, not if
 the java source has been changed.
\end_deeper 
\end_deeper 
\layout Itemize

Method Wrapper
\layout Itemize

no import statements, explicit package qualifying in the generated code
 instead.
\layout Itemize

checking the @element-type
\layout Itemize

may be: Auslagerung von möglichst viel code auf eine Extraklasse pro Klasse
 oder pro Package.
 Entlastung des CVS.
 Das hat niedrige Priorität.
\layout Section

Wrapping Methods
\layout Standard

Touching the code of each method is needed, because the generated code must
 be run on each call to the method.
\layout Standard

Using wrapper methods avoids many problems which arise if there are several
 return statements in a method or a complex expression in the return statement.
 Also, there are no name conflicts anymore beetween the original and the
 generated code.
\layout Paragraph

Example.
\layout Standard

This is, how it works: A method
\layout LyX-Code

int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
} 
\layout Standard

is transformed into two methods:
\layout LyX-Code

int someMethod_wrappedbyocl(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
}
\newline 

\protected_separator 

\newline 
int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/preconditions.
\newline 

\protected_separator 

\protected_separator 
int result=someMethod_wrappedbyocl(x);
\newline 

\protected_separator 

\protected_separator 
// some code checking postconditions/invariants.
\newline 
}
\layout Standard

Slightly different and a bit tricky for constructors:
\layout LyX-Code

SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\layout Standard

gets to
\layout LyX-Code

SomeClass(String x, Void void)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\newline 

\protected_separator 

\newline 
SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
this(x, new Void());
\newline 

\protected_separator 

\protected_separator 
// some code checking postconditions/invariants.
\newline 
}
\layout Chapter

Reverse Engineering
\layout Standard

Avoid the UML model for type checking.
\layout Standard

An interactive tool for injecting 
\family typewriter 
@element-type
\family default 
 tags into the code using information obtained staticly from the source
 code or dynamicly on run time.
\layout Section

Static
\layout Standard

Given 
\family typewriter 
Collection employees
\family default 
 look for 
\family typewriter 
void addEmployee(Person)
\family default 
 or 
\family typewriter 
boolean isEmployee(Person)
\family default 
.
 
\layout Section

Dynamic
\layout Itemize

Enriche the code with tracing the object types inside collections.
\layout Itemize

compile and run the program (regression tests if available)
\the_end
