/*
    Copyright (C) 2007  Nils (s0006383@inf.tu-dresden.de)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

public aspect PropertyCallExpASTComputation {
	
	/*
	 * This method serves as a switch. If the source expression exists and the type of the source expression
	 * is of the type collection type, then compute an iterator expression, otherwise an property call expression.
	 */
	public OclExpression PropertyCallExpAS.computeASM(Environment env) throws BuildingASMException {
		if (!hasSource()) return computePropertyASM(env);
		
		Environment innerEnv = env.nestedEnvironment();
		OclExpression sourceExpression = getSource().computeASM(innerEnv);
		
		/*
		 * The source expression can be null. In this case the source expression denotes a type.
		 * This type is saved in the environment. 
		 * 
		 */
		if (sourceExpression == null) {
			Type sourceType = innerEnv.getSourceType();
			
			TokenAS errorToken = null;
			try {
				errorToken = getSource().computeErrorToken();
			} catch(ErrorTokenComputationException ex) {
				String message = ex.getMessage() + " An internal error occured. A ErrorTokenComputationException was thrown";
				throw new BuildingASMException(message, null);
			}
			
			if (sourceType == null) throw new BuildingASMException("An internal error occured.", errorToken);
			
			if (sourceType instanceof CollectionType) return computeIteratorASM(env);
			
			return computePropertyASM(env);
		}
		if (sourceExpression.getType() instanceof CollectionType) return computeIteratorASM(env);
		
		return computePropertyASM(env);
	}
	
	/*
	 * OCL-Specification:
	 * 
	 * 1 [A] AttributeCallExpCS ::= OclExpressionCS '.' simpleNameCS isMarkedPreCS?
	 * 2 [B] AttributeCallExpCS ::= simpleNameCS isMarkedPreCS?
	 * 3 [C] AttributeCallExpCS ::= pathNameCS
	 * 
	 * 4 [A] AssociationEndCallExpCS ::= OclExpressionCS '.' simpleNameCS ('[' argumentsCS ']')? isMarkedPreCS?
	 * 5 [B] AssociationEndCallExpCS ::= simpleNameCS ('[' argumentsCS ']')? isMarkedPreCS?
	 * 
	 * 6 [A] typeCS ::= patheNameCS
	 * 
	 * 7     EnumLiteralExpCS ::= pathNameCS '::' simpleNameCS
	 * 
	 * Description:
	 * 1 Denotes an explicit attribute call expression
	 * 2 Denotes an implicit attribute call expression
	 * 3 Denotes a static attribute call expression
	 * 
	 * 4 Denotes an access of an association end with explicit source
	 * 5 Denotes an access of an association end with implicit source
	 * 
	 * 6 Denotes a type
	 * 
	 * 7 Denotes an enumeration literal
	 * 
	 * Notice:
	 * The pivotmodell doesn't have the concepts 'attribute' and 'association end', but
	 * the concept 'property'. Both the attribute and the association end denotes a property.
	 * This aspect deal with the property concept.
	 */
	public OclExpression PropertyCallExpAS.computePropertyASM(Environment env) throws BuildingASMException {
		// Get the factory.
		IModelFactory factory = env.getExpFactory();
		
		// Get the number elements of the path name. It can be  one or more than one.
		int numberPathElements = getPathName().getNumTokenAS();
		
		/* If the number of path name element is zero then it is an error. Normally this
		 * case can't happen, but we examine the nevertheless.
		 */
		if (numberPathElements < 1) throw new BuildingASMException("The property has no valid name. Internal error.", null);
		
		// Get the error token.
		TokenAS token = getPathName().getTokenAS(0);
		
		/*
		 * If the property call expression is part of the paramter of a
		 * special ocl operation ('isOclKindOf', 'isOclType' or 'oclAsType')
		 * then we know that this property call must be a type. We lookup for
		 * this type. If we found one than we pack this type in a type literal
		 * expression and return it.
		 */
		if (env.isSpecialOclOperation()) {
			// Convert the token list into a string list.
			java.util.List pathNameList = new ArrayList();
			int numberPathNameElements = getPathName().getNumTokenAS();
			for(int i = 0; i < numberPathNameElements; i++) {
				pathNameList.add(getPathName().getTokenAS(i).getValue());
			}
			
			// Try to create a type literal expression.
			TypeLiteralExp returnExpression = null;
			try {
				returnExpression = factory.createTypeLiteralExp(pathNameList);
			}
			catch(Exception ex) {
				String message = ex.getMessage() + " The literal expression can not be built.";
				throw new BuildingASMException(message, token);
			}
			
			// If the return expression is null, it is an internal error.
			if (returnExpression == null) throw new BuildingASMException("An internal error occured.", token);
			
			return returnExpression;
		}
		
		Environment nestedEnvironment = env.nestedEnvironment();
			
		// Get the number of qualifiers.
		int numberQualifier = getNumQualifier();
		
		// Create an array for the qualifiers.
		OclExpression[] qualifiers = new OclExpression[numberQualifier];
		
		// Fill the qualifier array with the ocl expression that must be computed.
		for(int i = 0; i < numberQualifier; i++) {
			qualifiers[i] = getQualifier(i).computeASM(env);
		}
		
		// The source expression that can be used in the aspect.
		OclExpression sourceExpression = null;
		
		
		
		/* 
		 * This are the cases 1, 2, 4 and 5.
		 * The property call has a simple attribute.
		 */
		if (numberPathElements == 1) {
			
			
			// Get the attribute name. It is only one string.
			String attributeName = token.getValue();

			/*
			 * This are the cases 1 and 4.
			 * The property call has a source
			 */ 
			if (hasSource()) {
				
				// Get the source expression. Compute the ocl expression.
				sourceExpression = getSource().computeASM(nestedEnvironment);
				
				/*
				 * We know that we have a source in the abstract syntax tree, but the compute
				 * method return null. This happens if the source expression is a property
				 * call expression that holds only a type. This type is used to build a
				 * static property call expression. The type is saved in the environment
				 * and we can fetch this with the 'getSourceType()'-method from there.
				 * Then we can look up for the property in this property call expression
				 * in that type. If found one, we must examine whether the property
				 * is static. If so, we can create a static property call expression. 
				 */
				if (sourceExpression == null) {
					
					// We examine whether the source type in the environment was set.
					Type sourceType = nestedEnvironment.getSourceType();
					if (sourceType == null) throw new BuildingASMException("An internal" +
							" error occured, no source found for the property.", token);
					
					// Try to create a static property call expression.
					java.util.List propertyName = new java.util.ArrayList();
					propertyName.add(sourceType.getName());
					propertyName.add(attributeName);
					PropertyCallExp returnExpression = null;
					try {
						returnExpression = factory.createPropertyCallExp(propertyName, qualifiers);
					}
					catch(Exception ex) {
						String message = ex.getMessage() + " The static property can not be found.";
						throw new BuildingASMException(message, token);
					}
					
					if (returnExpression == null) throw new BuildingASMException("An error" +
							" occured while creating a static property call expression.", token);
					
					return returnExpression;
				}
				
				// If the property call has an @pre then make an @pre-ocl-expression.
				if (hasAtPre()) {
					sourceExpression = sourceExpression.withAtPre();
				}
				
				// Try to create a property call expression with the computed elements before.
				PropertyCallExp result = null;
				try {
					result = factory.createPropertyCallExp(sourceExpression, attributeName, qualifiers);
				} catch(Exception ex) {
					throw new BuildingASMException(ex.getMessage() + " An error occured while building an property call expression.", token);
				}
				
												
				// If the factory method return null, then it is an internal error.
				if (result == null) throw new BuildingASMException("An internal error occured.", token);
				
				return result;
			} 
			/*
			 * This are the cases 2 and 5.
			 */
			else {  // The property call has no source.
				
				// Search for a source that contains the property.
				Variable sourceVariable = env.lookupImplicitProperty(attributeName);
				
				if (sourceVariable == null) {
				
					/* 
					 * If we have no source, the name can be an explicit variable. If so,
					 * we create a variable expression and return this.
					 */
					Variable explicitVariable = env.lookupExplicitVariable(attributeName);
					
					if (explicitVariable != null) {
						VariableExp resultExp = env.getExpFactory().createVariableExp(explicitVariable);
						return resultExp;
					}
					
						/* It can be that the attributeName denotes a type. For example as parameter
						 * of an 'oclIsKindOf' operation. In that case we must examine whether this is
						 * really a type. So we lookup for that type. If one exists then we create
						 * a type literal expression with that type.
						 */
						java.util.List nameList = new ArrayList();
						nameList.add(attributeName);
						
						// Lookup for a type with the attribute name.
						Type sourceType = env.lookupType(nameList);
						
						/* If a type exists then we set the source type in the environment
						 * to give the caller the type and we return null to indicate that we have
						 * build no property call expression, but set the source type.
						 */
						if (sourceType != null) {
							env.setSourceType(sourceType);
							return null;
						}
						
						// No type with the specific name exists.
						throw new BuildingASMException("A source for the property was not found.", token);
				} else { // An implicit source for the property exists.
					
					/* Look up for the property in the type of the variable. Normally this
					 * method must always return a property because we have lookup for the source
					 * that contains this property. But there is one exception. If the property
					 * has the name 'self' then the type must not exists. If the type exsits
					 * then the type has an attribute with the name 'self', otherwise it the type
					 * has no such property and the next method call returns null. So if
					 * null is returned and the property name is 'self', we know that this can
					 * only be the implicit self type and this means we must build a variable
					 * expression instead of a property call expression.
					 */ 
					Property property = sourceVariable.getType().lookupProperty(attributeName);
					
					// We must build a variable expression.
					if ((property == null) && (attributeName.equals("self"))) {
						VariableExp expression = factory.createVariableExp(sourceVariable);
						return expression;
					}
					
					/* If no such property exists then we build a variable expression.
					 * This is this case for the iterator expressions. An iterator variable was defined and
					 * this variable is accessed. From the environment we get a variable, but we must
					 * return a variable expression. So we must pack the returned variable into a 
					 * variable expression.
					 */
					if (property == null) {
						VariableExp expression = factory.createVariableExp(sourceVariable);
						return expression;
					}
					
					// Create a variable expression at top of the variable and make this to the source expression.
					try {
						sourceExpression = factory.createVariableExp(sourceVariable);
					} catch(Exception ex) {
						throw new BuildingASMException(ex.getMessage() + " An error occured while building an variable" +
								" expression (while building a property call expression).", token);
					}
					
				}
				
				// Examine whether the operation call has an @pre. If so, make a @pre-ocl-expression.
				if (hasAtPre()) {
					sourceExpression = sourceExpression.withAtPre();
				}
				
				// Try to create a property call expression with the elements that were computed before.
				PropertyCallExp result = null;
				try {
					result = factory.createPropertyCallExp(sourceExpression, attributeName, qualifiers);
				} catch(Exception ex) {
					throw new BuildingASMException(ex.getMessage() + " An error occured while building a property call expression.", token);
				}
				
								
				// If the factory gives us null, it is an internal error.
				if (result == null) throw new BuildingASMException("An internal error occured.", token);
				
				return result;
			}
		}
		
		/* This is the case 3, 6 and 7.
		 * The operation call has a long path name. This path name can denote
		 * a static property, a type or an enumeration literal. So we must examine
		 * all these type one after another.
		 */
		if ((numberPathElements > 1) && (!hasSource())) {
			
			// Convert the token list into a string list.
			java.util.List pathNameList = new ArrayList();
			int numberPathNameElements = getPathName().getNumTokenAS();
			for(int i = 0; i < numberPathNameElements; i++) {
				pathNameList.add(getPathName().getTokenAS(i).getValue());
			}
			
			// Look up for the property in the environment.
			Property property = env.lookupProperty(pathNameList);
			
			/*
			 * This is case 3.
			 */
			
			// If the path name denotes a property.
			if (property != null) {
				// Try to create a property call expression.
				PropertyCallExp result = null;
				try {
					result = factory.createPropertyCallExp(pathNameList, qualifiers);
				}
				catch(Exception ex) {
					throw new BuildingASMException(ex.getMessage() + " An error occured while building" +
							" a static property call expression.", token);
				}
				
				
				// If the factory returns null, it is an internal error.
				if (result == null) throw new BuildingASMException("An internal error occured.", token);
				
				return result;
			}
			
			/* If the path name denotes a type, we must set this type in the environment and we
			 * we return null, to indicate the caller that we have saved a type in the environment.
			 */
			
			Type type = env.lookupType(pathNameList);
			/*
			 * This is case 6.
			 */
			if (type != null) {
				env.setSourceType(type);
				return null;
			}
			
			/*
			 * This is case 7. 
			 */
			
			
			/* If the path name denotes an enumeration literal. We take the first elements of the list
			 * because we must determine the enumartion type. After that we can lookup up for the
			 * last element in the list that must be literal of the enumeration.
			 */
			Type enumerationType = env.lookupType(pathNameList.subList(0, pathNameList.size()));
			if (enumerationType != null) {
				if (!(enumerationType instanceof Enumeration)) throw new BuildingASMException("The path name denotes not an enumeration type.", token);
				Enumeration enumeration = (Enumeration) enumerationType;
				// Lookup for the literal.
				EnumerationLiteral enumLiteral = enumeration.lookupLiteral((String)pathNameList.get(pathNameList.size()-1));
				
				if (enumLiteral != null) {
					EnumLiteralExp result = null;
					try {
						result = factory.createEnumLiteralExp(pathNameList);
					}
					catch(Throwable th) {
						String message = th.getMessage() + " The literal doesn't exists in the enumeration.";
						throw new BuildingASMException(message, token);
					}
				}
				
				// If the enumeration hasn't such a literal, it is an error.
				throw new BuildingASMException("The literal doesn't exists in the enumeration.", token);
			}
			
			// We have examine all types of that path name can be, but no one match. So it is an error.
			throw new BuildingASMException("The string denotes neither an enumeration, a type nor a property.", token);
			
			
		}
		
		/* At this point the path name have more elements then one and the operation call
		 * has a source, but a source with an enumeration, type literal or static attribute
		 * is a little bit strange.
		 */
		throw new BuildingASMException("This operation call expression has a source that makes no sense.", token);
	}
	
	/**
	 * Compute a type literal expression from the given name list. If the name is
	 * not found a BuildingASMException is thrown.
	 * 
	 * @param nameList the list that specifies the path name of the type
	 * @return a TypeLiteralExpression
	 * @throws BuildingASMException thrown if the type with the name is not found.
	 */
	protected TypeLiteralExp PropertyCallExpAS.computeTypeLiteralExpression(java.util.List nameList, IModelFactory factory, TokenAS token) throws BuildingASMException {
		TypeLiteralExp expression = null;
		try {
			expression = factory.createTypeLiteralExp(nameList);
		}
		catch(FactoryException ex) {
			String message = ex.getMessage() + " An error occured while creating a type literal expression.";
			throw new BuildingASMException(message, token);
		}
		catch(Throwable th) {
			String message = th.getMessage() + " An error occured while creating a type literal expression.";
			throw new BuildingASMException(message, token);
		}
		
		return expression;
	}
	
	
	
}