/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * This file is part of SableCC.                             *
 * See the file "LICENSE" for copyright information and the  *
 * terms and conditions for copying, distribution and        *
 * modification of SableCC.                                  *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * Enhanced by Ansgar Konermann to support generation of
 * attribute evaluation skeletons for L-attributed grammars.
 * Enhancements (c) 2004, 2005 Ansgar Konermann
 * Contact: <konermann@itikko.net>
 */
 

Macro:AnalysisHeader
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

import $1$.*;

public interface Analysis extends Switch
{
    Object getIn(Node node);
    void setIn(Node node, Object in);
    Object getOut(Node node);
    void setOut(Node node, Object out);


$
Macro:AnalysisStart
    void caseStart(Start node);
    // void caseStart(Start node, Object param);

$

Macro:AnalysisBody
    void case$0$($0$ node);
    // void case$0$($0$ node, Object param);

$

Macro:AnalysisTail
    void caseEOF(EOF node);
    // void caseEOF(EOF node, Object param);
}

$


/*
 * @param 0 analysis package name
 * @param 1 node package name
 * @param 2 root package name
 */
Macro:AnalysisWithReturnHeader
/* This file was generated by SableCC (http://www.sablecc.org/). */

/* Generator for LAttrEvalAdapter written by Ansgar Konermann */
/* (c) 2004, 2005 Ansgar Konermann                            */
/* Contact: <konermann@itikko.net>                            */


package $0$;

import $1$.*;
import tudresden.ocl20.pivot.ocl2parser.gen.ocl2as.*;
import tudresden.ocl20.pivot.ocl2parser.internal.*;

import java.util.LinkedList;
import java.util.List;

public interface AnalysisWithReturn extends SwitchWithReturn {

$

Macro:AnalysisWithReturnStart
    Object caseStart(Start node, Object param) throws AttrEvalException;

$

/*
 * @param 0     Alternative name (Axxxx)
 * @param 1     return type name for this alternative
 */
Macro:AnalysisWithReturnBody
    $1$ case$0$($0$ node, Object param) throws AttrEvalException;

$

Macro:AnalysisWithReturnTail
    Object caseEOF(EOF node, Object param) throws AttrEvalException;
}

$



Macro:AnalysisAdapterHeader
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

import java.util.LinkedList;
import java.util.Hashtable;
import java.util.List;
import $1$.*;

public class AnalysisAdapter implements Analysis
{
    private Hashtable in;
    private Hashtable out;

    public Object getIn(Node node) {
        if (in == null) { return null; }
        return in.get(node);
    }

    public void setIn(Node node, Object in) {
        if (this.in == null) { 
            this.in = new Hashtable(1);
        }
        if (in != null) {
            this.in.put(node, in);
        } else {
            this.in.remove(node);
        }
    }

    public Object getOut(Node node) {
        if (out == null) { return null; }
        return out.get(node);
    }

    public void setOut(Node node, Object out) {
        if (this.out == null) {
            this.out = new Hashtable(1);
        }
        if (out != null) {
            this.out.put(node, out);
        } else {
            this.out.remove(node);
        }
    }

$

Macro:AnalysisAdapterStart
    public void caseStart(Start node) { defaultCase(node); }
   
$

Macro:AnalysisAdapterBody
    public void case$0$($0$ node) { defaultCase(node); }

$

Macro:AnalysisAdapterTail

    public void caseEOF(EOF node) { defaultCase(node); }

    public void defaultCase(Node node) { }
}

$

Macro:DepthFirstAdapterHeader
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

import java.util.LinkedList;
import java.util.List;
import $1$.*;

public class DepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node) { defaultIn(node); }
    public void outStart(Start node) { defaultOut(node); }
    public void defaultIn(Node node) { }
    public void defaultOut(Node node) { }
    
    public void caseStart(Start node) {
        inStart(node);
        node.get$2$().apply(this);
        node.getEOF().apply(this);
        outStart(node);
    }

$

Macro:ReversedDepthFirstAdapterHeader
/* This file was generated by SableCC (http://www.sablecc.org/). */

package $0$;

import $1$.*;

public class ReversedDepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node) { defaultIn(node); }
    public void outStart(Start node) { defaultOut(node); }
    public void defaultIn(Node node) { }
    public void defaultOut(Node node) { }

    public void caseStart(Start node) {
        inStart(node);
        node.getEOF().apply(this);
        node.get$2$().apply(this);
        outStart(node);
    }


$

Macro:DepthFirstAdapterInOut

    public void in$0$($0$ node) { defaultIn(node); }
    public void out$0$($0$ node) { defaultOut(node); }

$

Macro:DepthFirstAdapterCaseHeader

    public void case$0$($0$ node) {
        in$0$(node);

$

Macro:DepthFirstAdapterCaseBodyNode
        if(node.get$0$() != null) {
            node.get$0$().apply(this);
        }

$

Macro:DepthFirstAdapterCaseBodyList
        {
            Object temp[] = node.get$0$().toArray();
            for(int i = 0; i < temp.length; i++) {
                (($1$) temp[i]).apply(this);
            }
        }

$

Macro:ReversedDepthFirstAdapterCaseBodyList
        {
            Object temp[] = node.get$0$().toArray();
            for(int i = temp.length - 1; i >= 0; i--) {
                (($1$) temp[i]).apply(this);
            }
        }

$

Macro:DepthFirstAdapterCaseTail
        out$0$(node);
    }

$

Macro:DepthFirstAdapterTail
}

$


/* 
 * Macro definitions for LAttrEvalAdapter
 * 
 * (c) 2004, 2005 Ansgar Konermann
 * 
 * Released under GNU LGPL, Version 2 or later.
 */



/* 
 * @param 0     analysis package name (where this adapter will reside)
 * @param 1     node package name (where all node classes reside)
 * @param 2     main production name (start symbol)
 * @param 3     root package name (parent of "sablecc" package)
 */
Macro:LAttrEvalAdapterHeader

/* This file was generated by SableCC (http://www.sablecc.org/). */

/* Generator for LAttrEvalAdapter written by Ansgar Konermann */
/* (c) 2004, 2005 Ansgar Konermann                            */
/* Contact: <konermann@itikko.net>                            */

package $0$;

import $1$.*;
import tudresden.ocl20.pivot.ocl2parser.internal.*;
import tudresden.ocl20.pivot.ocl2parser.gen.ocl2as.*;

import java.util.LinkedList;
import java.util.List;


public abstract class LAttrEvalAdapter implements AnalysisWithReturn {

    public static final boolean verbose = false;

    protected Token currentToken = null;
    public Token getCurrentToken() { return currentToken; }
    public void setCurrentToken(Token tk) { this.currentToken = tk; }
    public boolean hasCurrentToken() { return (this.currentToken != null); }

    protected NodeFactory factory = null;
 
    public void setNodeFactory(NodeFactory f) { this.factory = f; }

    public final Object caseStart(Start node, Object param) throws AttrEvalException  {  
        Object result = null;
        try {
            result = node.get$2$().apply(this, param);
        } catch (AttrEvalException ex) {
            if ( (! ex.hasToken()) && ( this.hasCurrentToken()) ) {
                ex.setToken( this.getCurrentToken() );
            }
            throw ex;
        }
        // node.getEOF().apply(this, param);
        return result;
        // override
    }

    public final Object caseEOF(EOF node, Object param) throws AttrEvalException  {
        return node.apply(this, param);
    }

$

/*
 * @param 0     Alternative name (Axxx)
 * @param 1     return type name for this alternative
 */
Macro:LAttrEvalAdapterCaseHeader

    public final $1$ case$0$($0$ node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

$


/*
 * @param 0     Child node name (without any P or A prefix)
 * @param 1     Current alternative name (Axxx)
 * @param 2     Child node type (Pxxx or Txxx)
 * @param 3     Child node ast type name
 * @param 4     actual parameter list of all ast nodes of siblings further left
 */
Macro:LAttrEvalAdapterCaseBodyNode_customHeritage

        $2$ child$0$ = node.get$0$();
        $3$ ast$0$ = null;
        if( child$0$ != null) {
            childHrtg = inside$1$_computeHeritageFor_$0$(node, child$0$, nodeHrtg.copy()$4$);
            if ( childHrtg == null ) {
                childHrtg = nodeHrtg.copy();
            }
            if (verbose) System.out.println("   descending into child '$0$' of alternative $1$ with custom heritage... ");
            ast$0$ = ($3$) child$0$.apply(this, childHrtg );
            if (verbose) System.out.println("   back from '$0$'.");
        }
$


/*
 * @param 0     Child node name (without any P or A prefix)
 * @param 1     Current alternative name (Axxx)
 * @param 2     Child node type (Pxxx or Txxx)
 * @param 3     Child node ast type name
 * @param 4     actual parameter list of all ast nodes of siblings further left
 */
Macro:LAttrEvalAdapterCaseBodyNode_defaultHeritage

        $2$ child$0$ = node.get$0$();
        $3$ ast$0$ = null;
        if( child$0$ != null) {
            if (verbose) System.out.println("   descending into child '$0$' of alternative $1$... ");
            ast$0$ = ($3$) child$0$.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from '$0$'.");
        }
$


/*
 * @param 0     Child node name (without any P or A prefix)
 * @param 1     Current alternative name (Axxx)
 * @param 2     Child node type (Pxxx or Txxx)
 * @param 3     Child node ast type name
 * @param 4     actual parameter list of all ast nodes of siblings further left
 */
Macro:LAttrEvalAdapterCaseBodyList_customHeritage

        LinkedList astList$0$ = new java.util.LinkedList(); // contains $3$ instances
        {
            $2$ child$0$ = null;
            $3$ ast$0$ = null;
            Object temp[] = node.get$0$().toArray();
            for(int i = 0; i < temp.length; i++) {
                child$0$ = ($2$) temp[i];
                childHrtg = inside$1$_computeHeritageFor_$0$(node, child$0$, nodeHrtg.copy()$4$);
                if ( childHrtg == null ) {
                    childHrtg = nodeHrtg.copy();
                }
                if (verbose) System.out.println("   descending into child '$0$' of alternative $1$ with custom heritage... ");
                ast$0$ = ($3$) child$0$.apply(this, childHrtg );
                if (verbose) System.out.println("   back from '$0$'.");
                astList$0$.add(ast$0$);
            }
        }
$

/*
 * @param 0     Child node name (without any P or A prefix)
 * @param 1     Current alternative name (Axxx)
 * @param 2     Child node type (Pxxx or Txxx)
 * @param 3     Child node ast type name
 * @param 4     actual parameter list of all ast nodes of siblings further left
 */
Macro:LAttrEvalAdapterCaseBodyList_defaultHeritage

        LinkedList astList$0$ = new java.util.LinkedList(); // contains $3$ instances
        {
            $2$ child$0$ = null;
            $3$ ast$0$ = null;
            Object temp[] = node.get$0$().toArray();
            for(int i = 0; i < temp.length; i++) {
                child$0$ = ($2$) temp[i];
                if (verbose) System.out.println("   descending into child '$0$' of alternative $1$... ");
                ast$0$ = ($3$) child$0$.apply(this, nodeHrtg.copy());
                if (verbose) System.out.println("   back from '$0$'.");
                astList$0$.add(ast$0$);
            }
        }
$

/*
 * @param 0     Child node name (without any P or A prefix)
 * @param 1     Current alternative name (Axxx)
 * @param 2     Child node type (Pxxx or Txxx)
 * @param 3     Child node ast type name
 * @param 4     actual parameter list of all ast nodes of siblings further left
 */
Macro:LAttrEvalAdapterCaseBodyList_makeTree
        
        $3$ astTree$0$ = null;
        {
            $2$ child$0$ = null;
            $3$ astPrevious$0$ = null;
            Object temp[] = node.get$0$().toArray();
            for(int i = 0; i < temp.length; i++) {
                child$0$ = ($2$) temp[i];                
                childHrtg = inside$1$_computeHeritageFor_$0$(node, child$0$, 
                    nodeHrtg.copy(), astPrevious$0$$4$);
                if ( childHrtg == null ) {
                    childHrtg = nodeHrtg.copy();
                }
                if (verbose) System.out.println("   descending into child '$0$' of alternative $1$... ");
                astTree$0$ = ($3$) child$0$.apply(this, childHrtg);
                if (verbose) System.out.println("   back from '$0$'.");
                astPrevious$0$ = astTree$0$;
            }
        }
$



/*
 * @param 0     Alternative name (Axxx)
 * @param 1     Current alternative's AST node type name
 */
Macro:LAttrEvalAdapterCaseCreateAstIntro

        // create AST node for current CST node here.
        $1$ myAst = ($1$) factory.createNode("$1$");
        myAst = computeAstFor_$0$(myAst, nodeHrtg
$

/*
 * @param 0     Alternative name (Axxx)
 * @param 1     Current alternative's AST node type name
 */
Macro:LAttrEvalAdapterCaseCreateAstIntro_delegateCreation

        // create AST node for current CST node here.
        $1$ myAst = computeAstFor_$0$(nodeHrtg
$



/*
 * @param 0     Current alternative's AST node type name
 * @param 1     chained child node's parameter name
 */
Macro:LAttrEvalAdapterCaseCreateAst_chained

        // create AST node for current CST node here.
        $0$ myAst = $1$;
$


/**
 * @param 0     main component of the variable to pass as argument (e. g. child node name, element name)
 *�@param 1     unused
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterAstNodeVar_list
$2$List$0$
$

/**
 * @param 0     main component of the variable to pass as argument (e. g. child node name, element name)
 *�@param 1     unused
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterAstNodeVar_tree
$2$Tree$0$
$

/**
 * @param 0     main component of the variable to pass as argument (e. g. child node name, element name)
 * @param 1     unused
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterAstNodeVar_node
$2$$0$
$

/**
 * @param 0     main component of the variable to pass as argument (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterActualParam_node
,
            $2$$0$
$

/**
 * @param 0     main component of the variable to pass as argument (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterActualParam_list
,
            $2$List$0$
$

/**
 * @param 0     main component of the variable to pass as argument (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterActualParam_tree
,
            $2$Tree$0$
$


/*
 * @param 0     Alternative name (Axxx)
 * @param 1     Current alternative's AST node type name
 */
Macro:LAttrEvalAdapterCaseTail
);
        return myAst;
    }

$

/*
 * @param 0     Alternative name (Axxx)
 * @param 1     Current alternative's AST node type name
 */
Macro:LAttrEvalAdapterCaseTail_chained

        return myAst;
    }

$


/*
 * @param 0     Token name (Txxx)
 * @param 1     return type name for this token
 */
Macro:LAttrEvalAdapterCaseToken_default

    public final $1$ case$0$($0$ node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

$

/*
 * @param 0     Token name (Txxx)
 * @param 1     return type name for this token
 */
Macro:LAttrEvalAdapterCaseToken_custom

    public final $1$ case$0$($0$ node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        $1$ result = createNodeFor_$0$(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract $1$ createNodeFor_$0$($0$ node, Heritage nodeHrtg) throws AttrEvalException;

$


/*
 * @param 0     Current alternative name (Axxx)
 * @param 1     Child/element name to descend into (without any A or P prefix)
 * @param 2     Child node type (Pxxx or Txxx)
 * @param 3     AST type name of current element
 */
Macro:LAttrEvalAdapterComputeHeritageHeaderIntro

    public abstract Heritage inside$0$_computeHeritageFor_$1$($0$ parent,
        $2$ child, Heritage parentHrtgCopy
$

/*
 * @param 0     Current alternative name (Axxx)
 * @param 1     Child/element name to descend into (without any A or P prefix)
 * @param 2     Child node type (Pxxx or Txxx)
 * @param 3     AST type name of current element
 */
Macro:LAttrEvalAdapterComputeHeritageHeaderIntro_makeTree

    public abstract Heritage inside$0$_computeHeritageFor_$1$($0$ parent,
        $2$ child, Heritage parentHrtgCopy, $3$ astPreviousSibling
$


// the second set of macros generates a non-abstract dummy implementation
// if you prefer this behaviour, comment out the first of each of these macros
// and uncomment the second one of each of these.
// Macro:LAttrEvalAdapterComputeHeritageHeaderIntro
// 
//     public Heritage inside$0$_computeHeritageFor_$1$($0$ parent,
//         $2$ child, Heritage parentHrtgCopy
// $

Macro:LAttrEvalAdapterComputeHeritageHeaderTail
) throws AttrEvalException;

$

// Macro:LAttrEvalAdapterComputeHeritageHeaderTail
// ) throws AttrEvalException
//     {
// 
// $

Macro:LAttrEvalAdapterComputeHeritageBodyHeader

$

// Macro:LAttrEvalAdapterComputeHeritageBodyHeader
//         // create Heritage for current child node here
//         Heritage result = null;
// 
// $

Macro:LAttrEvalAdapterComputeHeritageBodyTail

$

// Macro:LAttrEvalAdapterComputeHeritageBodyTail
//         return result;
//     }
// 
// $


/**
 * @param 0     Current alternative name (Axxx)
 * @param 1     Current production name (Pxxx)
 */
Macro:LAttrEvalAdapterComputeAstHeaderJavadocIntro
    
    /**
     * Constructs AST node for alternative $1$:$0$.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
$

/**
 * @param 0     Current alternative name (Axxx)
 * @param 1     Current production name (Pxxx)
 */
Macro:LAttrEvalAdapterComputeAstHeaderJavadocIntro_delegateCreation
    
    /**
     * Constructs AST node for alternative $1$:$0$.
     * The implementation of this method must create an AST node of the correct
     * type <b>and</b> set all attributes and associations as required by the OCL
     * specification.
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
$


/**
 * @param 0     AST type name of alternative (Axxx)
 * @param 1     AST type name of production
 */
Macro:LAttrEvalAdapterComputeAstHeaderJavadocTail

     * @return the initialized AST node, which is an instance of $0$ (AST
     * type of production is $1$).
     */
$


/**
 * @param 0     parameter name main component (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterJavadocParam_node

     * @param  $2$$0$ a reference to an instance of class $1$
$

/**
 * @param 0     parameter name main component (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterJavadocParam_list

     * @param  $2$List$0$ a reference to a List of $1$ instances
$

/**
 * @param 0     parameter name main component (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterJavadocParam_tree

     * @param  $2$Tree$0$ a reference to an instance of class $1$ which in is the
     *         root node of a tree of other $1$ instances (or subclasses
     *         thereof).
$



/*
 * @param 0     Current alternative name (Axxx)
 * @param 1     AST type name of alternative (Axxx)
 * @param 2     AST type name of production
 * @param 3     Current production name (Pxxx)
 */
Macro:LAttrEvalAdapterComputeAstHeader

    public abstract $1$ computeAstFor_$0$($1$ myAst, Heritage nodeHrtg
$


/*
 * @param 0     Current alternative name (Axxx)
 * @param 1     AST type name of alternative (Axxx)
 * @param 2     AST type name of production
 * @param 3     Current production name (Pxxx)
 */
Macro:LAttrEvalAdapterComputeAstHeader_delegateCreation

    public abstract $1$ computeAstFor_$0$(Heritage nodeHrtg
$


/*
 * @param 0     parameter name main component (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterFormalParam_node
,
        $1$ $2$$0$
$

/*
 * @param 0     parameter name main component (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterFormalParam_list
,
        List $2$List$0$
$

/*
 * @param 0     parameter name main component (e. g. child node name, element name)
 * @param 1     formal parameter type
 * @param 2     parameter name prefix (e. g. "child", "ast" ...)
 */
Macro:LAttrEvalAdapterFormalParam_tree
,
        $1$ $2$Tree$0$
$

Macro:LAttrEvalAdapterComputeAstHeaderTail
) throws AttrEvalException;

$

/*
 * @param 0     AST type name of alternative (not: of production)
 */
Macro:LAttrEvalAdapterComputeAstBodyIntro
$

Macro:LAttrEvalAdapterComputeAstBodyTail
$






/*
 * @param none
 */
Macro:LAttrEvalAdapterTail
}

$


Macro:AttrEvalException
/* This file was generated by SableCC (http://www.sablecc.org/). */

/* Generator for LAttrEvalAdapter written by Ansgar Konermann */
/* (c) 2004, 2005 Ansgar Konermann                            */
/* Contact: <konermann@itikko.net>                            */

package $0$;

import $1$.*;

public class AttrEvalException extends Exception
{
    Token token = null;

    public AttrEvalException(String  message, Token token) {
        super(message);
        this.token = token;
    }

    public AttrEvalException(String message, Throwable cause) {
        super(message, cause);
    }

    public AttrEvalException(String message) {
        super(message);
    }

    public Token getToken() {
        return token;
    }
    public void setToken(Token tk) {
        this.token = token;
    }
    public boolean hasToken() {
        return token != null;
    }

    public String getMessage() {
        if ( ! this.hasToken() ) {
            return super.getMessage();
        } else {
            StringBuffer sb = new StringBuffer(512);
            sb.append(super.getMessage());
            if ( this.hasToken() ) {
                Token tok = this.getToken();
                sb.append(": at position ");
                sb.append(tok.getLine());
                sb.append(',');
                sb.append(tok.getPos());
                sb.append(" (line,col) for token '");
                sb.append(tok.getText());
                sb.append("', token type");
                sb.append(tok.getClass().getName());
            }
            return sb.toString();
        }
    }
}

$


