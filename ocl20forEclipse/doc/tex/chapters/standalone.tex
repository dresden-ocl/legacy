\chapter{Standalone -- Using DresdenOCL outside of Eclipse}
\label{chapter:standalone}
\lstset{language=Java}

\begin{flushright}
\textit{Chapter written by Michael Thiele}
\end{flushright}

Although \acl{DOT4Eclipse} is targeted at the Eclipse platform, it can be used outside of it as a standalone application. All GUI components cannot be used, but all the core components like model loading, model instance loading, parsing OCL constraints, interpreting them or generating AspectJ code out of them are available.


\section{The Example Application}

The easiest way to use the standalone application is to check out the provided example at \code{https://dresden-ocl.svn.sourceforge.net/svnroot/dresden-ocl/trunk/ocl20forEclipse/\linebreak[0]stand\-a\-lone/\linebreak[0]tudresden.ocl20.pivot.standalone.example}. It can be used as a Eclipse Java project (not plug-in project), can be imported into Netbeans or can be used from the command line as an Eclipse runtime is not required. The structure of the example is described below.


\subsection{Classpath}

The \reference{lib} folder contains all libraries that are needed when executing the example. This includes several Eclipse jar files as well as stringtemplate.jar that is needed for the code generation facilities of the application and others. The \reference{plugins} folder contains all jar files that are provided by \acl{DOT4Eclipse}. When using the example as an Eclipse or Netbeans project all jars are already on the classpath. When using the command line or other tools, you probably have to put these jars on the classpath by hand.


\subsection{Resources}

The \reference{resources} folder has three sub-folders. In \reference{constraints} the OCL constraint files for three different examples are located. The \reference{model} folder contains the model files. Note, that in order to use the Java models, you need the appropriate .class files that are contained in a folder structure that represents the package name of the classes. Also, all classes that are referenced by the model need to be located in the folder structure or have to be on the classpath. Otherwise, a \lstinline[breaklines=true]{NoClassDefFoundError} will be thrown. The \reference{modelInstance} folder contains model instance files that again, in the case of Java model instances, have the same conditions as described for Java models.

\subsection{Logging}

In order to log different parts of \acl{DOT4Eclipse}, you can alter the \reference{log4j.properties} file. There, two appenders and a root logger are already defined. In order to log only specific parts of the toolkit, for example, you can enter: \code{log4j.logger.tudresden.ocl20.pivot.in\-ter\-pre\-ter\linebreak[0]=\linebreak[0]debug, stdout} that puts all log messages of the interpreter on the console (please be aware that this will significantly slow down the execution time).

\subsection{Using the Example}

The \reference{src} folder contains one class, named \code{StandaloneDresdenOCLExample.java}. It contains a \code{main} method that executes numerous examples. 

\paragraph{Royals \& Loyals}
The first example is Royals \& Loyals. The model is loaded by calling \code{load\-UML\-Mo\-del\linebreak[0](File, File)} on the \code{StandaloneFacade}. The method takes 2 arguments, the first being the file where the UML model is located. The second argument needs to be a file that points to the resources jar of the Eclipse UML project. In the example project, this jar file is located at \reference{lib/org.eclipse.uml2.uml.resources\_3.0.0.v200906011111.jar}. The example UML model provided here was built using Eclipse UML 3.x. In order to load older models, you have to update the namespace in line 2 of the model (\code{xmlns:uml="http://www.eclipse.org/uml2/3.0.0/UML"}) or use an older resources jar file. You have to provide the resources to be able to use primitive types in your model that are not mapped correctly when no or the wrong resource is specified.

Then, the Java model instance is loaded. Note, that this needs to be a class that has a method with this signature: \lstinline[breaklines=true]{public static List<Object> getModelObjects()}. In the returned list all objects that shall be part of the model instance have to be contained. The actual loading is done by calling \lstinline[breaklines=true]{StandaloneFacade.INSTANCE.loadJavaModelInstance(IModel, File)}.

Parsing and interpretation should be self explanatory. The method \lstinline[breaklines=true]{StandaloneFacade.INSTANCE.interpretEverything(IModelInstance, List<Constraint>)} returns a list of \code{I\-In\-ter\-pre\-ta\-tion\-Re\-sult}s that contain the context (\code{getModelObject()}), the executed constraint (\code{get\-Con\-straint()}) and the result of the interpretation (\code{getResult()}).

In order to generate AspectJ code, one needs to define the \code{IOcl22CodeSettings} first. The settings can be created by \code{Ocl22JavaFactory.getInstance().createJavaCodeGenera\-tor\-Set\-tings()}. There are lots of non obligatory settings; only the directory where the code should be generated to has to be specified invariably. Afterwards the code can be generated calling \code{StandaloneFacade.INSTANCE.generateAspectJCode(List<Constraint>, IOcl22\-Code\-Set\-tings)}.

\paragraph{PML}
The PML example is nearly analogous to the Royals \& Loyals example described above. Before being able to load an Ecore model instance, you have to register the Ecore model at the global Ecore registry. In case of PML this is done by the lines 
\lstset{language=Java}
\begin{lstlisting}
Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap()
  .put("pml", new XMIResourceFactoryImpl());
PmlPackage.eINSTANCE.eClass();
\end{lstlisting}
Other Ecore models require other factory mappings and their package to be initialised.

\paragraph{Simple}
The difference to the other examples is the model instance that is not loaded from a class file, but built in the example itself. To create an empty Java model instance call 
\lstset{language=Java}
\begin{lstlisting}
IModelInstance modelInstance = new JavaModelInstance(model);
\end{lstlisting}
Calling the method \lstinline[breaklines=true]{addModelInstanceElement(Object)} on the model instance will cause the given object to be adapted to the model instance. Thus, constraints can be evaluated on it.


\section{The Standalone Facade}

The example already contains a jar file of the the facade. In order to change the implementation of the StandaloneFacade, check out the Java project available in the SVN \code{https://dresden-ocl.svn\linebreak[0].source\-forge\linebreak[0].net/\linebreak[0]svnroot/dresden-ocl/} at \code{trunk/ocl20forEclipse/standalone/tudresden\linebreak[0].ocl\-20\linebreak[0].pi\-vot\linebreak[0].stand\-a\-lone\linebreak[0].facade}.

\subsection{Classpath and OCL Standard Library}
The project contains all needed jars in the folders \reference{lib} and \reference{plugins} like the example. The \reference{resources} folder also needs to be on the classpath. It contains the modelled version of the OCL standard library. If you want to use your own version of the OCL standard library, you can manipulate the given file or create a new one and change the \lstinline[breaklines=true]{initialize(URL)} method in the \code{StandaloneFacade} to point to your version.

\subsection{Adding and Removing Methods}
The central class for standalone applications is the \code{StandaloneFacade}. Adding new methods to the facade should pose no problems as long as all needed libraries are on the classpath. If the facade offers too much possibilities, you can delete all methods you do not need. Then, you are able to remove libraries from the classpath that are no longer needed (e.g., all UML related jar files when loading UML models is not an option). Thus, you can significantly reduce the size of needed libraries for standalone applications.


\section{Summary}

The chapter showed how to use \acl{DOT4Eclipse} without Eclipse. An extensive example has been explained and how to modify the standard behaviour of the standalone facade that should be used by standalone applications.