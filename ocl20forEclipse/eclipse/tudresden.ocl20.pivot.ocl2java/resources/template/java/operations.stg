group javaOperations;

// ---- TEMPLATES FOR JAVA OPERATIONS ----
// ---------------------------------------

// --- Abs Operation ---
absOperation(sourceExp, resultType) ::= <<
java.lang.Math.abs($sourceExp$)
>>

// --- AllInstances Operation ---
allInstancesOperation(sourceExp, typeName) ::= <<
(new $setTypeInitialization()$<$typeName$>((java.util.Set<$typeName$>) allInstances.get($sourceExp$.class.getCanonicalName()).keySet()))
>>

// --- And Operation ---
andOperation(sourceExp, argsExp) ::= <<
($sourceExp$ && $argsExp$)
>>

// --- OrderedSet.append(T) ---
appendOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.append($sourceExp$, $argsExp$)
>>

// --- Sequence.append(T) ---
appendOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.append($sourceExp$, $argsExp$)
>>

// --- Bag.asBag() ---
asBagOperationOnBag(sourceExp) ::= <<
$bagUtility()$.asBag($sourceExp$)
>>

// --- Collection.asBag() ---
asBagOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.asBag($sourceExp$)
>>

// --- OrderedSet.asBag() ---
asBagOperationOnOrderedSet(sourceExp) ::= <<
$orderedSetUtility()$.asBag($sourceExp$)
>>

// --- Sequence.asBag() ---
asBagOperationOnSequence(sourceExp) ::= <<
$sequenceUtility()$.asBag($sourceExp$)
>>

// --- Set.asBag() ---
asBagOperationOnSet(sourceExp) ::= <<
$setUtility()$.asBag($sourceExp$)
>>

// --- Bag.asOrderedSet() ---
asOrderedSetOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.asOrderedSet($sourceExp$)
>>

// --- Collection.asOrderedSet() ---
asOrderedSetOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.asOrderedSet($sourceExp$)
>>

// --- OrderedSet.asOrderedSet() ---
asOrderedSetOperationOnOrderedSet(sourceExp) ::= <<
$orderedSetUtility()$.asOrderedSet($sourceExp$)
>>

// --- Sequence.asOrderedSet() ---
asOrderedSetOperationOnSequence(sourceExp) ::= <<
$sequenceUtility()$.asOrderedSet($sourceExp$)
>>

// --- Set.asOrderedSet() ---
asOrderedSetOperationOnSet(sourceExp) ::= <<
$setUtility()$.asOrderedSet($sourceExp$)
>>

// --- Bag.asSequence() ---
asSequenceOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.asSequence($sourceExp$)
>>

// --- Collection.asSequence() ---
asSequenceOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.asSequence($sourceExp$)
>>

// --- OrderedSet.asSequence() ---
asSequenceOperationOnOrderedSet(sourceExp) ::= <<
$orderedSetUtility()$.asSequence($sourceExp$)
>>

// --- Set.asSequence() ---
asSequenceOperationOnSet(sourceExp) ::= <<
$setUtility()$.asSequence($sourceExp$)
>>

// --- Sequence.asSequence() ---
asSequenceOperationOnSequence(sourceExp) ::= <<
$sequenceUtility()$.asSequence($sourceExp$)
>>

// --- Bag.asSet() ---
asSetOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.asSet($sourceExp$)
>>

// --- Collection.asSet() ---
asSetOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.asSet($sourceExp$)
>>

// --- OrderedSet.asSet() ---
asSetOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.asSet($sourceExp$)
>>

// --- Set.asSet() ---
asSetOperationOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.asSet($sourceExp$)
>>

// --- Sequence.asSet() ---
asSetOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.asSet($sourceExp$)
>>

// --- OrderedSet.at(Integer) ---
atOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.at($sourceExp$, $argsExp$)
>>

// --- Sequence.at(Integer) ---
atOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.at($sourceExp$, $argsExp$)
>>

// --- At Operation on String ---
atOnStringOperation(sourceExp, argsExp) ::= <<
Character.toString($sourceExp$.charAt($argsExp$ - 1))
>>

// --- Characters Operation ---
charactersOperation(sourceExp, resultVar, elementName) ::= <<
$sequenceType()$<$stringType()$> $resultVar$;
$resultVar$ = new $sequenceTypeInitialization()$<$stringType()$>();

/* Compute the result of a characters operation. */
for ($stringType()$ $elementName$ : $sourceExp$.split("")) {
    $resultVar$.add($elementName$);
}

/* Remove the first element ''. */
$resultVar$.remove($sequenceUtility()$.first($resultVar$));

>>

// --- Concat Operation ---
concatOperation(sourceExp, argsExp) ::= <<
$sourceExp$.concat($argsExp$)
>>

// --- Collection.count(T) ---
countOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.count($sourceExp$, $argsExp$)
>>

// --- Bag.count(T) ---
countOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.count($sourceExp$, $argsExp$)
>>

// --- Sequence.count(T) ---
countOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.count($sourceExp$, $argsExp$)
>>

// --- Set.count(T) ---
countOperationOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.count($sourceExp$, $argsExp$)
>>

// --- Div Operation ---
divOperation(sourceExp, argsExp) ::= <<
($sourceExp$ / $argsExp$)
>>

// --- Division Operation ---
divisionOperation(sourceExp, argsExp) ::= <<
($sourceExp$ / $argsExp$)
>>


// --- Division Operation On Integer ---
divisionOnIntegerOperation(sourceExp, argsExp) ::= <<
(new $realType()$ ($sourceExp$) / new $realType()$ ($argsExp$))
>>


// --- Equals Operation ---
equalsOperation(sourceExp, argsExp) ::= <<
$sourceExp$.equals($argsExp$)
>>

// --- Equals Ignore Case Operation ---
equalsIgnorCaseOperation(sourceExp, argsExp) ::= <<
$sourceExp$.equalsIgnorCase($argsExp$)
>>

// --- Bag.=(Bag(T)) ---
equalsOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.equals($sourceExp$, $argsExp$)
>>

// --- Collection.=(Collection) ---
equalsOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.equals($sourceExp$, $argsExp$)
>>

// --- Sequence.=(Sequence(T)) ---
equalsOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.equals($sourceExp$, $argsExp$)
>>

// --- Set.=(Set(T)) ---
equalsOperationOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.equals($sourceExp$, $argsExp$)
>>

// --- Equals Operation on Primitive Types ---
equalsOperationOnPrimitiveType(sourceExp, argsExp) ::= <<
(($anyType()$) $sourceExp$).equals($argsExp$)
>>


// --- Collection.excludes(T) ---
excludesOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.excludes($sourceExp$, $argsExp$)
>>

// --- Collection.excludesAll(Collection(T)) ---
excludesAllOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.excludesAll($sourceExp$, $argsExp$)
>>

// --- Bag.excluding(T) ---
excludingOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.excluding($sourceExp$, $argsExp$)
>>

// --- Sequence.excluding(T) ---
excludingOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.excluding($sourceExp$, $argsExp$)
>>

// --- Set.excluding(T) ---
excludingOperationOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.excluding($sourceExp$, $argsExp$)
>>

// --- OrderedSet.first() ---
firstOperationOnOrderedSet(sourceExp) ::= <<
$orderedSetUtility()$.first($sourceExp$)
>>

// --- Sequence.first() ---
firstOperationOnSequence(sourceExp) ::= <<
$sequenceUtility()$.first($sourceExp$)
>>

// --- Collection.flatten() ---
flattenOperationOnCollection(sourceExp, argsExp, resultType) ::= <<
($resultType$) $collectionUtility()$.flatten($sourceExp$)
>>

// --- Bag.flatten() ---
flattenOperationOnBag(sourceExp, argsExp, resultType) ::= <<
($resultType$) $bagUtility()$.flatten($sourceExp$)
>>

// --- Sequence.flatten() ---
flattenOperationOnSequence(sourceExp, argsExp, resultType) ::= <<
($resultType$) $sequenceUtility()$.flatten($sourceExp$)
>>

// --- Set.flatten() ---
flattenOperationOnSet(sourceExp, argsExp, resultType) ::= <<
($resultType$) $setUtility()$.flatten($sourceExp$)
>>

// --- Floor Operation ---
floorOperation(sourceExp) ::= <<
(new $integerType()$(new Double(java.lang.Math.floor($sourceExp$)).intValue()))
>>


// --- Greater Operation ---
greaterOperation(sourceExp, argsExp) ::= <<
($sourceExp$ > $argsExp$)
>>


// --- GreaterEquals Operation ---
greaterEqualsOperation(sourceExp, argsExp) ::= <<
($sourceExp$ >= $argsExp$)
>>


// --- Implies Operation ---
impliesOperation(sourceExp, argsExp) ::= <<
(!$sourceExp$ || $argsExp$)
>>


// --- Collection.includes(T) ---
includesOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.includes($sourceExp$, $argsExp$)
>>

// --- Collection.includesAll(Collection(T)) ---
includesAllOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.includesAll($sourceExp$, $argsExp$)
>>

// --- Bag.including(T) ---
includingOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.including($sourceExp$, $argsExp$)
>>

// --- Sequence.including(T) ---
includingOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.including($sourceExp$, $argsExp$)
>>

// --- Set.including(T) ---
includingOperationOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.including($sourceExp$, $argsExp$)
>>

// --- OrderedSet.indexOf(T) ---
indexOfOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.indexOf($sourceExp$, $argsExp$)
>>

// --- Sequence.indexOf(T) ---
indexOfOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.indexOf($sourceExp$, $argsExp$)
>>

// --- IndexOf Operation on String ---
indexOfOnStringOperation(sourceExp, argsExp) ::= <<
$sourceExp$.indexOf($argsExp$) + 1
>>

// --- OrderedSet.insertAt(Integer, T) ---
insertAtOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.insertAt($sourceExp$, $argsExp:{arg | $arg$}; separator = ", "$)
>>

// --- Sequence.insertAt(Integer, T) ---
insertAtOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.insertAt($sourceExp$, $argsExp:{arg | $arg$}; separator = ", "$)
>>

// --- Bag.intersection(Bag(T)) and Bag.intersection(Set(T)) ---
intersectionOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.intersection($sourceExp$, $argsExp$)
>>

// --- Set.intersection(Bag(T)) and Set.intersection(Set(T)) ---
intersectionOperationOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.intersection($sourceExp$, $argsExp$)
>>

// --- Collection.isEmpty() ---
isEmptyOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.isEmpty($sourceExp$)
>>

// --- OrderedSet.last() ---
lastOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.last($sourceExp$)
>>

// --- Sequence.last() ---
lastOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.last($sourceExp$)
>>

// --- Lesser Operation ---
lesserOperation(sourceExp, argsExp) ::= <<
($sourceExp$ < $argsExp$)
>>

// --- LesserEquals Operation ---
lesserEqualsOperation(sourceExp, argsExp) ::= <<
($sourceExp$ <= $argsExp$)
>>


// --- Max Operation ---
maxOperation(sourceExp, argsExp) ::= <<
java.lang.Math.max($sourceExp$, $argsExp$)
>>

// --- Collection.max() ---
maxOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.max($sourceExp$)
>>

// --- Min Operation ---
minOperation(sourceExp, argsExp) ::= <<
java.lang.Math.min($sourceExp$, $argsExp$)
>>

// --- Collection.min() ---
minOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.min($sourceExp$)
>>


// --- Minus Operation ---
minusOperation(sourceExp, argsExp) ::= <<
($sourceExp$ - $argsExp$)
>>


// --- Set.minus(Set(T)) ---
minusOperationOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.minus($sourceExp$, $argsExp$)
>>


// --- Multiply Operation ---
multiplyOperation(sourceExp, argsExp) ::= <<
($sourceExp$ * $argsExp$)
>>


// --- Modulo Operation ---
modOperation(sourceExp, argsExp) ::= <<
($sourceExp$ % $argsExp$)
>>


// --- Negative Operation ---
negativeOperation(sourceExp) ::= <<
-($sourceExp$)
>>


// --- Not Operation ---
notOperation(sourceExp) ::= <<
!$sourceExp$
>>


// --- Collection.notEmpty() ---
notEmptyOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.notEmpty($sourceExp$)
>>


// --- NotEquals Operation ---
notEqualsOperation(sourceExp, argsExp) ::= <<
!$sourceExp$.equals($argsExp$)
>>

// --- Collection.<>(Collection(T)) ---
notEqualsOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.notEquals($sourceExp$, $argsExp$)
>>

// --- NotEquals Operation on Primitive Types ---
notEqualsOperationOnPrimitiveType(sourceExp, argsExp) ::= <<
!(($anyType()$) $sourceExp$).equals($argsExp$)
>>

// --- OclAsType Operation ---
oclAsTypeOperation(sourceExp, argsExp) ::= <<
(($argsExp$) $sourceExp$)
>>


// --- OclIsInvalid Operation ---
oclIsInvalidOperation(sourceExp) ::= <<
($sourceExp$ == null)
>>


// --- OclIsNew Operation ---
oclIsNewOperation(sourceExp) ::= <<
this.newInstances.containsKey($sourceExp$)
>>


// --- OclIsKindOf Operation ---
oclIsKindOfOperation(sourceExp, argsExp) ::= <<
($sourceExp$ instanceof $argsExp$)
>>


// --- OclIsTypeOf Operation ---
oclIsTypeOfOperation(sourceExp, argsExp) ::= <<
$sourceExp$.getClass().getCanonicalName().equals("$argsExp$")
>>


// --- OclIsUndefined Operation ---
oclIsUndefinedOperation(sourceExp) ::= <<
($sourceExp$ == null)
>>


// --- Or Operation ---
orOperation(sourceExp, argsExp) ::= <<
($sourceExp$ || $argsExp$)
>>


// --- OclIsTypeOf Operation ---
oclTypeOperation(sourceExp, argsExp) ::= <<
$sourceExp$.getClass()
>>


// --- Plus Operation ---
plusOperation(sourceExp, argsExp) ::= <<
($sourceExp$ + $argsExp$)
>>


// --- Plus Operation on String ---
plusOnStringOperation(sourceExp, argsExp) ::= <<
$sourceExp$.concat($argsExp$)
>>

// --- Sequence.prepend(T) ---
prependOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.prepend($sourceExp$, $argsExp$)
>>

// --- OrderedSet.prepend(T) ---
prependOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.prepend($sourceExp$, $argsExp$)
>>

// --- Collection.product(Collection(T)) ---
productOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.product($sourceExp$, $argsExp:{arg | $arg$}; separator = ", "$)
>>

// --- OrderedSet.reverse() ---
reverseOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.reverse($sourceExp$)
>>

// --- Sequence.reverse() ---
reverseOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.reverse($sourceExp$)
>>

// --- Round Operation ---
roundOperation(sourceExp) ::= <<
java.lang.Math.round($sourceExp$)
>>

// --- Collection.size() ---
sizeOperationOnCollection(sourceExp) ::= <<
$collectionUtility()$.size($sourceExp$)
>>


// --- Size on String Operation ---
sizeOnStringOperation(sourceExp) ::= <<
$sourceExp$.length()
>>

// --- OrderedSet.subOrderedSet(Integer, Integer) ---
subOrderedSetOperationOnOrderedSet(sourceExp, argsExp) ::= <<
$orderedSetUtility()$.subOrderedSet($sourceExp$, $argsExp:{arg | $arg$}; separator = ", "$)
>>

// --- Sequence.subSequence() ---
subSequenceOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.subSequence($sourceExp$, $argsExp:{arg | $arg$}; separator = ", "$)
>>

// --- Substring Operation ---
substringOperation(sourceExp, argsExp) ::= <<
$sourceExp$.substring($argsExp:{arg | $arg$}; separator = " - 1, "$)
>>

// --- Collection.sum() ---
sumOperationOnCollection(sourceExp, argsExp) ::= <<
$collectionUtility()$.sum($sourceExp$)
>>

// --- Set.symmatricDifference(Set(T)) ---
symmetricDifferenceOperationOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.symmetricDifference($sourceExp$, $argsExp$)
>>

// --- ToBoolean Operation ---
toBooleanOperation(sourceExp) ::= <<
Boolean.parseBoolean($sourceExp$)
>>


// --- ToInteger Operation ---
toIntegerOperation(sourceExp) ::= <<
Integer.parseInt($sourceExp$)
>>


// --- ToReal Operation ---
toRealOperation(sourceExp) ::= <<
Float.parseFloat($sourceExp$)
>>


// --- ToString Operation ---
toStringOperation(sourceExp) ::= <<
$sourceExp$.toString()
>>


// --- ToLowerCase Operation ---
toLowerCaseOperation(sourceExp) ::= <<
$sourceExp$.toLowerCase()
>>


// --- ToUpperCase Operation ---
toUpperCaseOperation(sourceExp) ::= <<
$sourceExp$.toUpperCase()
>>


// --- UML Operation ---
umlOperation(operationName, sourceExp, argsExp) ::= <<
$sourceExp$.$operationName$($argsExp:{arg | $arg$}; separator = ", "$)
>>


// --- Bag.union(Bag(T)) and Bag.union(Set(T)) ---
unionOperationOnBag(sourceExp, argsExp) ::= <<
$bagUtility()$.union($sourceExp$, $argsExp$)
>>

// --- Sequence.union(Sequence.union(T)) ---
unionOperationOnSequence(sourceExp, argsExp) ::= <<
$sequenceUtility()$.union($sourceExp$, $argsExp$)
>>

// --- Set.union(Bag(T)) ---
unionOperationWithBagOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.unionWithBag($sourceExp$, $argsExp$)
>>

// --- Set.union(Set(T)) ---
unionOperationWithSetOnSet(sourceExp, argsExp) ::= <<
$setUtility()$.unionWithSet($sourceExp$, $argsExp$)
>>


// --- Xor Operation ---
xorOperation(sourceExp, argsExp) ::= <<
($sourceExp$ ^ $argsExp$)
>>


// ---- SOME OPERATION NAMES USED IN OTHER TEMPLATES ----
// ------------------------------------------------------

// --- Add Operation Name ---
addOperationName() ::= <<
add
>>

// --- AddAll Operation Name ---
addAllOperationName() ::= <<
addAll
>>

// --- Name for the method to manually check Invariants ---
checkInvariantsOperationName() ::= <<
checkInvariants
>>

// --- Name for the method to deeply clone Objects ---
deepCopyOperationName() ::= <<
createCopy
>>

// --- Utility Class for Bag Operations ---
bagUtility() ::= <<
tudresden.ocl20.pivot.ocl22java.types.util.OclBags
>>

// --- Utility Class for Collection Operations ---
collectionUtility() ::= <<
tudresden.ocl20.pivot.ocl22java.types.util.OclCollections
>>

// --- Utility Class for OrderedSet Operations ---
orderedSetUtility() ::= <<
tudresden.ocl20.pivot.ocl22java.types.util.OclOrderedSets
>>

// --- Utility Class for Sequence Operations ---
sequenceUtility() ::= <<
tudresden.ocl20.pivot.ocl22java.types.util.OclSequences
>>

// --- Utility Class for Set Operations ---
setUtility() ::= <<
tudresden.ocl20.pivot.ocl22java.types.util.OclSets
>>