/*
    Copyright (C) 2007  Nils (s0006383@inf.tu-dresden.de)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

public aspect AtPreResolver {
	public void OclFileAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		List packageList = getPackagedConstraintASList();
		if (packageList == null) return;
		int packageNumber = getNumPackagedConstraintAS();
		
		for(int i = 0; i < packageNumber; i++) {
			getPackagedConstraintAS(i).resolveAtPre(env);
		}
	}
	
	public void PackagedConstraintAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		List contextList = getContextList();
		if (contextList == null) return;
		int contextNumber = getNumContext();
		
		for(int i = 0; i < contextNumber; i++) {
			getContext(i).resolveAtPre(env);
		}
	}
	
	abstract public void ContextAS.resolveAtPre(AtPreEnvironment env) throws AtPreException;
	
	public void OperationContextAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		List constraintList = getOperationConstraintASList();
		if (constraintList == null) return;
		
		int constraintNumber = getNumOperationConstraintAS();
		
		for(int i = 0; i < constraintNumber; i++) {
			AtPreEnvironment innerEnv = new AtPreEnvironment();
			innerEnv.setPredecessor(innerEnv);
			innerEnv.setPostConstraint(false);
			getOperationConstraintAS(i).resolveAtPre(innerEnv);
		}
		
		AtPreEnvironment innerEnv = new AtPreEnvironment();
		innerEnv.setPredecessor(env);
		innerEnv.setPostConstraint(false);
		getOperationSignatureAS().resolveAtPre(innerEnv);
	}
	
	public void ClassifierContextAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		List constraintList = getClassifierConstraintASList();
		if (constraintList == null) return;
		
		int constraintNumber = getNumClassifierConstraintAS();
		
		for(int i = 0; i < constraintNumber; i++) {
			AtPreEnvironment innerEnv = new AtPreEnvironment();
			innerEnv.setPredecessor(innerEnv);
			innerEnv.setPostConstraint(false);
			
			getClassifierConstraintAS(i).resolveAtPre(innerEnv);
		}
	}
	
	public void AttrOrAssocContextAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		List constraintList = getAttrOrAssocConstraintASList();
		if (constraintList == null) return;
		
		int constraintNumber = getNumAttrOrAssocConstraintAS();
		
		for(int i = 0; i < constraintNumber; i++) {
			AtPreEnvironment innerEnv = new AtPreEnvironment();
			innerEnv.setPredecessor(env);
			innerEnv.setPostConstraint(false);
			
			getAttrOrAssocConstraintAS(i).resolveAtPre(innerEnv);
		}
	}
	
	public void ConstraintAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		if (hasExpression()) {
			OclExpressionAS expression = getExpression();
			expression.resolveAtPre(env);
		}
		
	}
	
	public void OperationConstraintAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		TokenAS operationStereotype = getOperationStereotype();
		if (operationStereotype.getValue().equals("post")) {
			env.setPostConstraint(true);
		}
		else {
			env.setPostConstraint(false);
		}
		
		if (hasExpression()) getExpression().resolveAtPre(env);
	}
	
	public void DefOperationConstraintAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		super.resolveAtPre(env);
		getSignature().resolveAtPre(env);
	}
	
	public void DefAttributeConstraintAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		super.resolveAtPre(env);
		getAttributeType().resolveAtPre(env);
	}
	
	public void OperationSignatureAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		int variableNumber = getNumVariableAS();
		for(int i = 0; i < variableNumber; i++) {
			getVariableAS(i).resolveAtPre(env);
		}
	}
	
	abstract public void TypeAS.resolveAtPre(AtPreEnvironment env) throws AtPreException;
	
	public void PathNameAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		// nothing to do
	}
	
	public void TupleTypeAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		int variableNumber = getNumVariableAS();
		for(int i = 0; i < variableNumber; i++) {
			getVariableAS(i).resolveAtPre(env);
		}
	}
	
	public void CollectionTypeAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		// nothing to do
	}
	
	abstract public void OclExpressionAS.resolveAtPre(AtPreEnvironment env) throws AtPreException;
	
	public void TupleLiteralExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		List tupleLiteralParts = getPartsList();
		if (tupleLiteralParts == null) return;
		
		int partNumber = getNumParts();
		
		for(int i = 0; i < partNumber; i++) {
			getParts(i).resolveAtPre(env);
		}
	}
	
	public void TupleLiteralPartAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		OclExpressionAS expression = getExpression();
		if (expression == null) return;
		expression.resolveAtPre(env);
		
		getVariable().resolveAtPre(env);
	}
	
	public void CollectionLiteralExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		List collectionParts = getCollectionLiteralPartASList();
		if (collectionParts == null) return;
		
		int partNumber = getNumCollectionLiteralPartAS();
		
		for(int i = 0; i < partNumber; i++) {
			getCollectionLiteralPartAS(i).resolveAtPre(env);
		}
	}
	
	abstract public void CollectionLiteralPartAS.resolveAtPre(AtPreEnvironment env) throws AtPreException;
	
	public void CollectionRangeAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		OclExpressionAS first = getFirst();
		OclExpressionAS last = getLast();
		
		if (first != null) first.resolveAtPre(env);
		if (last != null)last.resolveAtPre(env);
	}
	
	public void CollectionItemAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		OclExpressionAS item = getItem();
		if (item == null) return;
		item.resolveAtPre(env);
	}
	
	public void PrimitiveLiteralExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		// nothing to do
	}
	
	public void LetExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		OclExpressionAS in = getIn();
		if (in == null) return;
		in.resolveAtPre(env);
		
		int variableNumber = getNumVariable();
		for(int i = 0; i < variableNumber; i++) {
			getVariable(i).resolveAtPre(env);
		}
	}
	
	public void IfExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		OclExpressionAS condition = getCondition();
		OclExpressionAS thenExpression = getThenExpression();
		OclExpressionAS elseExpression = getElseExpression();
		
		if (condition != null) condition.resolveAtPre(env);
		if (thenExpression != null) thenExpression.resolveAtPre(env);
		if (elseExpression != null ) elseExpression.resolveAtPre(env);
	}
	
	public void CallExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		//OclExpressionAS source = getSource();
		if (hasSource()) getSource().resolveAtPre(env);
	}
	
	public void LoopExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		OclExpressionAS body = getBody();
		if (body != null) body.resolveAtPre(env);
		super.resolveAtPre(env);
	}
	
	/**
	 * An @pre is not allowed to be placed in a constraint other than a post-constraint. So, if
	 * such a case exists an exception is thrown with the line and column of the @pre.
	 */
	public void FeatureCallExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		super.resolveAtPre(env);
		if (hasAtPre()) getAtPre();
		if ((hasAtPre()) && (!env.isPostConstraint()))
			throw new AtPreException("An @pre-Element was found at a position where it is not allowed." +
					" The constraint isn't a post constraint.", getAtPre());
		
	}
	
	public void OperationCallExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		super.resolveAtPre(env);
		List argumentList = getArgumentList();
		if (argumentList == null) return;
		int argumentNumber = getNumArgument();
		/*System.out.println("In OperationCallExpAS resolveAtPre ");
		System.out.println("Number of arguments " + argumentNumber);*/
		
		for(int i = 0; i < argumentNumber; i++) {
			try {
			getArgument(i).resolveAtPre(env);
			}
			catch(Exception ex) {
				ex.printStackTrace();
			}
		}
	}
	
	public void PropertyCallExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		super.resolveAtPre(env);
		List qualifierList = getQualifierList();
		if (qualifierList == null) return;
		int qualifierNumber = getNumQualifier();
		
		for(int i = 0; i < qualifierNumber; i++) {
			getQualifier(i).resolveAtPre(env);
		}
	}
	
	public void VariableExpAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		getVariable().resolveAtPre(env);
	}
	
	public void VariableAS.resolveAtPre(AtPreEnvironment env) throws AtPreException {
		if (hasExpression()) getExpression().resolveAtPre(env);
	}
	
	
}
