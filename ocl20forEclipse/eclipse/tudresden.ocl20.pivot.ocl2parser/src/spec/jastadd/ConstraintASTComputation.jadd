/*
    Copyright (C) 2008  Nils (s0006383@inf.tu-dresden.de)

    This file is part of the OCL parser of the Dresden OCL2 for Eclipse.

    The OCL parser is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The OCL parser is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with the OCL parser.  If not, see <http://www.gnu.org/licenses/>.
.
*/

public aspect ConstraintASMComputation {
	abstract public Constraint ConstraintAS.computeASM(Environment env) throws BuildingASMException;
	
	abstract public Constraint AttrOrAssocConstraintAS.computeASM(Environment env) throws BuildingASMException;
	
	/*
	 * OCL-Specification:
	 * 
	 * attrOrAssocContextCS ::= 'context' pathNameCS '::' simpleName ':' typeCS initOrDerValueCS
	 */
	public Constraint AttrOrAssocConstraintAS.computeASM(Environment env, ConstraintKind kind) throws BuildingASMException {
		// Get the expression factory.
		EssentialOclFactory factory = env.getExpFactory();
		
		// Compute the expression.
		OclExpression expression = getExpression().computeASM(env);
		
		// Compute the string of the expression.
		String bodyString = getExpression().computeBodyString();
		
		// Surround the expression in an expression-in-ocl.
		Variable selfVariable = env.getSelfVariable();
		if (selfVariable == null) throw new BuildingASMException("The property 'self' was not found. In this case it is internal error.", null);
		
		ExpressionInOcl oclExpression = null;
		try {
			oclExpression = factory.createExpressionInOcl(bodyString, expression, selfVariable, null, null);
		}
		catch(Throwable th) {
			String message = th.getMessage() + " The ExpressionInOcl-instance could not be built.";
			throw new BuildingASMException(message, null);
			
		}
			
		// Build the constraint.
		Constraint constraint = null;
		try {
			constraint = factory.createConstraint("", kind, oclExpression, null, env.getContext());
		}
		catch(Throwable th) {
			String message = th.getMessage() + " The constraint could not be built.";
			throw new BuildingASMException(message, null);
		}
			
		return constraint;
	}
	
	/*
	 * OCL-Specification:
	 * 
	 * [A] initOrDerValueCS[1] ::= 'init' ':' OclExpression initOrDerValue[2]?
	 * [B] initOrDerValueCS[1] ::= 'derive' ':' OclExpression initOrDerValueCS[2]?
	 */
	public Constraint InitAttrOrAssocConstraintAS.computeASM(Environment env) throws BuildingASMException {
		ConstraintKind kind = ConstraintKind.get(ConstraintKind.INITIAL_VALUE);
		return computeASM(env, kind);
	}
	
	
	public Constraint DeriveAttrOrAssocConstraintAS.computeASM(Environment env) throws BuildingASMException {
		ConstraintKind kind = ConstraintKind.get(ConstraintKind.DERIVED_VALUE);
		return computeASM(env, kind);
	}
	
	
	abstract public Constraint ClassifierConstraintAS.computeASM(Environment env) throws BuildingASMException;
	abstract public Constraint DefClassifierConstraintAS.computeASM(Environment env) throws BuildingASMException;
	
	/*
	 * OCL-Specification:
	 * 
	 * classifierContextDeclCS ::= 'context' pathNameCS invOrDefCS
	 * 
	 * [B] invOrDefCS[1] ::= 'def' (simpleNameCS)? ':' defExpressionCS invOrDefCS[2]
	 * 
	 * [A] defExpressionCS ::= VariableDeclarationCS '=' OclExpression
	 *
	 * Meaning:
	 * This rule denotes an attribute definition.
	 */
	public Constraint DefAttributeConstraintAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		EssentialOclFactory factory = env.getExpFactory();
		
		// Get the optional name of the definition if any was specified.
		String optionalName = null;
		if (hasName()) optionalName = getName().getValue();
		
		// Compute the expression.
		OclExpression expression = getExpression().computeASM(env);
		
		// Compute the string representation of the expression.
		String bodyString = getExpression().computeBodyString();
		
		// Compute the type of the defined property.
		Type propertyType = getAttributeType().computeASM(env);
		
		// Get the attribute name.
		String propertyName = getAttributeName().getValue();
		
		/* The expression type must be a type that conforms to the given attribute type. This implies
		 * that the expression type can be a sub type of the attribute type. If this check fails
		 * it is an error.
		 */
		if (!(expression.getType().conformsTo(propertyType))) throw new BuildingASMException("The type of the" +
				" new defined property and the type of the expression do not match.", getAttributeName());
		
		// Create a new property with the computed name and type.
		Property property = null;
		try {
			property = PivotModelFactory.INSTANCE.createProperty();
		}
		catch(Throwable th) {
			String message = th.getMessage() + " A property could not be built.";
			throw new BuildingASMException(message, null);
		}
		
		property.setName(propertyName);
		property.setType(propertyType);
		//property.setOwningType(env.getSelf());
		
		/* Create an ocl expression with the computed elements. Because this is a definition a result variable and a
		 * parameter list are not necessary.
		 */
		Variable selfVariable = env.getSelfVariable();
		if (selfVariable == null) throw new BuildingASMException("The property 'self' was not found. In this case it is internal error.", null);
		
		ExpressionInOcl oclExpression = null;
		try {
			oclExpression = factory.createExpressionInOcl(bodyString, expression, selfVariable, null, null);
		}
		catch(Throwable th) {
			String message = th.getMessage() + " A ExpressionInOcl-instance could not be built.";
			throw new BuildingASMException(message, null);
		}
				
		/* Create the constraint with the computed elements. The constrainable element of this constraint is the
		 * created property.
		 */
		Constraint constraint = null;
		try {
			/*
			 * Here we must notice a constraint the ocl specification:
			 * context ExpressionInOcl
			 *		def: isDefinitionConstraint : Boolean = self.constraint.stereotype.name = ‘definition’
			 *				and
			 *				self.constraint.constrainedElement->size() = 1
			 *				and
			 *				self.constraint.constrainedElement.any(true).oclIsKindOf(Classifier)
			 */
			constraint = factory.createConstraint(optionalName, ConstraintKind.get("definition"), oclExpression, property, selfVariable.getType());
			constraint.setDefinedFeature(property);
		}
		catch(Throwable th) {
			String message = th.getMessage() + " The constraint could not be built.";
			throw new BuildingASMException(message, null);
		}
		
		
		// The property must be added to the self type because this property can be used in other expressions.
		env.getSelfVariable().getType().addProperty(property);
		return constraint;
	}
	
	/*
	 * OCL-Specification:
	 * 
	 * classifierContextDeclCS ::= 'context' pathNameCS invOrDefCS
	 * 
	 * [B] invOrDefCS[1] ::= 'def' (simpleNameCS)? ':' defExpressionCS invOrDefCS[2]
	 * 
	 * [B] defExpression ::= operationCS '=' OclExpression
	 * 
	 * Meaning:
	 * This rule denotes an operation definition.
	 */
	public Constraint DefOperationConstraintAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		EssentialOclFactory factory = env.getExpFactory();
		
		// Get the optional definition name if any exists.
		String optionalName = null;
		if (hasName()) optionalName = getName().getValue();
		
		// Compute the operation signature.
		OperationSignatureContainer signature = getSignature().computeASM(env);
		
		// Get the return type of the defined operation.
		Type returnType = signature.getResultType();
			
		// Get the defined method name.
		String methodName = getMethodName().getValue();
		
		// Create an operation.
		Operation operation = null;
		try {
			operation = PivotModelFactory.INSTANCE.createOperation();
		}
		catch(Throwable th) {
			String message = th.getMessage() + " An operation could not be built by the pivot model factory.";
			throw new BuildingASMException(message, null);
		}
		
		operation.setName(methodName);
		operation.setType(returnType);
		//operation.setOwningType(env.getSelf());
		
		// Create an inner environment.
		Environment innerEnv = env.nestedEnvironment();
		
		// Iterate over all parameters of the signatures and add them to the operation.
		Iterator it = signature.getParameterList().iterator();
		while(it.hasNext()) {
			Variable var = (Variable) it.next();
			
			/*Parameter param = null;
			try {
				param = PivotModelFactory.INSTANCE.createParameter();
			}
			catch(Throwable th) {
				String message = th.getMessage() + " A paramter could not be built by the pivot model factory.";
				throw new BuildingASMException(message, null);
			}
			
			param.setType(var.getType());
			param.setName(var.getName());
			param.setOperation(operation);
			param.setKind(ParameterDirectionKind.get("inout"));*/
			//operation.addParameter(param);
			operation.addParameter(var.asParameter());
			
			// Add the variable to the explicit variables of the environment.
			innerEnv.addExplicitVariable(var);
		}
		
		/* The operation has a special type namely the return parameter. So we build a new parameter with
		 * the return type and the mark it as return value.
		 */
		Parameter resultParameter = null;
		try {
			resultParameter = PivotModelFactory.INSTANCE.createParameter();
		}
		catch(Throwable th) {
			String message = th.getMessage() + " A result parameter could not be built by the pivot model factory.";
			throw new BuildingASMException(message, null);
		}
		
		resultParameter.setType(returnType);
		resultParameter.setOperation(operation);
		resultParameter.setKind(ParameterDirectionKind.get(ParameterDirectionKind.RETURN_VALUE));
		operation.addParameter(resultParameter);
				
		// Compute the expression.
		OclExpression expression = getExpression().computeASM(innerEnv);
		
		// Compute the string representation of the expression.
		String bodyString = getExpression().computeBodyString();
		
		/*
		 * Examine whether the expression type conforms to the declared operation return type. Note that the
		 * expression type can be a sub type of the declared type. If this check fails it is an error.
		 */
		if (!expression.getType().conformsTo(returnType)) throw new BuildingASMException("The defined" +
				" operation type must match the type of the expression.", getMethodName());
		
		// Create the ocl expression with the computed elements.
		Variable selfVariable = env.getSelfVariable();
		if (selfVariable == null) throw new BuildingASMException("The property 'self' was not found. In this case it is internal error.", null);
		
		
		ExpressionInOcl oclExpression = null;
		try {
			oclExpression = factory.createExpressionInOcl(bodyString, expression, selfVariable, null, null);
		}
		catch(Throwable th) {
			String message = th.getMessage() + " An ExpressionInOcl-instance could not be built.";
			throw new BuildingASMException(message, null);
		}
		
		
		// Create the constraint.
		Constraint constraint = null;
		try {
			/*
			 * Here we must notice a constraint the ocl specification:
			 * context ExpressionInOcl
			 *		def: isDefinitionConstraint : Boolean = self.constraint.stereotype.name = ‘definition’
			 *				and
			 *				self.constraint.constrainedElement->size() = 1
			 *				and
			 *				self.constraint.constrainedElement.any(true).oclIsKindOf(Classifier)
			 */
			constraint = factory.createConstraint(optionalName, ConstraintKind.get("definition"), oclExpression, operation, selfVariable.getType());
			constraint.setDefinedFeature(operation);
		}
		catch(Throwable th) {
			String message = th.getMessage() + " A constraint could not be built.";
			throw new BuildingASMException(message, null);
		}
		
		
		// Add the new operation to the self type.
		env.getSelfVariable().getType().addOperation(operation);
		
		return constraint;
	}
	
	/*
	 * OCL-Specification:
	 * 
	 * classifierContextCS ::= 'context' pathNameCS invOrDefCS
	 * 
	 * [A] invOrDefCS[1] ::= 'inv' (simpleNameCS)? ':' OclExpressionCS invOrDefCS[2]
	 */
	public Constraint InvClassifierConstraintAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		EssentialOclFactory factory = env.getExpFactory();
		
		// Compute the expression.
		OclExpression expression = getExpression().computeASM(env);
		
		// Compute the string representation of the expression.
		String bodyString = getExpression().computeBodyString();
		
		// Get the optional name of the invariant expression if any exists.
		String optionalName = null;
		if (hasName()) optionalName = getName().getValue();
		
		// Create a new primtivie type of boolean.
		PrimitiveType primType = env.getOclLibrary().getOclBoolean();
		
		// We compute an error token to denote the error position in the source code.
		TokenAS errorToken = null;
		try {
			errorToken = getExpression().computeErrorToken();
		}
		catch(ErrorTokenComputationException ex) {
			throw new BuildingASMException("Trying to compute an error token is faild. Internal error. " + ex.getMessage(), null);
		}
		
		
		// Examine whether the expression is of type boolean. If not then it is an error.
		if(!(expression.getType().conformsTo(primType))) throw new BuildingASMException("The expression type must be boolean.", errorToken);
		
		// Create the ocl expression.
		Variable selfVariable = env.getSelfVariable();
		if (selfVariable == null) throw new BuildingASMException("The self variable was not found. In this case it is internal error.", null);
		
		ExpressionInOcl oclExpression = null;
		try {
			oclExpression = factory.createExpressionInOcl(bodyString, expression, selfVariable, null, null);
		}
		catch(Throwable th) {
			String message = th.getMessage() + " A ExpressionInOcl-instance could not be built.";
			throw new BuildingASMException(message, null);
		}
		
		
		// Create the constraint.
		Constraint constraint = factory.createConstraint(optionalName, ConstraintKind.get("invariant"), oclExpression, null, selfVariable.getType());
		
		return constraint;
	}
	
	/*
	 * OCL-Specification:
	 * 
	 * operationContextDeclCS ::= 'context' operationCS prePostOrBodyDeclCS
	 * 
	 * [A] prePostOrBodyDeclCS ::= 'pre' (simpleNameCS)' ':' OclExpressionCS prePostBodyDeclCS[2]
	 * [B] prePostOrBodyDeclCS ::= 'post' (simpleNameCS)' ':' OclExpressionCS prePostBodyDeclCS[2]
	 * [C] prePostOrBodyDeclCS ::= 'body' (simpleNameCS)' ':' OclExpressionCS prePostBodyDeclCS[2]
	 */
	public Constraint OperationConstraintAS.computeASM(Environment env) throws BuildingASMException {
		EssentialOclFactory factory = env.getExpFactory();
		
		Operation operation = (Operation)env.getContext();
		String operationStereotype = getOperationStereotype().getValue();
		
		Variable resultVariable = null;
		if (operationStereotype.equals("body")) {
			resultVariable = factory.createVariable("result", operation.getType(), null);
			env.addExplicitVariable(resultVariable);
		}
		// Compute the expression.
		OclExpression expression = getExpression().computeASM(env);
		
		// Compute the string representation of the expression.
		String bodyString = getExpression().computeBodyString();
		
		
		
		// Get the optional name of the invariant expression if any exists.
		String optionalName = null;
		if (hasName()) optionalName = getName().getValue();
		
		if ((operationStereotype.equals("pre") || (operationStereotype.equals("post")))) {
			
			
			// Create a new primtivie type of boolean.
			PrimitiveType primType = env.getOclLibrary().getOclBoolean();
			
			// We compute an error token to denote to the error position in the source code.
			TokenAS errorToken = null;
			try {
				errorToken = getExpression().computeErrorToken();
			}
			catch(ErrorTokenComputationException ex) {
				throw new BuildingASMException("Trying to compute an error token was failed. Internal error. " + ex.getMessage(), null);
			}
			// Examine whether the expression is of type boolean. If not then it is an error.
			if(!expression.getType().conformsTo(primType)) throw new BuildingASMException("The expression type must be boolean.", null);
			
			// Create the ocl expression.
			Variable selfVariable = env.getSelfVariable();
			if (selfVariable == null) throw new BuildingASMException("The property 'self' was not found. In this case it is internal error.", null);
			
			ExpressionInOcl oclExpression = factory.createExpressionInOcl(bodyString, expression, selfVariable, null, null);
			
			// Create the constraint.
			Constraint constraint = null;
			if (operationStereotype.equals("pre")) {
				constraint = factory.createConstraint(optionalName, ConstraintKind.get("precondition"), oclExpression, null, operation);
			}
			
			if (operationStereotype.equals("post")) {
				constraint = factory.createConstraint(optionalName, ConstraintKind.get("postcondition"), oclExpression, null, operation);
			}
			return constraint;
		}
		
		if (operationStereotype.equals("body")) {
			if (!expression.getType().conformsTo(operation.getType())) throw new BuildingASMException("The expression type" +
					" must match the operation return type in the context.", getOperationStereotype());
			
			// Create the ocl expression.
			Variable selfVariable = env.getSelfVariable();
			if (selfVariable == null) throw new BuildingASMException("The property 'self' was not found. In this case it is internal error.", null);
			
			ExpressionInOcl oclExpression = factory.createExpressionInOcl(bodyString, expression, selfVariable, resultVariable, null);
			Constraint constraint = factory.createConstraint(optionalName, ConstraintKind.get("body"), oclExpression, null, operation);
			return constraint;
		}
		
		throw new BuildingASMException("The stereotype of the operation constraint is unkown.", getOperationStereotype());
	}
}