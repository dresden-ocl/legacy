Implemented Test Packages:
==========================
* Constraint Types
  + Body Expressions
  + Definitions
  + Derive Expressions
  + Init Expressions
  + Invariants
  + Postconditions
  + Preconditions
* Expressions
  + BooleanLiteralExp
  + CollectionLiteralExpression
    - Standard Init
    - Ranges
  + EnumLiteralExp
  + IntegerLiteralExp
  + IfExp
  + IterateExp
  + (IteratorExp are tested with the standard library, because they are just
     predefined IterateExpressions)
  + LetExp
  + OperationCallExp
    + obligatory self variable
    + obligatory asSet() operation for non-collection types
    + static operations
    + special operation allInstances() (uses . Operator!!!)
    + special operation @pre
      * non allowed on static properties
      * only allowed in postconditions.
  + PropertyCallExp
    + obligatory self variable
    + static properties
    + When the name of an association-end is missing at one of the ends of an
      association, the name of the type at the association end starting with a
      lower case character is used as the role name.
  + RealLiteralExp
  + StringLiteralExp
  + TupleLiteralExp
  + TypeLiteralExp
  + VariableExp
    + self
    + argument variables if context is operation
    + result variable
* Namespace and Context
  + Context Expressions
    - Positives and Negatives (Types and Operation contexts)
    - Multiple result context unique/ordered -> Set, OrderedSet etc.
  + Package Expression
    - Positives and Negatives
* StandardLibrary      
  + Collection
    - asBag()
    - asOrderedSet()
    - asSequence()
    - asSet()
    - count(T)
    - excludes(T)
    - excludesAll(Collection(T))
    - flatten()
    - includes(T)
    - includesAll(Collection(T))
    - isEmpty()
    - max() (OCL 2.1)
    - min() (OCL 2.1)
    - notEmpty()
    - product(Collection(T))
    - size()
    - sum()
  + Integer
    - a.-(), -a
    - a.+(b), a + b
    - a.-(b), a - b
    - a.*(b), a * b
    - a./(b), a / b (result type is real)
    - abs()
    - a.div(b) (result type is integer)
    - a.mod(b)
    - a.max(b)
    - a.min(b)
    - toString() (OCL 2.1)
  + OclAny
    - a.=(b), a = b
    - a.<>(b), a <> b
    - oclAsType(Type)
    - oclIsInvalid()
    - oclIsKindOf(Type)
    - oclIsNew()
      * only in postconditions valid
    - oclIsTypeOf(Type)
    - oclIsUndefined()
    - oclType() (OCL 2.1)
  + Real
    - a.+(b), a + b
    - a.-(b), a - b
    - a.*(b), a * b
    - a.-(), -a
    - a./(b), a / b
    - a.<(b), a < b
    - a.>(b), a > b 
    - a.<=(b), a <= b
    - a.>=(b), a >= b
    - abs()
    - floor()
    - a.max(b)
    - a.min(b)
    - round()
    - toString() (OCL 2.1)
  + String
    - a.+(b), a + b
    - at(Integer) (OCL 2.1)
    - characters(): Sequence(String) (OCL 2.1)
    - concat(String)
    - equalsIgnoreCase(String) (OCL 2.1)
    - indexOf(String) (OCL 2.1) (index starts with 1)
    - size()
    - substring(lower, upper), (lower starts with 1)
    - toBoolean() (OCL 2.1)
    - toInteger()
    - toLowerCase() (OCL 2.1)
    - toReal()
    - toUpperCase() (OCL 2.1)
  + Boolean
    - and(Boolean)
    - implies(Boolean)
    - not Boolean
    - or(Boolean)
    - toString() (OCL 2.1)
    - xor(Boolean)


Planned Test Cases:
===================
* StandardLibrary      
  + Set
    - union(Set(T))
    - union(Bag(T))
    - intersection(Set(T))
    - intersection(Bag(T))
    - -(Set(T))
    - including(T)
    - excluding(T)
    - symmetricDifference(Set(T))
    - count(T)
    
...    
  
    
Continue reading Standard from Chapter 11.7.3

Readme?
Manifest
Add to general test suite?
    
StandardLibrary:
================
False IMPLIES anything is True, anything IMPLIES True is True

The IF-expression is another exception. It will be valid as long as 
the chosen branch is valid, irrespective of the value of the other branch.
OclVoid = object is true, if object is undefined (Spec 2.1 p. 140)
OclInvalid = object is true, if object is invalid (Spec 2.1 p. 140)
Collection->isEmpty(): null->isEmpty() returns true! (Spec 2.1 p. 150)
Collection->notEmpty(): null->notEmpty() returns false! (Spec 2.1 p. 150)