/*
    Copyright (C) 2007  Nils (s0006383@inf.tu-dresden.de)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

public aspect TypeASMComputation {
	abstract public Type TypeAS.computeASM(Environment env) throws BuildingASMException;
	
	public Type PathNameAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		IModelFactory factory = env.getExpFactory();
		
		// Get the first token for error message.
		TokenAS token = getTokenAS(0);
		
		// Transform the list of tokens into a list of strings.
		java.util.List stringList = new ArrayList();
		int numberToken = getNumTokenAS();
		for(int i = 0; i < numberToken; i++) {
			stringList.add(getTokenAS(i).getValue());
		}
		
		// With this list search for the type in the environment.
		Type type = env.lookupType(stringList);
		
		// If no type was found, it is an error.
		if (type == null) throw new BuildingASMException("The type was not found.", token);
		
		// Return the type.
		return type;
	}
	
	/*
	 * OCL-Specification:
	 * 
	 * collectionTypeCS ::= collectionTypeIdentifierCS '(' typeCS ')'
	 * 
	 * [A] CollectionTypeIdentifierCS ::= 'Set'
	 * [B] CollectionTypeIdentifierCS ::= 'Bag'
	 * [C] CollectionTypeIdentifierCS ::= 'Sequence'
	 * [D] CollectionTypeIdentifierCS ::= 'Collection'
	 * [E] CollectionTypeIdentifierCS ::= 'OrderedSet'
	 */
	public Type CollectionTypeAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		IModelFactory factory = env.getExpFactory();
		
		// Get the ocl library for building the collections types.
		OclLibrary library = env.getOclLibrary();
		
		// Compute the inner type of the collection type.
		Type innerType = getType().computeASM(env);
		
		// Get the token for the collection name to be built for error handling.
		TokenAS token = getName();
		
		// Get the name of the collection type.
		String collectionName = token.getValue();
		
		Type collectionType = null;
		
		// Build the collection from the collection name with the inner type.
		if (collectionName.equals("Bag")) collectionType = library.getBagType(innerType);
		if (collectionName.equals("Sequence")) collectionType = library.getSequenceType(innerType);
		if (collectionName.equals("Set")) collectionType = library.getSetType(innerType);
		if (collectionName.equals("OrderedSet")) collectionType = library.getOrderedSetType(innerType);
		if (collectionName.equals("Collection")) collectionType = library.getCollectionType(innerType);
		
		// If no collection name suffice, it is an error.
		if (collectionType == null) throw new BuildingASMException("The collection type is not valid.", token);
		
		// Return the collection type.
		return collectionType;
	}
	
	/*
	 * OCL-Specification:
	 * 
	 * tupleTypeCS ::= 'Tuple' '(' variableDeclarationListCS ')'
	 */
	public Type TupleTypeAS.computeASM(Environment env) throws BuildingASMException {
		// Get the expression factory.
		IModelFactory factory = env.getExpFactory();
		
		// The error token.
		TokenAS errorToken = null;
		if (getNumVariableAS() > 0)	errorToken = getVariableAS(0).getName();
		
		// Get the ocl library for building the collections types.
		OclLibrary library = env.getOclLibrary();
		
		// Create a list of properties.
		java.util.List variableList = new ArrayList();
		
		// Get the number of variables.
		int numberVariable = getNumVariableAS();
		
		// Iterate over all variables.
		for(int i = 0; i < numberVariable; i++) {
			// Transform the variable as instance into an variable.
			Variable var = getVariableAS(i).computeASM(env);
			
			// Get the token of the variable for error handling.
			TokenAS variableToken = getVariableAS(i).getName();
			
			// Examine whether the variable has an init expression. If so, it is an error.
			// OCL-Specification, page 79, Disambiguating rule [1]
			if (var.getInitExpression() != null) throw new BuildingASMException("The variable may not" +
					" have an init expression in a tuple type definition.", variableToken);
			
			// All variables must have a type. If no type exists, it is an error.
			// OCL-Specification, page 79, Disambiguating rule [1]
			if (var.getType() == null) throw new BuildingASMException("The variable must have" +
					" a type in the tuple type definition.", variableToken);
			
			// Add the variable as property to the list.
			variableList.add(var.asProperty());
		}
		
		// Make a tuple type with the ocl library.
		Type type = library.makeTupleType(variableList);
		
		// If null is returned, an error occured while building the tuple type.
		if (type == null) throw new BuildingASMException("An error occurs while building the tuple type.", errorToken);
		
		// Return the type.
		return type;
		
	}
}