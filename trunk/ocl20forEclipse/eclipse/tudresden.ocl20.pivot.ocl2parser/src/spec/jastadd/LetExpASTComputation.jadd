/*
    Copyright (C) 2007  Nils (s0006383@inf.tu-dresden.de)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * This aspect computes the ast for the let expression.
 */
public aspect LetExpASMComputation {
	/*
	 * OCL-Specification:
	 * 
	 * LetExpCS ::= 'let' VariableDeclarationCS LetExpSubCS
	 * 
	 * [A] LetExpSubCS[1] ::= ',' VariableDeclarationCS LetExpSubCS[2]
	 * [B] LetExpSubCS ::= 'in' OclExpressionCS
	 * 
	 * Notice:
	 * All this rules of the specification are realized by this compute-method.
	 * The let subexpressions are in the variable list of the LetExpAS-instance.
	 */
	public LetExp LetExpAS.computeASM(Environment env) throws BuildingASMException {
		// Get the model factory to create the let expression.
		IModelFactory factory = env.getExpFactory();
		
		// Create a new inner environment for the variables.	
		Environment innerEnv = env.nestedEnvironment();
		
		// Create a new list of variables.
		java.util.List variableList = new ArrayList();
		
		// Iterate over all VariableAS instance of the LetExpAS
		for(int i = 0; i < getNumVariable(); i++) {
			// Get an VariableAS instance
			VariableAS varAS = getVariable(i);
			
			// Examine whether the variable has a type. If not, it is an error (OCL Spec, page 87, disambiguating rule 2).
			if (varAS.hasType() == false) throw new BuildingASMException("The variable has no type.", varAS.getName());
			
			// Examine whether the variable has an init expression. If not, it is an error (OCL Spec, page 87, disambiguating rule 2)
			if (varAS.hasExpression() == false) throw new BuildingASMException("The variable has no valid init expression.", varAS.getName());
			
			// Compute the variable with the inner envirnoment. Note that
			// this environment collect the variables in this for-loop.
			// So no variable declared before the next computation can declared twice,
			// for example in the ocl init expression of the variable.
			Variable var = varAS.computeASM(innerEnv);
			
			/*
			// Examine whether the variable has an init expression. If not, it is an error (OCL Spec, page 87, disambiguating rule 2)
			if (var.getInitExpression() == null) throw new BuildingASMException("The variable has no valig init expression.", varAS.getName());
			
			// Examine whether the variable has a type. If not, it is an error (OCL Spec, page 87, disambiguating rule 2).
			if (var.getType() == null) throw new BuildingASMException("The variable has no type.", varAS.getName());
			
			*/
			
			// Try to insert the variable in the inner environment. If the inserting is not successfully done, then the
			// variable already was declared and this an error (OCL Spec, page 87, disambiguating rule 1).
			boolean result = innerEnv.addVariable(var);
			if (result == false) throw new BuildingASMException("The variable already exists.", varAS.getName());
			
			// Add the variable into the variable list
			variableList.add(var);
		}
		
		// Compute the in expression of this LetExpAS. Note that all variable are hold
		// in the inner environment. It is different from the specification where the variables
		// are added into nested let expressions.
		OclExpression in = getIn().computeASM(innerEnv);
		
		// Now we must construct the nested let exp with the variable of the variable list. Note
		// that at this time the variable hold in the inner environment don't appear in the
		// let epxression even build.
		
		// We need a temporary let expression variable to swap the in expression with the whole let expression.
		OclExpression tempLetExp = in;
		
		// This variable saves the end let expression.
		LetExp letExp = null;
		
		// Now we iterate over all the variables in the variable list in the reverse order. So
		// the last variable will be the last variable in the last let expression.
		for(int i = variableList.size(); i != 0; i--) {
			// Get the variable.
			Variable var =  (Variable) variableList.get(i-1);
			
			// Create a let expression with the variable and the temporary let expression.
			// Note that the first temporary let expression is the in expression computed so far.
			// In the first iteration the variable is the last variable.
			letExp = factory.createLetExp(var, tempLetExp);
			
			// Swap let expresion with the temporary let expression. So the temporary let expression
			// becomes the current let expression. In the next iteration it becomes the
			// the in expression of the next let expression.
			tempLetExp = letExp;
		}
		
		// Return the last let expression of the for loop. That is the full
		// cunstructed let expression with all nested variable.
		return letExp;
	}
}