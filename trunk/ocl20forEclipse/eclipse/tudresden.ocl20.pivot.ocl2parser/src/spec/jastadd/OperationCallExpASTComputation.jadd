/*
    Copyright (C) 2008  Nils (s0006383@inf.tu-dresden.de)

    This file is part of the OCL parser of the Dresden OCL2 for Eclipse.

    The OCL parser is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The OCL parser is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with the OCL parser.  If not, see <http://www.gnu.org/licenses/>.
.
*/

public aspect OperationCallExpASMComputation {
	/*
	 * This method serves as a switch. If the source expression exists and the type of the source expression
	 * is of the type collection type, then compute an iterator expression, otherwise an operation call expression.
	 */
	public CallExp OperationCallExpAS.computeASM(Environment env) throws BuildingASMException {
		if (!hasSource()) return computeOperationASM(env);
		
		/*
		 * If the a source expression exists and this source expression is a collection then we must
		 * examine whether the original expression is simple mathematical expression or an expression
		 * with a dot. If it is a dot expression then we must build an implicit iterator expression
		 * with the operation 'collect'. If this expression is mathematical then it is a normal
		 * operation call expression.
		 */
		Environment innerEnv = env.nestedEnvironment();
		OclExpression sourceExpression = getSource().computeASM(innerEnv);
		
		/*
		 * The source expression can be null. In this case the source expression denotes a type.
		 * This type is saved in the environment. 
		 * 
		 */
		if (sourceExpression == null) {
			Type sourceType = innerEnv.getSourceType();
			
			TokenAS errorToken = null;
			try {
				errorToken = getSource().computeErrorToken();
			} catch(ErrorTokenComputationException ex) {
				String message = ex.getMessage() + " An internal error occured. A ErrorTokenComputationException was thrown.";
				throw new BuildingASMException(message, null);
				
			}
			if (sourceType == null) throw new BuildingASMException("An internal error occured.", errorToken);
			
			if ((sourceType instanceof CollectionType) && (getDotExpression() == true)) return computeIteratorASM(env);
			
			return computeOperationASM(env);
		}
		if ((sourceExpression.getType() instanceof CollectionType) && (getDotExpression() == true)) return computeIteratorASM(env);
		
		return computeOperationASM(env);
	}
	
	public OperationCallExp OperationCallExpAS.computeOperationASM(Environment env) throws BuildingASMException {
		/* Rules of the operation call expression [OCL Specification, page 80 and 81]
		 * [A] OperationCallExpCS ::= OclExpressionCs[1] simpleNameCs OclExpression[2]
		 * [B] OperationCallExpCS ::= OclExpressionCs[1] '->' simpleNameCs '(' argumentsCs? ')'
		 * [C] OperationCallExpCS ::= OclExpressionCs '.' simpleNameCs '(' argumentsCs? ')'
		 * [D] OperationCallExpCS ::= simpleNameCs '(' argumentsCs? ')'
		 * [E] OperationCallExpCS ::= OclExpressionCs '.' simpleNameCs isMarkedPreCs '(' argumentsCs? ')'
		 * [F] OperationCallExpCS ::= simpleNameCs isMarkedPreCs '(' argumentsCs? ')'
		 * [G] OperationCallExpCS ::= pathNameCs '(' argumentsCs ')'
		 * [H] OperationCallExpCS ::= simpleNameCs OclExpressionCs
		 * 
		 * Rule A: binary mathematical expressions
		 * Rule B: calling a collection operation
		 * Rule C: calling a type operation
		 * Rule D: calling an implicit operation
		 * Rule E: calling a type operation with @pre
		 * Rule F: calling an implicit type operation with @pre
		 * Rule G: calling a static operation
		 * Rule H: unary mathematical expression (the source was set by the parser, it is the OclExpressionCs)
		 */
		IModelFactory factory = env.getExpFactory();
		Environment nestedEnvironment = env.nestedEnvironment();
		
		OclExpression[] arguments = null; //getArgumentArray(env);
		
		TokenAS token = getName().getTokenAS(0);
		String operationName = (String) getName().getTokenAS(0).getValue();
		
		
		
		/* Since the fabric method of the IModelFactory that creates the operation call expression
		 * require a source expression, an operation name and a list of arguments, this method stands
		 * for the cases A, B, C, E and H in the OCL-Specification [page 80 and 81, Nonterminal OperationCallExpCS].
		 */
		if ((hasSource()) && (getName().getNumTokenAS() <= 1)) {
			
				OclExpression sourceExpression = getSource().computeASM(nestedEnvironment);
				
				/*
				 * If the source expression denotes a type then we get null from the compute method,
				 * but the computed type was saved in the environment. So we get this type and lookup for
				 * the operation name at this type. If we found one, we must examine whether the operation
				 * is static. If so, we can create a static operation call expression.
				 */
				if (sourceExpression == null) {
					// Get the source type from the environment.
					Type sourceType = nestedEnvironment.getSourceType();
					
					// If the source type is null, it is an error.
					if (sourceType == null) throw new BuildingASMException("An internal error occured.", token);
					
					/*
					 * If the operation name denotes a special ocl operation we must compute the arguments in
					 * a special manner.
					 */
					if (operationName.equals("oclIsKindOf") || operationName.equals("oclIsTypeOf") || operationName.equals("oclAsType")) {
						arguments = computeSpecialOclOperationArguments(env, token);
					} else { // This is no special ocl operation. So we compute the arguments normally.
						arguments = getArgumentArray(env);
					}
									
					java.util.List pathNameOperation = new ArrayList();
					pathNameOperation.add(sourceType.getName());
					pathNameOperation.add(operationName);
					
					// Try to create a static operation call expression.
					OperationCallExp returnExpression = null;
					try {
						returnExpression = factory.createOperationCallExp(pathNameOperation, arguments);
					}
					catch(Exception ex) {
						throw new BuildingASMException(ex.getMessage(), token);
					}
					
					return returnExpression;
				}
				
				
				/* This is case A, C, E and H in the OCL Specification [page 80 and 81, Nonterminal OperationCallExpCS] */
				if (getArrowRightExpression() == false) {
					
					/*
					 * If the operation is a special ocl operation we must change the parameter compution
					 * by setting the 'isSpecialOclOperation'-flag in the environment. Then we make some
					 * checks.
					 */
					if (operationName.equals("oclIsKindOf") || operationName.equals("oclIsTypeOf") || operationName.equals("oclAsType")) {
						arguments = computeSpecialOclOperationArguments(env, token);
					} else { // This is no special ocl operation. So we compute the arguments normally.
						arguments = getArgumentArray(env);
					}
					
					/* This is case E of the OCL-Specification [page 80 and 81, Nonterminal OperationCallExpCS] */
					//if (hasAtPre()) sourceExpression = sourceExpression.withAtPre();
					OperationCallExp returnExpression = null;
					try {
						returnExpression = factory.createOperationCallExp(sourceExpression, operationName, arguments);
					}
					catch(Exception ex) {
						String message = ex.getMessage();
						message = message + " The operation is invalid.";
						throw new BuildingASMException(message, token);
					}
					
					if (returnExpression == null) throw new BuildingASMException("The operation is invalid.", token);
					
					if (hasAtPre()) returnExpression = returnExpression.withAtPre();
					return returnExpression;
				}
				
				
				
				/* This is case B in the OCL Specification [page 80 and 81, Nonterminal OperationCallExpCS] */
				if (getArrowRightExpression() == true) {
					Type sourceType = sourceExpression.getType();
					
					if (!(sourceType instanceof CollectionType)) {
						sourceExpression = sourceExpression.withAsSet();
					}
					
					// We must compute the arguments.
					arguments = getArgumentArray(env);
					
					OperationCallExp returnExpression = null;
					try {
						returnExpression = factory.createOperationCallExp(sourceExpression, operationName, arguments);
					}
					catch(Exception ex) {
						String message = ex.getMessage();
						message = message + "The collection operation is invalid.";
						throw new BuildingASMException(message, token);
					}
					
					if (returnExpression == null) throw new BuildingASMException("The collection operation is invalid.", token);
					return returnExpression;
					
				}
				
			}
			
		/* This code are for the cases D and F of the OCL-Specification [page 80 and 81, Nonterminal OperationCallExpCS].
		 * The operation call has no source and the path name has a length of most of one.
		 */
		if (!hasSource() && (getName().getNumTokenAS() <= 1)) {
			/*
			 * If the operation name denotes a special ocl operation we must compute the arguments in
			 * a special manner.
			 */
			if (operationName.equals("oclIsKindOf") || operationName.equals("oclIsTypeOf") || operationName.equals("oclAsType")) {
				arguments = computeSpecialOclOperationArguments(env, token);
			} else { // This is no special ocl operation. So we compute the arguments normally.
				arguments = getArgumentArray(env);
			}
			
			// We transform the array of arguments in a list of arguments.
			java.util.List argumentList = new ArrayList();
			for(int i = 0; i < arguments.length; i++) {
				argumentList.add(arguments[i]);
			}
			
			
			 
			//Operation operation = env.lookupImplicitOperation(operationName, argumentList);
			
			// If no operation is found it is an error.
			//if (operation == null) throw new BuildingASMException("The operation was not found.", token);
			
			/* If no source exists, search for the operation in the implicit types of the environment.
			 * One of this type holds the operation and this type will be packed in a variable.
			 */
			//Variable sourceVariable = env.lookupImplicitSourceForOperation(operation);
			
			// If the operation has no owning type it is an strange error.
			/*if (sourceVariable == null) throw new BuildingASMException("This maybe an internal error." +
					" The implicit operation was found but the operation has no owning type.", token);
			*/
			/*
			 * The returned variable will be packed in a variable expression. So the source
			 * become a variable expression.
			 */
			//VariableExp variableExpression = factory.createVariableExp(sourceVariable);
			//OclExpression sourceExpression = variableExpression;
			
			
			/*Variable selfVariable = env.getSelfVariable();
			OclExpression sourceExpression = factory.createVariableExp(selfVariable);*/
			
			Variable implVariable = env.lookupImplicitOperation(operationName, argumentList);
			OclExpression sourceExpression = factory.createVariableExp(implVariable);
			
			/* This is case F of the OCL-Specifiation [page 80 and 81, Nonterminal OperationCallExpCS] */
			/*if (hasAtPre()) {
				sourceExpression = sourceExpression.withAtPre();
			}*/
			
			OperationCallExp operationCallExpression = null;
			try {
				operationCallExpression = factory.createOperationCallExp(sourceExpression, operationName, arguments);
			}
			catch(Exception ex) {
				String message = ex.getMessage();
				message = message + " The operation can't be build.";
				throw new BuildingASMException(message , token);
			}
			
			if (operationCallExpression == null) throw new BuildingASMException("The operation can't be build.", token);
			
			if (hasAtPre()) {
				operationCallExpression = operationCallExpression.withAtPre();
			}
			return operationCallExpression;
		}
		
		
		/* This is case G of the OCL-Specification [page 80 and 81, Nonterminal OperationCallExpCS]
		 * The operation call has no source and the path name denotes a static operation. 
		 */
		if (!hasSource() && (getName().getNumTokenAS() > 1)) {
			java.util.List pathNameList = new ArrayList();
			int numberToken = getName().getNumTokenAS();
			for(int i = 0; i < numberToken; i++) {
				pathNameList.add(getName().getTokenAS(i).getValue());
			}
			
			String staticOperationName = (String) pathNameList.get(pathNameList.size()-1);
			
			/*
			 * If the operation name denotes a special ocl operation we must compute the arguments in
			 * a special manner.
			 */
			if (staticOperationName.equals("oclIsKindOf") || staticOperationName.equals("oclIsTypeOf") || staticOperationName.equals("oclAsType")) {
				arguments = computeSpecialOclOperationArguments(env, token);
			} else { // This is no special ocl operation. So we compute the arguments normally.
				arguments = getArgumentArray(env);
			}
					
			OperationCallExp resultOperation = null;
			try {
				resultOperation = factory.createOperationCallExp(pathNameList, arguments);
			}
			catch(FactoryException ex) {
				String message = ex.getMessage();
				throw new BuildingASMException(message, token);
			}
			
			if (resultOperation == null) throw new BuildingASMException("An internal error occured.", token);
			
			return resultOperation;
			
		}
		
		throw new BuildingASMException("An internal error occured.", token);
		
		
	}
	
	/**
	 * This method transforms the list of arguments into a list of expressions.
	 * @param env the environment that is used to computed the arguments expressions
	 * @return an array of of ocl expressions that were computed from the arguments, it is never null
	 * @throws BuildingASMException this exception will be thrown if any error occurs while computing
	 * the argument expressions
	 */
	protected OclExpression[] OperationCallExpAS.getArgumentArray(Environment env) throws BuildingASMException {
		int numberArguments = getNumArgument();
		OclExpression[] arguments = new OclExpression[numberArguments];
		for(int i = 0; i < numberArguments; i++) {
			arguments[i] = getArgument(i).computeASM(env);
		}
		
		return arguments;
	}
	
	/**
	 * This method computes the arguments with the special ocl operation flag in the environemnt.
	 * So the result array must contains exactly one argument that is of type 'TypeLiteralExp'.
	 * @param token the error token that is used to generate an error message
	 * @return an array of one type literal expression
	 * @throws BuildingASMException is thrown if the returned array has more then one argument or
	 * the type of the element is incorret.
	 */
	protected OclExpression[] OperationCallExpAS.computeSpecialOclOperationArguments(Environment env, TokenAS token) throws BuildingASMException {
		Environment innerEnv = env.nestedEnvironment();
		innerEnv.setSpecialOclOperation(true);
		
		OclExpression[] arguments = getArgumentArray(innerEnv);

		if (arguments.length != 1) {
			throw new BuildingASMException(
					"The special"
							+ " ocl operation has exactly one parameter, but more then one were found.",
					token);
		}
		// no else.

		OclExpression argumentExpression;
		argumentExpression = arguments[0];

		/*
		 * Check if the argument expression is of the right type (OclType).
		 * First check generic types to avoid IllegalArgumentExceptions if
		 * getType() is null.
		 */
		boolean valid;

		/* Valid Generic Operation Call? */
		valid = (argumentExpression instanceof OperationCallExp
				&& ((OperationCallExp) argumentExpression)
						.getReferredOperation().getGenericType() != null && ((OperationCallExp) argumentExpression)
				.getReferredOperation().getGenericType().isConformant(
						env.getOclLibrary().getOclType()));

		/* Valid Generic Property Call? */
		if (!valid) {
			valid = (argumentExpression instanceof PropertyCallExp
					&& ((PropertyCallExp) argumentExpression)
							.getReferredProperty().getGenericType() != null && ((PropertyCallExp) argumentExpression)
					.getReferredProperty().getGenericType().isConformant(
							env.getOclLibrary().getOclType()));
		}
		// no else.

		/* Valid type? */
		if (!valid) {
			valid = (argumentExpression.getType() != null || argumentExpression
					.getType().conformsTo(env.getOclLibrary().getOclType()));
		}

		/* Valid Operation Call? */
		if (!valid) {
			valid = (argumentExpression instanceof OperationCallExp
					&& ((OperationCallExp) argumentExpression)
							.getReferredOperation().getType() != null && ((OperationCallExp) argumentExpression)
					.getReferredOperation().getType().conformsTo(
							env.getOclLibrary().getOclType()));
		}

		/* Valid Property Call? */
		if (!valid) {
			valid = (argumentExpression instanceof PropertyCallExp
					&& ((PropertyCallExp) argumentExpression)
							.getReferredProperty().getType() != null && ((PropertyCallExp) argumentExpression)
					.getReferredProperty().getType().conformsTo(
							env.getOclLibrary().getOclType()));
		}

		if (!valid) {
			throw new BuildingASMException("A special OCL operation must have"
					+ " exactly one expression resulting in a Type.", token);
		}
		// no else.

		return arguments;
	}
	
}