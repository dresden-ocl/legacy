group oracle;

// --- OCL INVARIANT --- 
constraint_body(constraint_name,context,context_alias,expression) ::= <<
CREATE OR REPLACE VIEW $constraint_name$ AS
(SELECT * FROM $context$ $context_alias$
WHERE NOT ($expression$));
>>

literal_collection_bag_item(item) ::= <<
SELECT $item$ AS elem FROM DUAL
>>


// ---  COLLECTIONS - SEQUENCE (QUERY) --- 
literal_collection_sequence(items) ::= <<
$items:literal_collection_sequence_item(); separator="\nUNION\n"$
>>

literal_collection_sequence_item(item) ::= <<
SELECT $item$ AS elem, $i$ AS seqno FROM DUAL
>>


// ---  COLLECTIONS - SET (QUERY) --- 
literal_collection_set_item(item) ::= <<
SELECT $item$ AS elem FROM DUAL
>>


// --- IF EXPRESSION ---
if_expression(if_branch,then_branch,else_branch) ::= <<
!!! no if-expressions supported !!!
>>


// -- ITERATOR FORALL (QUERY) ---
feature_call_forall(source,alias,object,collection,expression) ::= <<
NOT EXISTS (
  $collection$ MINUS
     SELECT $object$ FROM $source$ $alias$
     WHERE $expression$
  )
>>

// -- ITERATOR REJECT (QUERY) ---
feature_call_reject(source,alias,object,collection,expression) ::= <<
($collection$ MINUS
  SELECT $object$ FROM $source$ $alias$
  WHERE ($expression$))
>>

// -- ITERATOR SELECT (QUERY) ---
feature_call_select(source,alias,object,collection,expression) ::= <<
$collection$ MINUS
  SELECT $object$ FROM $source$ $alias$
  WHERE NOT ($expression$))
>>


// --- COLLECTION RELATED OPERATIONS ---
feature_call_count(source,element,collection,object) ::= <<
(SELECT NVL(COUNT(*),0)
  FROM $source$
  WHERE $element$ IN $collection$
  AND $element$ = $object$)
>>

feature_call_exists(source,object,collection,expression) ::= <<
EXISTS (
  ($collection$) INTERSECT
  SELECT $object$ FROM $source$
  WHERE $expression$
)
>>

feature_call_size(source,element,collection) ::= <<
(SELECT NVL(COUNT(*),0)
  FROM $source$
  WHERE $element$ IN $collection$)
>>

feature_call_sum(source,element,collection) ::= <<
(SELECT NVL(SUM($element$),0)
  FROM $source$
  WHERE $element$ IN $collection$)
>>

feature_call_excludes(object,collection) ::= <<
NOT EXISTS (
  SELECT $object$ FROM DUAL
  INTERSECT
  ($collection$))
>>

feature_call_includes(object,collection) ::= <<
EXISTS (
  SELECT $object$ FROM DUAL
  INTERSECT
  ($collection$))
>>

feature_call_excludesall(collection,collection2) ::= <<
NOT EXISTS (
  ($collection2$)
  INTERSECT
  ($collection$))
>>

feature_call_includesall(collection,collection2) ::= <<
NOT EXISTS (
  ($collection2$)
  MINUS
  ($collection$))
>>

feature_call_including_bag(collection,object) ::= <<
($collection$ UNION ALL
  SELECT $object$ FROM DUAL)
>>

feature_call_including_sequence(collection,object) ::= <<
($collection$)
  UNION
  (SELECT $object$, ((SELECT max(SEQNO) FROM ($collection$)) + 1) AS SEQNO FROM DUAL)
>>

feature_call_including_set(collection,object) ::= <<
($collection$ UNION
  SELECT $object$ FROM DUAL)
>>

feature_call_excluding_bag(collection,object,element) ::= <<
($collection$ MINUS
  SELECT $object$ FROM DUAL)
>>

feature_call_excluding_sequence(collection,object,element) ::= <<
SELECT $element$,
  (SELECT count(*)+1 FROM (
    SELECT $element$, SEQNO
    FROM $collection$
    WHERE NOT ($element$ = $object$)
  ) WHERE SEQNO < s.SEQNO) AS SEQNO
  FROM (
    SELECT $element$, SEQNO
    FROM $collection$
    WHERE NOT ($element$ = $object$)
  )
>>

feature_call_excluding_set(collection,object,element) ::= <<
($collection$ MINUS
  SELECT $object$ FROM DUAL)
>>

feature_call_union_bag(collection,collection2,element) ::= <<
($collection$ UNION ALL
  $collection2$)
>>

feature_call_string_concat(operand1,operand2) ::= <<
$operand1$ + $operand2$
>>

feature_call_string_substring(operand,start,end) ::= <<
SUBSTR($operand$, $start$, $end$ - $start$ + 1)
>>

feature_call_int_max(operand1,operand2) ::= <<
GREATEST ($operand1$,$operand2$)
>>

feature_call_int_min(operand1,operand2) ::= <<
LEAST ($operand1$,$operand2$)
>>

feature_call_int_mod(operand1,operand2) ::= <<
$operand1$ - $operand2$ * FLOOR($operand1$/$operand2$)
>>