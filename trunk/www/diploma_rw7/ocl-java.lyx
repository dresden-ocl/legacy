#This file was created by <wiera> Wed Dec  6 16:27:11 2000
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass report
\begin_preamble
\usepackage{textcomp}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Diploma Thesis:
\newline 
Utility Support for Checking OCL Business Rules in Java Programs
\newline 
---DRAFT---
\newline 
---scheduled for 12/2000---
\layout Author

Ralf Wiebicke
\layout Date

December 2000
\layout Section*

Copyright
\layout Standard

Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke.
\layout Standard

Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.1 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is available at http://www.gnu.org/copyleft/fdl.html.
\layout Standard

The source code developed together with this paper is Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke and published under the GNU Lesser General Public License
 (LGPL).
 Additional source code was developed by Steffen Zschaler under LGPL.
\layout Section*

Availability
\layout Standard

This document is available at http://dresden-ocl.
\family typewriter 
\SpecialChar \-

\family default 
sourceforge.
\family typewriter 
\SpecialChar \-

\family default 
net/
\family typewriter 
\SpecialChar \-

\family default 
diploma_rw7/ in several electronic forms including 
\latex latex 

\backslash 
LaTeX{}
\latex default 
, Postscript, PDF, HTML and the original kLyx version.
 
\layout Standard

The source code developed together with this paper is available at http://
\family typewriter 
\SpecialChar \-

\family default 
dresden-ocl.
\family typewriter 
\SpecialChar \-

\family default 
sourceforge.net/.
\layout Standard


\begin_inset LatexCommand \tableofcontents

\end_inset 


\layout Chapter

Introduction
\layout Standard

This work descibes the design and implementation of a tool providing runtime
 verification of OCL (Object Contraint Language) constraints in java programs.
 Therefore, the OCL compiler developed by Frank Finger 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 was extended by java source code instrumentation.
 This tool is able to 
\layout Standard

support the principals of Design by Contract in java.
\layout Standard

Wishlist in section 3.6.
 
\layout Chapter

Related Work
\layout Standard

This chapter lists both papers and software related to this diploma thesis.
 For some of the work there is a detailed comparison in subsequent chapters.
 
\layout Section

Runtime Constraint Checking 
\begin_inset LatexCommand \label{Sec:relatedConstraints}

\end_inset 


\layout Standard

This section lists tools, which perform runtime constraint checking on java
 programs, more or less similar to the tool developed in chapter 
\begin_inset LatexCommand \ref{Sec:chapterCodeInjection}

\end_inset 

.
 
\layout Standard

JMSAssert (
\begin_inset LatexCommand \cite{JMSAssert}

\end_inset 

) provides OCL support for java.
 Constraints are embedded into javadoc comments.
 The tool links into the JVM to make the constraints checked.
 This approach does not involve source code modification.
 This makes it easier to use, but also platform dependent (currently Windows
 only).
 It also requires just-in-time compilers to be switched off.
 Binaries are available at no cost.
\layout Standard

Several approaches instrument java byte code to make constraints checked,
 such as Handshake (
\begin_inset LatexCommand \cite{Handshake}

\end_inset 

) and jContractor (
\begin_inset LatexCommand \cite{jContractor}

\end_inset 

).
 Section 
\begin_inset LatexCommand \ref{sec: compareByteCodeInstr}

\end_inset 

 discusses, whether the approach of source code instrumentation presented
 in this paper is adaptable to byte code instrumentation.
 Handshake uses separate text files with a non-standard syntax to express
 class invariants and pre/postconditions.
 jContractor implements constraints with dedicated java methods.
 Neither Handshake nor jContractor binaries are publicly available.
\layout Standard

iContract (
\begin_inset LatexCommand \cite{iContract}

\end_inset 

) is a preprocessor for java.
 It instruments java source code to check constraints.
 It supports a subset of OCL.
 Constraints are embedded into javadoc comments.
 iContracts source code instrumentation is analyzed in detail in section
 
\begin_inset LatexCommand \ref{sec: compareIContract}

\end_inset 

.
 Binaries are available at no cost.
\layout Standard

For some applications OCL is just too powerful.
 A simpler approach is demonstrated in 
\begin_inset LatexCommand \cite{kbeans}

\end_inset 

.
 It implements a number of predefined constraint types, such as 
\emph on 
numeric range
\emph toggle 
 or 
\emph on 
ordering of arrays
\emph toggle 
.
 For instance to have an attribute 
\family typewriter 
age
\family default 
 constrained to positive values, one just adds a method 
\family typewriter 
getAge\SpecialChar \-
Min\SpecialChar \-
Value() {return
\protected_separator 
0;}
\family default 
.
 Most OCL constraints used in the development of the OCL toolkit also could
 have been expressed with such simple means.
 Constrained classes must be valid JavaBeans.
 Also, the class must announce the modification of attributes manually to
 have the constraints reevaluated.
 KBeans is released under GPL.
 Additionally there is a GUI for simulating an object population and checking
 constraints against it.
\layout Standard

Jass (
\begin_inset LatexCommand \cite{jassWeb}

\end_inset 

) is a preprocessor for java assertions developed at the University of Oldenburg
 (
\begin_inset LatexCommand \cite{jassDiplom}

\end_inset 

).
 Apart from class invariants and method pre- and postconditions it provides
 check statements (like assert() in C++) and loop invariants and variants.
 Assertions are expressed in java, extended by universal and existential
 quantifiers.
 Section 
\begin_inset LatexCommand \ref{sec: compareJass}

\end_inset 

 analyses the code instrumentation of Jass in detail.
 Jass is available under GPL.
\layout Standard

The following table summarizes the tools introduced above.
 The last line shows the tool developed with this paper.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
13 4 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
0 0 0 0
0 1 0 0
8 1 1 "" ""
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""


\newline 
Constraint Source
\newline 
Verification Method
\newline 
Availability
\newline 
JMSAssert
\newline 
OCL in javadoc
\newline 
links JVM 
\newline 
binary
\newline 

\newline 

\newline 
(platform dependent)
\newline 

\newline 
Handshake
\newline 
proprietary language
\newline 
byte code instr.
 / 
\newline 
not
\newline 

\newline 

\newline 
 proxy system library
\newline 
available
\newline 
jContractor
\newline 
 java methods
\newline 
 byte code instr.
 /
\newline 
not
\newline 

\newline 

\newline 
class loader
\newline 
available
\newline 
iContract
\newline 
OCL in javadoc
\newline 
source code instr.
\newline 
binary
\newline 
KBeans
\newline 
predefined constraint
\newline 
in special environment
\newline 
GPL
\newline 

\newline 
types / java methods
\newline 

\newline 

\newline 
Jass
\newline 
java fragments in javadoc
\newline 
source code instr.
\newline 
GPL
\newline 
Dresden 
\newline 
OCL in javadoc
\newline 
source code instr.
\newline 
LGPL
\newline 
Toolkit
\newline 

\newline 
(reversible)
\newline 

\layout Section

Reverse Engineering
\begin_inset LatexCommand \label{Sec:relatedReverse}

\end_inset 


\layout Standard

This section lists work related to reverse engineering needed in chapter
 
\begin_inset LatexCommand \ref{Sec:chapterModelInformation}

\end_inset 

.
\layout Standard

A powerful approach to reverse engineering has been developed at the MIT
 
\begin_inset LatexCommand \cite{womble}

\end_inset 

.
 The tool Superwomble extracts an object model from java byte code.
 Object models are roughly a subset of UML class diagrams, featuring inheritance
 and object associations.
 An important challenge for the analysis is the detection of element types
 of container attributes.
 The tool performs this very efficiently, without requiring any additional
 help from the user.
 Thus, it complements the two approaches presented in this paper.
 A detailed comparison is provided in section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineering}

\end_inset 

.
\layout Standard

JVision 
\begin_inset LatexCommand \cite{jvision}

\end_inset 

 produces class diagrams from java source or byte code.
 It's easy to use and has nice auto-layout.
 But it does not handle associations in any way.
 Collection attributes are simply shown as attributes.
 Instead it analyses, which classes instantiate/use each other.
 This is not nearly as useful as associations.
\layout Section

Other Related Work
\layout Standard

Cybernetic Intelligence develops an OCL compiler (
\begin_inset LatexCommand \cite{Cybernetic}

\end_inset 

).
 The current prototype claims to support syntax checking only.
 Type checking is under development.
 Frontends are available for Select Enterprise and Rational Rose.
\layout Standard

Elixir (
\begin_inset LatexCommand \cite{elixir}

\end_inset 

) claims OCL support in it's CASE tool and its java IDE.
 The CASE tool provides an OCL text field only, without any syntax checking.
 For the IDE a plugin is provided to integrate iContract.
\layout Standard

Several approaches implement OCL upon object repositories, such as USE 
\begin_inset LatexCommand \cite{USE}

\end_inset 

 and ModelRun 
\begin_inset LatexCommand \cite{Bold}

\end_inset 

.
 The object repositories can be populated and animated visually, with OCL
 constraints continuesly being checked.
\layout Standard

There is a universal code instrumentation toolkit (
\begin_inset LatexCommand \cite{CodeInstrumentation}

\end_inset 

) available for java.
 It parses java files into parse trees, preserving white space and comments.
 The parse tree can be modified and written back into the file.
 There are various applications for this, including tracing/profiling of
 program execution.
 The code instrumentation developed in this paper could probably be realized
 using this toolkit.
 However, the parser analyses the complete java file, thus is much more
 heavy-weight than the parser developed with this paper.
 There is a test version available at no cost, limited in the size of source
 programs it can handle.
\layout Chapter

Code Instrumentation
\begin_inset LatexCommand \label{Sec:chapterCodeInjection}

\end_inset 


\layout Standard

Insertion of generated code into java programs is the main subject of this
 paper.
 Such an automatic source code transformation is commonly referred to as
 code instrumentation.
 In this paper it covers anything beyond code generation, to get a java
 program checking its own constraints.
 For an idea, where code generation ends and instrumentation starts, see
 section 
\begin_inset LatexCommand \ref{Sec:codegeneration_result}

\end_inset 

.
 
\layout Standard

This is followed by an analysis of requirements for the code instrumentation
 and resulting design decisions in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements}

\end_inset 

.
 Section 
\begin_inset LatexCommand \ref{Sec:wrappingMethods}

\end_inset 

 describes the solution in detail.
 
\layout Standard

Finally sections 
\begin_inset LatexCommand \ref{Sec:temporalScope}

\end_inset 

 and 
\begin_inset LatexCommand \ref{Sec:structuralScope}

\end_inset 

 discuss the more fundamental issue, when and how often invariants have
 to be checked.
\layout Section

Results of Code Generation
\begin_inset LatexCommand \label{Sec:codegeneration_result}

\end_inset 


\layout Standard

The java code generator developed in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 produces a set of code fragments
\begin_float footnote 
\layout Standard

see documentation of class 
\family typewriter 
tudresden.ocl.codegen.CodeFragment.
\end_float 
.
 These code fragments have the following properties:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "70mm" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Property 
\newline 

\newline 
Constrained
\protected_separator 
type 
\newline 
The class this constraint applies to.
\newline 
Kind 
\newline 
Specifies, whether this fragment is an invariant, a pre- or a postcondition
 or a transfer or preparation fragment for a postcondition.
 
\newline 
Constrained
\protected_separator 
operation 
\newline 
The operation, this constraint applies to (not valid for invariants).
\newline 
Code 
\newline 
Contains the actual java code to be executed.
\newline 
Result
\protected_separator 
variable 
\newline 
Specifies the name of the boolean variable, which contains the result of
 the OCL expression after code execution.
\layout Standard

For each postcondition containing a @pre expression there are two additional
 code fragments called preparation and transfer.
 See below.
\layout Subsection

Preparation and Transfer Fragments
\layout Standard

The meaning of preparation and transfer fragments is explained on a dramatically
 simplified example.
 
\layout Standard

Suppose a post condition for operation 
\family typewriter 
employ()
\family default 
, that leaves the attribute 
\family typewriter 
age
\family default 
 unchanged:
\layout LyX-Code

context Person::employ() 
\newline 
post: age=age@pre
\layout Standard

The following code fragments will be produced:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 1 0 0
0 0 0 0
0 1 0 0
2 0 0 "" ""
2 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Kind
\newline 
 Code
\newline 
Transfer
\newline 

\family typewriter 
int node1;
\family default 
 
\newline 
Preparation
\newline 

\family typewriter 
node1=this.age;
\family default 

\newline 
Post Condition
\newline 

\family typewriter 
int node2=this.age;
\family default 

\newline 

\newline 

\family typewriter 
boolean result=(node1==node2);
\layout Standard

Typically these fragments would be inserted as follows:
\layout LyX-Code

class Person
\newline 
{
\newline 

\protected_separator 
 void employ()
\newline 

\protected_separator 

\protected_separator 
{
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
int node1;
\family default 
 
\protected_separator 
 
\protected_separator 
 
\protected_separator 
 // transfer fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
node1=this.age;
\family default 
 
\protected_separator 
// preparation fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// original code of employ()
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// post condition fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
node
\family default 
2
\family typewriter 
=this.age;
\family default 

\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
boolean result=(node1==node2)
\family default 
;
\newline 

\protected_separator 

\protected_separator 
}
\newline 
}
\layout Standard

Note, that precise semantics of code fragments involving the @pre expression
 has been changed, so that the original meaning described in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 7.1.2 is no longer fully correct.
 For a detailed comparison see section 
\begin_inset LatexCommand \ref{Sec:maintainJavaCodeGenerator}

\end_inset 

.
\layout LyX-Code


\protected_separator 

\layout Section

Requirements and Design Decisions
\begin_inset LatexCommand \label{Sec:injection_requirements}

\end_inset 


\layout Standard

This section analyzes the requirements for the code instrumentation and
 derives some fundamental design decisions.
\layout Subsection

Reversable Modification
\begin_inset LatexCommand \label{Sec:injection_requirements_reversable}

\end_inset 


\layout Standard

The most important feature is the reversability of code instrumentation.
 It must be possible to
\layout Itemize

clean the code tracelessly from all inserted fragments.
\layout Itemize

redo the instrumentation on source code that has already been modified,
 for instance when constraints have been changed.
 
\layout Itemize

edit the modified source code without losing all changes at the next instrumenta
tion.
 
\layout Standard

These requirements makes things quite a bit more difficult, but there are
 serious reasons for this.
 Otherwise there would be two versions of source code: the original and
 the modified version.
 This raises some unpleasant problems:
\layout Enumerate

Configuration management must handle two source code trees.
\layout Enumerate

Developers must be careful to edit the original version only.
\layout Enumerate

Running the instrumentation is required after every change of the java source
 code, not only when the constraints have been changed.
 
\layout Enumerate

Stack traces of runtime exceptions point to the modified source code.
 Developers must look for the corresponding place in the original version.
\layout Standard

The implementation of reversable modification requires a strategy of minimally
 invasive modification.
 This is realized by two design decisions:
\layout Enumerate

Method wrappers, explained detailed in section 
\begin_inset LatexCommand \ref{Sec:wrappingMethods}

\end_inset 

.
\layout Enumerate

Explicit package qualifiers for the OCL library in the generated code.
 Otherwise, an import statement for the OCL library would be necessary.
 This would be just another spot, were the original source code had to be
 touched.
 Additionally, this may introduce name conflicts between OCL library and
 user code.
\layout Subsection

Embedding Constraints in Java Source Code.
\begin_inset LatexCommand \label{Sec:embedConstraints}

\end_inset 


\layout Standard

It should be possible to embed constraints in the javadoc comments.
 The placement of embedded constraints implicates (and replaces) the context
 of the constraint.
 See the example below.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@invariant ageGreaterZero: age>0
\newline 
*/
\newline 
class Person
\newline 
{
\newline 

\protected_separator 

\protected_separator 
int age;
\newline 

\protected_separator 

\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@postcondition: age=age@pre
\newline 

\protected_separator 

\protected_separator 
*/
\newline 
 
\protected_separator 
void employ();
\newline 
}
\layout Standard

Constraints should be immediately visible to the editor of a java file.
 Also, this generally promotes the single source approach.
 The author is strongly convinced, that constraints stored in an extra text
 file are too far away from attention.
\layout Standard

Invariants may also be placed on an attribute or method of their context
 class.
 This is for convenience, since most invariants are clearly related to one
 specific attribute or method.
\layout Subsection

Checking the Element Type.
\layout Standard

The instrumented code must check, that container attributes comply to the
 
\family typewriter 
@element-type
\family default 
 and 
\family typewriter 
@key-type
\family default 
 javadoc tags.
 For collections the 
\family typewriter 
@element-type
\family default 
 tag specifies the type of the objects allowed in the collection.
 For maps 
\family typewriter 
@element-type
\family default 
 specifies the type of values, while 
\family typewriter 
@key-type
\family default 
 defines the type of key objects.
 A detailed description is provided in section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

.
 
\layout Standard

Note, that this feature may be be used standalone, without OCL expressions
 at all.
 Then it provides a runtime check for typed collections.
\layout Section

Code Insertion
\begin_inset LatexCommand \label{Sec:wrappingMethods}

\end_inset 


\layout Standard

The main task of code instrumentation is to have some code executed immediately
 before and after all methods (and after all constructors too).
 This section describes, how this is done by the tool developed with this
 paper.
\layout Standard

At first, section 
\begin_inset LatexCommand \ref{sec: SimpleApproach}

\end_inset 

 intoduces a simple approach, and why this would not work.
 Sections 
\begin_inset LatexCommand \ref{Sec:wrappingMethodsSub}

\end_inset 

 and 
\begin_inset LatexCommand \ref{Sec:wrappingConstructors}

\end_inset 

 explain the approach followed in this work.
 A somewhat tricky caveat and how it is solved is worked out in 
\begin_inset LatexCommand \ref{Sec:WrapperLoop}

\end_inset 

.
 Section 
\begin_inset LatexCommand \ref{Sec:cleaningCode}

\end_inset 

 shows, how it is managed to undo all modifications of the instrumentation.
 The java parser used to do all this is outlined in 
\begin_inset LatexCommand \ref{sec: JavaParser}

\end_inset 

.
\layout Standard

Sections 
\begin_inset LatexCommand \ref{sec: compareJass}

\end_inset 

, 
\begin_inset LatexCommand \ref{sec: compareIContract}

\end_inset 

, 
\begin_inset LatexCommand \ref{sec: compareByteCodeInstr}

\end_inset 

 compare this solution to three other tools approaching a similar task quite
 differently.
 This is summarized in 
\begin_inset LatexCommand \ref{Sec:CodeInsertionSummary}

\end_inset 

.
\layout Subsection

A Simple Approach
\begin_inset LatexCommand \label{sec: SimpleApproach}

\end_inset 


\layout Standard

A straight-forward solution would insert the code directly into the method.
 Consider the following method.
\layout LyX-Code

int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 

\protected_separator 

\protected_separator 
return result;
\newline 
} 
\layout Standard

The generated code could be inserted like this:
\layout LyX-Code

int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/preconditions.
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/postconditions.
\newline 

\protected_separator 

\protected_separator 
return result;
\newline 
} 
\layout Standard

But this raises some severe problems:
\layout Enumerate

The code to be executed after the method (postcondition and invariants)
 has to be inserted before any return statement.
\layout Enumerate

The post condition code must have the return value available.
 Instead of the 
\family typewriter 
result
\family default 
 variable in the example above, there could be a complex expression.
 Such a return expression has to be computed in advance, if the post condition
 code refers to the return value or the return expression produces side
 effects.
\layout Enumerate

There may be name conflicts between the original and the generated code,
 since the generated code defines local variables.
\layout Enumerate

For methods with return type void it must be decided, whether the post condition
 code has to be inserted at the end of the method.
 This depends on whether the end of the method is a reachable point of code.
 For the decision it needs a complete control flow analysis of the method.
 Note, that if the post condition code is wrongly inserted at the end of
 the method, the java compiler will fail due to unreachable statements.
\layout Standard

An implementation would need a complete java parser.
 The following code instrumentation would have to modify the original code
 at many different places and in a complicated way.
 This runs contrary to the strategy of minimally invasive modification as
 decided in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements_reversable}

\end_inset 

.
 
\layout Standard

Additionally, item 4 requires much of the semantic analysis performed by
 a java compiler.
 This makes the simple approach very hard to implement.
 
\layout Standard

Jass (
\begin_inset LatexCommand \cite{jassWeb}

\end_inset 

) and iContract (
\begin_inset LatexCommand \cite{iContract}

\end_inset 

) use this simple approach and encounter all the problems mentioned above.
 For a detailed comparison see sections 
\begin_inset LatexCommand \ref{sec: compareJass}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec: compareIContract}

\end_inset 

.
\layout Standard

Method wrappers solve all these problems in a nifty but simple way.
 This is introduced in the following section.
\layout Subsection

Wrapping Methods
\begin_inset LatexCommand \label{Sec:wrappingMethodsSub}

\end_inset 


\layout Standard

Some code tells more than thousand words, so an example is used to explain.
 Consider the following method.
\layout LyX-Code

int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
} 
\layout Standard

This is transformed into two methods.
\layout LyX-Code

int someMethod_wrappedbyocl
\begin_float footnote 
\layout Standard

This is not yet the full truth, see section 
\begin_inset LatexCommand \ref{Sec:WrapperLoop}

\end_inset 

.
\end_float 
(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
}
\newline 

\protected_separator 

\newline 
int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/preconditions.
\newline 

\protected_separator 

\protected_separator 
int result=someMethod_wrappedbyocl(x);
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/postconditions.
\newline 

\protected_separator 

\protected_separator 
return result;
\newline 
}
\layout Standard

Now let's have a look back at the problems encountered for the simple approach.
 None of them exist anymore.
 
\layout Itemize

The code to be executed after the method has to be inserted once only.
\layout Itemize

When the post condition code is executed, the return expression is already
 evaluated and ready to use.
\layout Itemize

No name conflicts are possible, since user code and generated code are strictly
 separated into different methods.
\layout Itemize

No control flow analysis is needed.
\layout Standard

The user code is modified in a simple way: a suffix is appended to the method
 name.
 For an implementation a very fragmentary java parser is sufficient, which
 understands 
\begin_inset Quotes eld
\end_inset 

java signature level
\begin_inset Quotes erd
\end_inset 

 only.
 This signature level covers anything outside of method bodies and attribute
 initializers.
 This is a very small part of the java language and easily to be analyzed
 by a hand-crafted parser.
 See section 
\begin_inset LatexCommand \ref{sec: JavaParser}

\end_inset 

 how easy it is.
\layout Standard

This kind of method wrapping still has a problem, which has been called
 the 
\begin_inset Quotes eld
\end_inset 

wrapper loop
\begin_inset Quotes erd
\end_inset 

 in this paper.
 Section 
\begin_inset LatexCommand \ref{Sec:WrapperLoop}

\end_inset 

 shows how this is solved.
\layout Subsection

Wrapping Constructors
\begin_inset LatexCommand \label{Sec:wrappingConstructors}

\end_inset 


\layout Standard

Another transformation is used for constructors, since they cannot be renamed.
 Suppose a example constructor
\layout LyX-Code

SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\layout Standard

Instead of renaming, the original constructor gets an additional dummy argument.
\layout LyX-Code

SomeClass(String x, Dummy
\begin_float footnote 
\layout Standard

Actually this is class 
\family typewriter 
tudresden.ocl.injection.lib.WrapperDummy
\family default 
.
\end_float 
 oclwrapperdummy)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\newline 

\protected_separator 

\newline 
SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
this(x, (Dummy)null);
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants.
\newline 
}
\layout Standard

A special case occurs if a class doesn't provide any constructors.
 Then the java compiler generates a default constructor as specified in
 
\begin_inset LatexCommand \cite{JAVA}

\end_inset 

 section 8.6.7.
 This default constructor cannot be wrapped.
 Instead it is replaced by an explicit constructor with the same access
 modifier as the generated default constructor would get.
\layout Subsection

Avoiding the Wrapper Loop
\begin_inset LatexCommand \label{Sec:WrapperLoop}

\end_inset 


\layout Standard

Wrapping methods as described in section 
\begin_inset LatexCommand \ref{Sec:wrappingMethodsSub}

\end_inset 

 causes a problem for a special situation.
 This sections describes this situation and provides a solution.
\layout Standard

The critical situation is shown in the figure below:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 121 141
file WrapperLoop1.eps
height 1 5
flags 13

\end_inset 


\layout Standard

The dotted arrow represents a method call: 
\family typewriter 
Sub.method()
\family default 
 contains a statement 
\family typewriter 
super.method();
\family default 
 somewhere.
\layout Standard

The code instrumentation changes the structure as shown below:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 210 141
file WrapperLoop2.eps
height 1 5
flags 13

\end_inset 


\layout Standard

The arrows show the problem: there's an infinite loop of method calls.
 In detail the following happens:
\layout Enumerate

Method 
\family typewriter 
Sub.method()
\family default 
 is called somewhere in the user program.
 This is a wrapper method replacing the original method, which is named
 
\family typewriter 
method_\SpecialChar \-
wrappedbyocl()
\family default 
 now.
\layout Enumerate


\family typewriter 
Sub.method()
\family default 
 does some OCL specific things, before it executes the statement 
\family typewriter 
method_\SpecialChar \-
wrappedbyocl()
\family default 
.
 This calls the original method 
\family typewriter 
Sub.\SpecialChar \-
method_\SpecialChar \-
wrappedbyocl()
\family default 
 as it is supposed to be.
\layout Enumerate


\family typewriter 
Sub.method_\SpecialChar \-
wrappedbyocl()
\family default 
 contains the 
\family typewriter 
super.\SpecialChar \-
method();
\family default 
 statement, therefore calls 
\family typewriter 
Super.\SpecialChar \-
method()
\family default 
.
\layout Enumerate


\family typewriter 
Super.method()
\family default 
 is a wrapper method replacing the original method, which is called 
\family typewriter 
Super.\SpecialChar \-
method_\SpecialChar \-
wrappedbyocl()
\family default 
 now.
 It does some OCL specific thing, before it executes the statement 
\family typewriter 
method_\SpecialChar \-
wrappedbyocl()
\family default 
.
 But this statement does not call 
\family typewriter 
Super.\SpecialChar \-
method_\SpecialChar \-
wrappedbyocl()
\family default 
 as it is supposed to be, but 
\family typewriter 
Sub.method_\SpecialChar \-
wrapped\SpecialChar \-
byocl()
\family default 
, which finally causes the infinite loop.
\layout Standard

The principal solution approach is simple: method 
\family typewriter 
Super.\SpecialChar \-
method()
\family default 
 should force 
\family typewriter 
Super.\SpecialChar \-
method_\SpecialChar \-
wrapped\SpecialChar \-
byocl()
\family default 
 to be executed, although this method was overridden in class 
\family typewriter 
Sub
\family default 
.
 Java language does not provide a way, to call a method, which was overridden.
 Therefore we do a small trick:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 229 141
file WrapperLoop3.eps
height 1 5
flags 13

\end_inset 


\layout Standard

Wrapped methods get the class name appended.
 Thus, a wrapper method can call the wrapped method of its own class.
\layout Subsection

Cleaning the Code
\begin_inset LatexCommand \label{Sec:cleaningCode}

\end_inset 


\layout Standard

Reversable modification means, that the instrumented code can be cleaned
 from any modifications without leaving any traces.
 This section explains, how this requirement is met.
 
\layout Standard

The user code is modified in two different ways only:
\layout Enumerate

Renaming the wrapped methods/constructors.
\layout Enumerate

Adding new object features, e.g.
 wrapper methods, methods for checking invariants and observing attributes.
\layout Standard

For each method to be wrapped the suffix 
\family typewriter 
_wrappedbyocl
\family default 
 is appended to the name.
 This transformation is done on the unparsed method header, so all typographical
 extras (line breaks, comments etc.) are preserved.
 This transformation is easily reversed, when the code has to be cleaned.
 For constructors, this works similarly with appending the dummy parameter
 to the parameter list.
\layout Standard

Removing generated class features relies on the fact, that all generated
 features get a special tag as shown below.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@author ocl_injector
\newline 
*/
\newline 
void checkOclInvariants();
\layout Standard

When cleaning the code, all object features carrying such an 
\family typewriter 
@author
\family default 
 tag are removed.
 This is quite simple and functional.
\layout Subsection

Design of the Java Parser
\begin_inset LatexCommand \label{sec: JavaParser}

\end_inset 


\layout Standard

Previous sections stated, that a very simple parser is sufficient for implementi
ng wrapper methods.
 This is proven in this section by giving an overview of the parser's design.
 In fact, it is as simple as a parser used for syntax highlighting and class
 browsers in a java IDE.
\layout Standard

First, the parser is actually a manipulator.
 The java file is simultaneously read, parsed, modified on-the-fly and written
 to an output file.
 For a class diagram of the parse tree produced see figure 
\begin_inset LatexCommand \ref{fig: JavaParser}

\end_inset 

.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 283 206
file JavaParser.eps
width 1 10
flags 15

\end_inset 


\layout Caption

Design of the Java Parser used by the OCL Instrumentation
\begin_inset LatexCommand \label{fig: JavaParser}

\end_inset 


\end_float 
\layout Standard

The parser analyses things which are relevant for the parse tree only.
 Particularly method bodies and attribute initializers are ignored.
 These skipped parts may not even compile.
 As long as the parenthesis balance is held, the java parser will process
 them correctly.
\layout Subsection

Comparison to Jass
\begin_inset LatexCommand \label{sec: compareJass}

\end_inset 


\layout Standard

Jass (
\begin_inset LatexCommand \cite{jassWeb}

\end_inset 

) is a precompiler for checking assertions in java programs.
 It translates jass files into java.
 Jass files are valid java source code with assertions specified in comments.
 The generated java file contains additional code checking these assertions.
 Thus, Jass performs something similar to the code instrumentation presented
 in the sections above.
 
\layout Standard

However, Jass directly inserts generated code into user code as described
 in section 
\begin_inset LatexCommand \ref{sec: SimpleApproach}

\end_inset 

.
 Thus the problems found there should occur in Jass too:
\layout Enumerate


\emph on 
The code to be executed after the method has to be inserted before any return
 statement.
\newline 

\emph toggle 
This is done by Jass.
 Thus, it requires a full java parser (JavaCC here).
\layout Enumerate


\emph on 
The return expression has to be computed in advance.
\emph toggle 

\newline 
This is also done by Jass.
\layout Enumerate


\emph on 
There may be name conflicts between the original and the generated code.
\emph toggle 

\newline 
Jass just defines a number of names (e.g.
 
\family typewriter 
jassResult
\family default 
), which cannot be used in the user code.
\layout Enumerate


\emph on 
For methods with return type void it must be decided, whether the end of
 the method is a reachable point of code.
\emph toggle 

\newline 
This is a known problem of Jass.
 It will simply fail in such cases.
 There is a work around: enclose the method body into a 
\family typewriter 
if(true){...}
\family default 
 statement.
\layout Standard

Jass performs a complex modification of the java source code.
 This modification cannot be reversed as described in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements_reversable}

\end_inset 

.
 Thus, Jass must be run before compilation whenever the source code has
 changed.
 Additionally, the source code repository must hold jass files instead of
 java, which causes administration effort for existing projects.
\layout Standard

Jass cannot use wrapper methods, since this would not allow loop invariants
 and check statements to be implemented.
 But without these features as in OCL, method wrappers are much better than
 direct insertion of code.
\layout Subsection

Comparison to iContract
\begin_inset LatexCommand \label{sec: compareIContract}

\end_inset 


\layout Standard

iContract (
\begin_inset LatexCommand \cite{iContract}

\end_inset 

) is a precompiler for checking OCL constraints in java programs.
 It extracts constraints from javadoc comments and produces modified java
 source files checking these constraints.
 This is exactly the functionality, which the tool presented in this paper
 tries to provide.
\layout Standard

Just like Jass it uses direct insertion of generated code into user code.
 Once again the problems found in section 
\begin_inset LatexCommand \ref{sec: SimpleApproach}

\end_inset 

 are reviewed.
\layout Enumerate


\emph on 
The code to be executed after the method has to be inserted before any return
 statement.
\newline 

\emph toggle 
This has to be done by iContract.
 However it fails here for most cases.
 According to the list of known problems 
\emph on 

\begin_inset Quotes eld
\end_inset 

iContract generates wrong code or crashes, if there is more than one return
 statement in a method.
\begin_inset Quotes erd
\end_inset 


\emph toggle 
.
 This matches with the experience of the author.
\layout Enumerate


\emph on 
The return expression has to be computed in advance.
\emph toggle 

\newline 
This is also done by iContract.
\layout Enumerate


\emph on 
There may be name conflicts between the original and the generated code.
\emph toggle 

\newline 
Also iContract forbids a number of names (e.g.
 
\family typewriter 
__return_value_holder_
\family default 
), to be used in the user code, although this isn't documented.
\layout Enumerate


\emph on 
For methods with return type void it must be decided, whether the end of
 the method is a reachable point of code.
\emph toggle 

\newline 
iContract doesn't do the control flow analysis needed to decide this question.
 This has been proven on example in appendix 
\begin_inset LatexCommand \ref{sec: unreachableIConstract}

\end_inset 

.
\layout Standard

Experience with iContract shows, that correctly modifying java source code
 isn't trivial at all.
 The current list of known problems suggests, that iContract isn't usable
 for a real-world task.
 Additionally, the problem of reachable ends of method bodies remains.
\layout Subsection

Comparison to Byte Code Instrumentation
\begin_inset LatexCommand \label{sec: compareByteCodeInstr}

\end_inset 


\layout Standard

This paper is focused on source code instrumentation.
 Another approach is to modify java byte code.
 This section discusses, whether it's possible and useful, to apply the
 concept of method wrappers to byte code instrumentation.
\layout Standard

For the third time the problems found in section 
\begin_inset LatexCommand \ref{sec: SimpleApproach}

\end_inset 

 are reviewed.
\layout Enumerate


\emph on 
The code to be executed after the method has to be inserted before any return
 statement.
\newline 

\emph toggle 
This is also needed for byte code instrumentation, but it's much easier.
 The code just has to be scanned for return opcodes.
 
\layout Enumerate


\emph on 
The return expression has to be computed in advance.
\emph toggle 

\newline 
This is not needed.
 Whenever a return opcode is executed, the return value is ready-to-use
 on the top of the execution stack.
\layout Enumerate


\emph on 
There may be name conflicts between the original and the generated code.
\emph toggle 

\newline 
This cannot happen.
 Name conflicts with local variables are not possible, since variable names
 do not exist anymore in byte code.
 Name conflicts with non-local variables are not possible too, since they
 are handled by different opcodes.
\layout Enumerate


\emph on 
For methods with return type void it must be decided, whether the end of
 the method is a reachable point of code.
\emph toggle 

\newline 
This is also no problem.
 The java compiler takes care for it - just scan for return opcodes.
 If the end of the method body isn't a reachable point of code, then there
 is also no return opcode.
 On the other hand, if the end of a method 
\emph on 
is
\emph toggle 
 reachable, there will also be a return opcode, no matter whether there
 was a return statement in the source.
 This is shown on example in appendix 
\begin_inset LatexCommand \ref{sec: byteCodeReturn}

\end_inset 

, since the JVM Specification 
\begin_inset LatexCommand \cite{JVM}

\end_inset 

 wasn't that clear about it.
\layout Standard

Thus, it makes no sense, to apply the approach of method wrappers to byte
 code instrumentation.
 
\layout Standard

In contrary to the approach presented in this paper, byte code instrumentation
 has to be redone after every compilation of the source code.
 This may be done on the fly, when loading the classes into the JVM.
 For instance jContractor 
\begin_inset LatexCommand \cite{jContractor}

\end_inset 

 uses a class loader to instrument java code.
 This may cause problems, if the user code registers a class loader of it's
 own.
 This is solved by Handshake 
\begin_inset LatexCommand \cite{Handshake}

\end_inset 

, which uses a proxy system library to intercept the JVM when opening class
 files.
 Thus, Handshake buys total transparency to the JVM with platform dependency.
\layout Subsection

Summary
\begin_inset LatexCommand \label{Sec:CodeInsertionSummary}

\end_inset 


\layout Standard

Wrapping methods seems to be the best choice when instrumenting source code
 for checking constraints.
 Several problems encountered with the simple approach of direct insertion
 are solved.
 
\layout Standard

Method wrappers cannot be used, if implementation constraints (assertions,
 loop invariants) are to be checked.
 Since OCL does not support implementation constraints, this does not affect
 the scope of this paper.
\layout Standard

Method wrappers are not useful for instrumentation on byte code level.
 The biggest advantage of source instrumentation (if it is reversible) is,
 that it doesn't need to be redone on each recompilation.
\layout Section

Scope of Invariants
\begin_inset LatexCommand \label{Sec:temporalScope}

\end_inset 


\layout Standard

This section discusses the issue, when an constraint is required to be fulfilled.
 This is trivially for pre/post conditions, but for invariants it's not
 so easy.
\layout Standard


\begin_inset LatexCommand \cite{Warmer}

\end_inset 

 section 5.4.2 suggests to check invariants immediately after an object has
 changed
\begin_float footnote 
\layout Standard

This is partially corrected in the errata 
\begin_inset LatexCommand \cite{WarmerErrata}

\end_inset 

.
\end_float 
.
 This is not workable, even if runtime efficiency is ignored.
 Modifications on the model often produce intermediate states, which are
 not consistent according to the constraints.
 
\layout Standard

When using databases the answer is simple: invariants must be valid outside
 of transactions.
 Since the java system does not provide transactions there are several strategie
s offered for various user requirements.
\layout Standard

Invariants may be required to be fulfilled on:
\layout Itemize

All methods.
 This may be too strict, since private methods may intentionally leave an
 object in an inconsistent state.
 
\layout Itemize

Public methods (or any other access modifier).
 This may be not strict enough.
\layout Itemize

Tagged methods.
 A special tag in the javadoc comment declares, that a method promises to
 leave the system in a consistent state.
 This tag is then part of the interface contract.
 This is the best solution, but requires additional effort spent by the
 developer.
\layout Itemize

Explicit request.
 This is the way of choice, if the model is held in a database backend.
 Then the checking of invariants is simply done immediately before committing.
\layout Standard

These strategies may be used in conjunction.
 Except of 
\emph on 
All Methods
\emph toggle 
 together with 
\emph on 
Public Methods
\emph toggle 
 and/or 
\emph on 
Tagged Methods
\emph toggle 
 all other combinations make sense for special user requirements.
\layout Standard

There won't be a single solution for this problem.
 Many applications will require their own individual scope of invariants.
 The scope may even differ between several classes of invariants.
 
\layout Standard

The current implementation supports scopes needed during the ongoing diploma
 thesis only.
 Up to now, all invariants share the same scope.
 Also, tagged methods are not yet supported.
\layout Section

Caching Results of Invariants
\begin_inset LatexCommand \label{Sec:structuralScope}

\end_inset 


\layout Standard

The previous section discussed, when we have to make sure, that all invariants
 are fulfilled.
 But even then it's not absolutely necessary to evaluate all invariants.
 The implementation developed along with this paper checks only those invariants
, whose result may possibly have changed by recent changes of the model.
\layout Subsection

Design
\layout Standard

Caching is realized with an observer design.
 Each invariant determines all object attributes it depends on and registers
 to these attributes as observer.
 Figure 
\begin_inset LatexCommand \ref{Abb:observingInvariants}

\end_inset 

 shows the meta model of the principal design.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 246
file observingInvariants.eps
width 4 100
flags 15

\end_inset 


\layout Caption

Design for Observing Invariants
\begin_inset LatexCommand \label{Abb:observingInvariants}

\end_inset 


\end_float 
 
\layout Standard

The classes in the UML chart have the following meaning:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
10 3 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
2 1 0 "" ""
2 1 0 "" ""
2 1 1 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Class
\newline 

\newline 
Example
\newline 
Class
\newline 
An arbitrary class of 
\newline 

\family typewriter 
class Person
\family default 

\newline 

\newline 
the user model
\newline 

\newline 
Invariant
\newline 
An invariant in the 
\newline 

\family typewriter 
context Person 
\family default 

\newline 

\newline 
context of a class
\newline 

\family typewriter 
inv: age>=0
\family default 

\newline 
Object
\newline 
An instance of a class
\newline 
Person Joe
\newline 
Invariant-
\newline 
An invariant in the 
\newline 
Has Joe 
\newline 
Instance
\newline 
context of an object.
\newline 
a positive age?
\newline 
Feature
\newline 
A feature (attribute or 
\newline 
Joe's age
\newline 

\newline 
query method) of an object.
\newline 

\layout Standard

For now, lets think of features as attributes only.
 How to deal with query methods is explained below.
 
\layout Standard

The cycle of checking invariants contains two stages.
\layout Enumerate

Evaluating invariants.
 When evaluating an invariant instance, this invariant instance registers
 to all object attributes used during evaluation as observer.
 This means, the attribute promises to notify the invariant instance, when
 the attributes value changes.
\layout Enumerate

Running the model.
 When an attribute changed its value during execution of user code, it notifies
 all observing invariant instances.
 Then, the attribute unregisters all observers, so they must register again
 on the next evaluation stage.
 See section 
\begin_inset LatexCommand \ref{Sec:structuralScopeImplementation}

\end_inset 

 how changed attributes are detected.
\layout Standard

This design can be extended to query
\begin_float footnote 
\layout Standard

Operations used in ocl expressions must not have side effects.
\end_float 
 methods.
 If the query does not have parameters, it's exactly like attributes.
 Things get a bit more complex, if the queries are parameterized.
 See figure 
\begin_inset LatexCommand \ref{Abb:observingMethods}

\end_inset 

.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 196
file observingMethods.eps
width 4 100
flags 15

\end_inset 


\layout Caption

Design for Observing Methods
\begin_inset LatexCommand \label{Abb:observingMethods}

\end_inset 


\end_float 
\layout Standard

The point is, that not methods but method invocations are features observed
 by invariants.
 A method invocation is a method together with a parameter sequence suitable
 to invoke this method.
 
\layout Standard

Up to now, the implementation observes attributes only.
\layout Subsection

Implementation
\begin_inset LatexCommand \label{Sec:structuralScopeImplementation}

\end_inset 


\layout Standard

Not all of these classes exist explicitly in the implementation.
 
\emph on 
Class
\emph toggle 
 and 
\emph on 
Object
\emph toggle 
 are provided by the user model already.
 
\emph on 
Invariant
\emph toggle 
 exists only as an additional method 
\family typewriter 
check\SpecialChar \-
Ocl\SpecialChar \-
Invariant_\SpecialChar \-
<name>
\family default 
 of its context class.
 
\emph on 
InvariantInstance
\emph toggle 
 is an explicit class
\begin_float footnote 
\layout Standard

called a bit confusingly 
\family typewriter 
tudresden.ocl.injection.lib.Invariant
\family default 
.
\end_float 
 of the instrumentation runtime library.
 Finally 
\emph on 
Feature
\emph toggle 
 is provided by the user model, but cannot be referred to as a single java
 object.
 (
\family typewriter 
java.\SpecialChar \-
lang.\SpecialChar \-
reflect.\SpecialChar \-
Field
\family default 
 is a field of a class, not of an object.) Whenever a feature has to be referred
 to, it is represented by it's observer collection object, which is sufficient
 for the needs of this implementation.
\layout Standard

Changes of object features are detected with polling.
 For each feature a backup attribute is added to the class.
 
\layout LyX-Code

class Person
\newline 
{
\newline 

\protected_separator 

\protected_separator 
int age;
\newline 

\protected_separator 

\protected_separator 
int age_oclbackup=age;
\newline 
}
\layout Standard

Additionally there is a utility method added comparing each attribute to
 it's backup.
 If there is a difference, the observers of the attribute are notified.
 
\layout LyX-Code

private void checkForChangedFeatures()
\newline 
{
\newline 

\protected_separator 

\protected_separator 
if(age!=age_oclbackup)
\newline 

\protected_separator 

\protected_separator 
{
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
age_oclbackup=age;
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// notify observers of age
\newline 

\protected_separator 

\protected_separator 
}
\newline 

\protected_separator 

\protected_separator 
// ...
 further attributes
\newline 
}
\layout LyX-Code


\protected_separator 

\layout Standard

This method is called immediately before and after each method of the class.
 If the attribute contains an object reference, the comparison tests object
 identity, not object equality.
 This means, the 
\family typewriter 
!=
\family default 
 operator is used as for basic types and not the 
\family typewriter 
equals()
\family default 
 method.
 
\layout Standard

For collections the backup stores a hashcode of the collection to avoid
 the overhead of maintaining a complete backup collection.
 Since comparison to backups is done very often, hashcode computation is
 required to be lightweight.
 The following section discusses this in detail.
\layout Subsection

Detecting Collection Modification
\begin_inset LatexCommand \label{Sec:detectingCollectionChanges}

\end_inset 


\layout Standard

Detecting changes of attributes is essential for caching of invariants as
 described above.
 For atomic attributes this is trivial: 
\family typewriter 
age!=age_backup
\family default 
 does it all.
 For collection attributes it's not that easy.
 The backup of a collection shouldn't be a collection as well, since this
 would consume large amounts of memory.
 Also, comparison between two collection isn't that fast.
\layout Standard

Thus, the backup for collection attributes stores a single integer value
 only.
 This value is computed from the collection.
 When the collection changes, also the value is expected to change.
 Such a value is commonly referred to as hash value.
 
\layout Standard

However, these hash values are not required to be uniformly distributed.
 Also, the hash value is required to be constant for unmodified collections
 only, not generally for equal collections.
 This means: if an element is added to the collection and removed immediately
 afterwards, the collection is 
\emph on 
not
\emph toggle 
 required to have the same hash code as before.
 This relaxion of requirements will be used below.
 It has to be admitted, that the term 
\begin_inset Quotes eld
\end_inset 

hash code
\begin_inset Quotes erd
\end_inset 

 is used here mainly for historical reasons.
\layout Standard

A first try to implement the hash functions follows the implementation of
 
\family typewriter 
hashCode
\family default 
 methods in the Java Collection API.
 These methods cannot be used directly, since they call method 
\family typewriter 
hashCode
\family default 
 for each of their elements.
 This is not desired, since change detection covers object identity, not
 object value.
 To achieve the intended behavior, collection hash functions had to be rewritten
 with calls to 
\family typewriter 
System.identityHashCode
\family default 
.
 This has been implemented in class 
\family typewriter 
HashExact
\begin_float footnote 
\layout Standard

all the source code is in 
\family typewriter 
tudresden.injection.lib.Hash*.java
\family default 
.
\end_float 
.
\layout Standard

These hash functions are good at detecting changes.
 However, they are too slow.
 Each invocation involves an iteration over the whole collection.
 For object populations of a few hundert instances with many relations between
 them, this virtually causes the system to stop.
\layout Standard

A quick but incomplete fix is achieved with the hash functions in 
\family typewriter 
HashSize
\family default 
.
 They simply return the size of the collection.
 This is very quick of course.
 But it does not detect changes which don't affect the collections size.
\layout Standard

Finally, 
\family typewriter 
HashModCount
\family default 
 performs a hash function which is a) nearly as fast as 
\family typewriter 
HashSize
\family default 
, but b) performs change detection even better than 
\family typewriter 
HashExact
\family default 
.
 It uses the fact, that standard collections already provide a change detection
 mechanism for implementing fail-fast iterators.
 Each collection maintains a modification counter, which is incremented
 whenever the collection is modified.
 Iterators create a copy of this counter on creation, and check this copy
 on every access.
 Unfortunately, the counter isn't publicly available.
 Thus, 
\family typewriter 
HashModCount
\family default 
 has to access the private counter attribute via reflection.
 This is highly dependent on the internal details of collection classes.
 The implementation has been tested successfully on JDK 1.2.2.
 With other versions better do not expect it to work.
\layout Standard

There is a work-around for this.
 The collection backup could be an iterator instead of an integer.
 To detect a modification, just access the iterator and wait for a 
\family typewriter 
ConcurrentModificationException
\family default 
.
 This has not been implemented yet, since it imposes several problems.
 Method 
\family typewriter 
hasNext()
\family default 
 does not check for modifications.
 Thus, method 
\family typewriter 
next()
\family default 
 has to be invoked.
 But this may also fail due to 
\family typewriter 
NoSuchElementException
\family default 
 if there are no elements left.
 Thus, the iterator used for backup would have to be recreated, whenever
 there is no element left.
 Empty collections would require a special treatment.
\layout Standard

Using the fail-fast mechanism obviously does not work for arrays.
 However, a fall back to 
\family typewriter 
HashExact
\family default 
 or 
\family typewriter 
HashSize
\family default 
 is easily provided.
 This could even be decided dynamicely depending on the size of the arrays.
\layout Standard

The table below summarizes the different detection mechanisms:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
16 5 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
1 1 0 0
1 0 0 0
0 0 0 0
1 0 0 0
0 1 0 0
0 0 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""


\newline 
Exact
\newline 
Size
\newline 
ModCount
\newline 
Iterator
\newline 
Modification 
\newline 
nearly perfect
\newline 
insertion/
\newline 
perfect
\newline 
perfect
\newline 
Detection
\newline 

\newline 
deletion only
\newline 

\newline 

\newline 
Runtime 
\newline 
linear
\newline 
constant/
\newline 
constant/
\newline 
constant/
\newline 
Complexity
\newline 

\newline 
very low
\newline 
low
\newline 
intermediate
\newline 
Implemention
\newline 
yes
\newline 
yes
\newline 
yes
\newline 
-
\newline 
Works with
\newline 

\newline 

\newline 

\newline 

\newline 
Arrays
\newline 
yes
\newline 
yes
\newline 
fall back 
\newline 
fall back
\newline 

\newline 

\newline 

\newline 
to other
\newline 
to other
\newline 
Collections without 
\newline 
yes
\newline 
yes
\newline 
runtime
\newline 
silent
\newline 
Fail-Fast Iterators
\newline 

\newline 

\newline 
error
\newline 
failure
\newline 
 Non-JDK 
\newline 
yes
\newline 
yes
\newline 
runtime 
\newline 
yes
\newline 
Collections with 
\newline 

\newline 

\newline 
error
\newline 

\newline 
Fail-Fast Iterators
\newline 

\newline 

\newline 

\newline 

\newline 
JDK Standard 
\newline 
yes
\newline 
yes
\newline 
yes
\newline 
yes
\newline 
Collections 
\newline 

\newline 

\newline 

\newline 

\layout Standard

Finally there is the question, which to choose.
 Probably one should start with 
\emph on 
Exact
\emph toggle 
 (the default).
 If this works, everything is fine.
 If the application slows down more, than one is willing to accept, try
 
\emph on 
ModCount
\emph toggle 
 (invoked with option 
\family typewriter 
--modcount-hash
\family default 
).
 If this works, it's fine.
 Otherwise it will fail-fast throwing a 
\family typewriter 
RuntimeException
\family default 
.
 Then one may try 
\emph on 
Size
\emph toggle 
 (
\family typewriter 
--simple-hash
\family default 
).
 Hopefully it doesn't miss too many modifications.
 
\layout Standard

If this is not acceptable, one may implement the 
\emph on 
Iterator
\emph toggle 
 method.
 It is important, that all collections used in the application provide fail-fast
 iterators (JDK standard collections do).
 Otherwise modifications may be missed silently.
\layout Chapter

Model Information
\begin_inset LatexCommand \label{Sec:chapterModelInformation}

\end_inset 


\layout Standard

The OCL compiler needs model information for type checking.
 How this works is explained in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 5.3.3.
 
\layout Standard

One possible source of model information may be a UML model exported from
 a CASE tool.
 This is probably the most elegant way.
 But since most real-world projects don't have a (up to date) UML representation
 of their business model, this isn't feasible in practice.
\layout Standard

Another source is the java code itself, accessed through the reflection
 API
\begin_float footnote 
\layout Standard

see class 
\family typewriter 
tudresden.ocl.check.types.ReflectionFacade
\family default 
.
\end_float 
.
 This is very convenient, since no additional model is needed.
 However, java reflection lacks some model properties which are important
 for type checking.
\layout Enumerate

Element types of collections, particularly collections representing associations.
 From a C++ perspective, java lacks templates implementing parameterized
 container classes.
\layout Enumerate

Qualifier types of maps, representing qualified associations.
\layout Enumerate

The isQuery tag of operations.
 Note, that OCL expressions may use operations without side effects (queries)
 only.
\layout Standard

This chapter presents a solution to the first two items above.
 The information needed is put into the source code.
 Section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

 explains, how this information is stored, while section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineering}

\end_inset 

 presents several approaches, how this information is generated.
\layout Standard

The third item could be solved in a similar way, by putting an isQuery tag
 into the source code.
 However, this is not an urgent problem.
 Without an explicit solution the developer has to be careful to call java
 methods without side effects only in OCL expressions.
\layout Section

Representing Element Types
\begin_inset LatexCommand \label{Sec:element_type_tag}

\end_inset 


\layout Standard

Element types and qualifier types are specified using special tags in javadoc
 comments.
 See the example below.
 
\layout LyX-Code

class Company
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
All persons employed
\protected_separator 
by this company.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
 
\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Collection employees;
\newline 
}
\layout Standard

The 
\family typewriter 
@element-type
\family default 
 tag takes an parameter specifying a java class or interface.
 Thus, it's similar to 
\family typewriter 
@see
\family default 
 as defined in 
\begin_inset LatexCommand \cite{JAVA}

\end_inset 

 section 18.4.1.
 The 
\family typewriter 
@element-type
\family default 
 tag is valid for attributes only, and there must be at most one such tag
 per javadoc comment.
 The tag is not restricted to attributes of type 
\family typewriter 
java.util.Collection
\family default 
, since future implementations could use other collection API's as well.
\layout Standard

Analogously, the 
\family typewriter 
@key-type
\family default 
 tag is introduced for association qualifiers.
 
\layout LyX-Code

class Bank
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
Customers qualified by
\protected_separator 
their account number.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@key-type Integer
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Map customers;
\newline 
}
\layout Standard

Note, that the reflection model is restricted to qualified associations
 with one qualifier only.
 
\begin_inset LatexCommand \cite{UML}

\end_inset 

 allows multiple qualifiers, but there is no convenient representation for
 this in java.
 
\layout Standard

Furthermore, UML specifies a qualified association which has not been qualified
 in the OCL expression to be a set, i.e.
 there must be no duplicates.
 For the java example above, this means, that the following invariant must
 hold:
\layout LyX-Code

context Bank inv: 
\newline 

\protected_separator 

\protected_separator 
customers->size()=customers->asSet()->size()
\layout Standard

Since this is not enforced by 
\family typewriter 
java.util.Map
\family default 
 (only keys are guaranteed to be unique), the OCL library provides an appropriat
e runtime check.
\layout Paragraph

Implementation.
\layout Standard

A really comfortable implementation would let the java compiler do the parsing,
 and provide the information through an extended reflection API.
 This would be similar to the 
\family typewriter 
@deprecated
\family default 
 tag.
 However, this approach would require the java compiler, the JVM and the
 standard runtime library to be modified.
 Apart from the effort of making these modifications, most java developers
 probably have a profound aversion against using a dedicated java environment
 just for checking ocl constraints.
\layout Standard

The implementation developed with this paper extends
\begin_float footnote 
\layout Standard

Encapsulated in 
\family typewriter 
tudresden.ocl.check.types.ReflectionExtender
\family default 
.
\end_float 
 the reflection facade by scanning the source code for these comments on
 demand.
 This implies, that the java source code is necessary for type checking
 OCL constraints in addition to the class files.
\layout Standard

There is a crucial question left: Where do the tags come? Possible sources
 are:
\layout Itemize

A UML model.
 The code generator of a CASE tool could generate these tags.
 
\layout Itemize

Maintained by hand.
 It is good-practice of programming, to specify which kind of objects are
 supposed to be in a collection attribute.
 The tags just make this information available formally.
 
\layout Itemize

Reverse Engineering.
 This is discussed in detail in section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineering}

\end_inset 

 below.
\layout Standard

Collection attributes with type tags are verified on runtime by the instrumented
 code.
 Note, that this kind of type information is useful for reverse engineering
 a UML model from given java code.
\layout Section

Reverse Engineering
\begin_inset LatexCommand \label{Sec:ReverseEngineering}

\end_inset 


\layout Standard

Section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

 explained, how to store additional type information of a java model in
 javadoc tags.
 This section discusses, how to create this information.
\layout Standard

Actually, these type tags have to be created manually.
 None of the automated procedures is perfect, so these procedures are suitable
 for decision support only.
 This chapter tries to support the developer with an interactive tool for
 inserting 
\family typewriter 
@element-type
\family default 
 and 
\family typewriter 
@key-type
\family default 
 tags into the code.
 There are two main features of this tool:
\layout Enumerate

Graphical User Interface: Clear presentation of missing type tags and comfortabl
e editing facilities.
 
\layout Enumerate

Decision Support: Giving hints to the developer.
 These hints are either derived statically (section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineeringStatic}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec: ReverseEngineeringWomble}

\end_inset 

) or gathered dynamically on runtime (section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineeringDynamic}

\end_inset 

).
 There should be a special indication, if several hints suggest different
 types.
\layout Standard

A prototype
\begin_float footnote 
\layout Standard

run class 
\family typewriter 
tudresden.ocl.injection.reverseeng.RevengGUI
\family default 
.
\end_float 
 of this tool according to the ideas presented in this section has been
 developed by Steffen Zschaler.
 The prototype currently features the graphical user interface and the runtime
 analysis of section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineeringDynamic}

\end_inset 

.
\layout Subsection

Source Code Analysis
\begin_inset LatexCommand \label{Sec:ReverseEngineeringStatic}

\end_inset 


\layout Standard

Information about element types may be derived from static properties of
 the class, such as parameter types of methods and other tags in javadoc
 comments.
 
\layout Standard

The following example suggests some of these properties.
 The element type of 
\family typewriter 
employees
\family default 
 is obviously 
\family typewriter 
Person
\family default 
, but this information is not yet available to the OCL compiler.
 The tool could derive an appropriate hint for the developer from each of
 the underlined features.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
All employed {@link 
\bar under 
Person
\bar default 
 persons} of this company.
\newline 

\protected_separator 
 
\protected_separator 
@see 
\bar under 
Person
\bar default 

\newline 
*/
\newline 
Collection employees;
\newline 

\protected_separator 

\newline 
boolean isEmployee(
\bar under 
Person
\bar default 
);
\newline 
void addEmployee(
\bar under 
Person
\bar default 
);
\newline 
void removeEmployee(
\bar under 
Person
\bar default 
);
\layout Standard

Note, that the example above requires linguistic knowledge about plural
 and singular form of nouns (employee here).
 This gets far more difficult, if identifiers are not English.
\layout Subsection

Runtime Analysis
\begin_inset LatexCommand \label{Sec:ReverseEngineeringDynamic}

\end_inset 


\layout Standard

This section describes, how to trace element types of collections on runtime.
 This is useful, if there is no static type information available, as described
 in the previous section.
 
\layout Standard

For each collection attribute, the object types encountered during a run
 of the program are collected and fed into the interactive tool.
 This requires the program to be executable.
 Additionally there must be extensive test cases available, otherwise only
 a subset of all possible element types will be encountered.
\layout Standard

The interactive tool presents the set of object types for every collection
 attribute.
 Additionally, the tool highlights all types, for which there is no super
 type in this set.
 Formally, these are the local minima of the set respective to the generalizatio
n partial order.
 These local minima are good candidates for an element type, especially
 if there is only one minimum.
 Presenting minima simplifies the decision if there are many types encountered
 in the collection attribute.
\layout Paragraph

Implementation.
\layout Standard

The instrumented code makes a static method 
\family typewriter 
traceTypes
\begin_float footnote 
\layout Standard

actually 
\family typewriter 
tudresden.ocl.injection.lib.TypeTracer.traceTypes
\family default 
.
\end_float 
 to be executed whenever a collection attribute changes it's contents.
 Class 
\family typewriter 
TypeTracer
\family default 
 maintains a static data structure containing all element types and key
 types for all attributes, as well as the minima of these type sets.
 This information is continuesly written to a log file.
 The interactive tool can read this log file and display the information.
\layout Subsection

Byte Code Analysis 
\begin_inset LatexCommand \label{sec: ReverseEngineeringWomble}

\end_inset 


\layout Standard

This section describes how type information can be extracted from java byte
 code.
 This technology and it's implementation (called Superwomble) was developed
 by Daniel Jackson and Allison Waingold at the MIT.
 This section outlines the parts of their paper (
\begin_inset LatexCommand \cite{womble}

\end_inset 

) related to type information together with experiences from practical experimen
ts with the tool.
\layout Standard

Superwomble is a powerful reverse engineering solution.
 It generates object graphs from nothing but java byte code.
 Object graphs are roughly speaking a subset of UML class diagrams.
 They feature classes with generalizationships and associations between
 them.
 The graph is finally fed into a tool named dot, which does a nice layout
 for the graph.
\layout Standard

One of the tricky parts of this tool is the detection of element types for
 object containers, which is exactly what this whole chapter is about.
 How this works, is explained on the Company-Person example from section
 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

 (page 
\begin_inset LatexCommand \pageref{Sec:element_type_tag}

\end_inset 

).
 
\layout Standard

Suppose 
\family typewriter 
company
\family default 
 is a variable of type 
\family typewriter 
Company
\family default 
 and 
\family typewriter 
person
\family default 
 of type 
\family typewriter 
Person
\family default 
.
 A typical program around this example would probably contain a statement
 like this:
\layout LyX-Code

company.employees.add(person);
\layout Standard

The operation 
\family typewriter 
add
\family default 
 takes an argument of type 
\family typewriter 
Object
\family default 
, but is called with a variable of type 
\family typewriter 
Person
\family default 
.
 This is a good hint, that the element type of employees is 
\family typewriter 
Person
\family default 
.
\layout Standard

The same works for objects returned from the container.
 The expression
\layout LyX-Code

person=(Person)(company.employees.iterator().next());
\layout Standard

strongly suggests the element type 
\family typewriter 
Person
\family default 
.
\layout Standard

Another highlight of Superwomble is, that container classes are detected
 even if they don't implement 
\family typewriter 
java.util.Collection
\family default 
.
 In fact the type is not cared at all.
 Instead there are some heuristics applied to decide, whether a class is
 an object container or not.
\layout Standard

The tool was used on several parts of both the OCL toolkit and the net-linx
 code, and it produced good and reliable results.
\layout Standard

Integration of Superwomble results into the interactive tool should be possible.
 The object graph is exported to a human readable text file.
 However, this task is outside the scope of this paper.
\layout Subsection

Comparison
\layout Standard

This section provides a comparison between the three approaches presented
 in the sections above.
 
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
11 4 0 0 -1 -1 -1 -1
1 0 0 0
0 1 0 0
1 0 0 0
1 0 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
2 1 1 "" ""
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""


\newline 
Source Code
\newline 
Byte Code
\newline 
Runtime
\newline 

\newline 

\newline 
(Superwomble)
\newline 

\newline 
Source Code required
\newline 
yes
\newline 
no
\newline 
yes
\newline 
Required Code Quality
\newline 
fairly 
\newline 
fully 
\newline 
up and 
\newline 

\newline 
parseable
\newline 
compileable
\newline 
running
\newline 
Availability of Results
\newline 
intermediate
\newline 
good 
\newline 
good
\newline 
Reliability of Results
\newline 
good
\newline 
very good
\newline 
intermediate
\newline 
Application Effort
\newline 
low
\newline 
low
\newline 
high
\newline 
Implementation Effort 
\newline 
low
\newline 
high
\newline 
very low
\newline 
(starkly subjective)
\newline 

\newline 

\newline 

\newline 
Availability
\newline 
LGPL
\newline 
Binary at no cost
\newline 
LGPL
\layout Standard

Runtime analysis requires the source code to be instrumented before.
 Only byte code analysis requires no source code.
 This argument is weakened by the fact, that the type information is to
 be inserted into source code anyway.
 However, byte code analysis may cover libraries, which aren't available
 in source code, but provide useful type information about other parts of
 the program.
\layout Standard

Anyway, byte code analysis requires, that there is a fully compilable source
 code somewhere, even if it's not available to the user.
 Source code analysis even makes do with incorrect source code, as long
 as signature data is parsable (method headers etc.) and method bodies hold
 the bracket balance.
 Most demanding on source code quality is runtime analysis, which requires
 a running system, with complete test cases.
\layout Standard

Source code analysis is most demanding on the 
\begin_inset Quotes eld
\end_inset 

beauty
\begin_inset Quotes erd
\end_inset 

 of implementation.
 To deliver results, it requires some kind of getter/setter methods for
 the container attributes.
 In contrary, byte code and runtime analysis even work for public container
 attributes manipulated from outside of the class.
\layout Standard

For runtime analysis 
\emph on 
reliability of results 
\emph toggle 
depends heavily on completeness of test cases.
 If the test cases are insufficient, results may be wrong.
 Byte code analysis provides best reliability, it's more difficult for a
 poor quality code to fool the analysis.
\layout Standard

Runtime analysis also requires most 
\emph on 
application effort
\emph toggle 
 for the user.
 The system must be actually run.
 Particularilly all requirements for runtime (libraries, database, configuration
 etc.) must be available.
\layout Standard

The 
\emph on 
implementation effort
\emph toggle 
 is very subjective for this paper.
 Both source code and runtime analysis require parsing and instrumenting
 of java source code, which was already built for runtime verification of
 OCL constraints.
 Thus the implementation effort in this paper was low.
 Byte code analysis is something completely different.
\layout Standard

Finally, 
\emph on 
availability
\emph toggle 
 is about whether it is allowed to use, review and adapt the implementation.
 According to 
\begin_inset LatexCommand \cite{freesw}

\end_inset 

, the difference between 
\emph on 
LGPL
\emph toggle 
 and 
\emph on 
Binary at no cost
\emph toggle 
 is same as between free speech and free beer.
\layout Subsection

Summary
\layout Standard

There have been three approaches presented for acquiring type information.
 Runtime analysis is implemented and fully integrated into the project.
 Source code analysis is not yet implemented, but this should be easy to
 add.
 Experiences with byte code analysis where drawn from the tool Superwomble
 (
\begin_inset LatexCommand \cite{womble}

\end_inset 

).
 This is fully implemented but not integrated into the OCL toolkit, thus
 not ready to use.
\layout Standard

Adding up the scores, byte code analysis is probably the best.
 However, most of the criteria listed above are some kind of orthogonal,
 so adding up scores might not be sufficient for a decision.
 Each application may emphasize different criteria, so a universal solution
 is not available.
\layout Standard

All approaches have one thing in common: they are not perfect.
 Thus, they cannot be used directly in the type checker of the OCL compiler.
 The intermediate step of the 
\family typewriter 
@element-type
\family default 
 tags is necessary to allow correcting intervention of a human user.
\layout Chapter

OCL on an Industrial Example
\layout Chapter

Summary
\layout Chapter
\start_of_appendix 
Maintance of the OCL Toolkit
\layout Standard

This chapter describes all major changes to Frank Fingers OCL compiler.
 This includes bugfixes too, if they caused changes of internal or external
 interfaces.
 It it some kind of update for 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

, listing everything changed since.
\layout Section

Reflection Facade and OCL Library
\layout Standard

Many changes occurred both in the reflection model facade and in the OCL
 library.
 This section groups these changes.
\layout Subsection

Polymorphism of Operation Parameters
\layout Standard

Both 
\family typewriter 
Reflection\SpecialChar \-
Facade.\SpecialChar \-
navigate\SpecialChar \-
Parameterized
\family default 
 and 
\family typewriter 
OclAny\SpecialChar \-
Impl.\SpecialChar \-
get\SpecialChar \-
Feature
\family default 
 lacked polymorphism of operation parameters.
 This means, that a method is found only if actual parameter types match
 formal parameter types exactly.
 The correct behavior is, that actual parameter types may also be subtypes
 of formal parameter types.
 For a detailed description see 
\begin_inset LatexCommand \cite{rw7}

\end_inset 

 section 3.1.5.
 
\layout Standard

The new implementation made 
\family typewriter 
Reflection\SpecialChar \-
Adapter.\SpecialChar \-
get\SpecialChar \-
Class\SpecialChar \-
ForType
\family default 
 superfluous, so it was removed from the interface.
\layout Subsection

Mandatory Name Adapters
\layout Standard

Previous versions of the OCL library provided a default functionality, if
 no name adapter had been set explicitly.
\layout Standard

Now its mandatory to set a name adapter.
 Otherwise a NullPointerException is thrown.
 The default functionality has been moved into a separate name adapter (
\family typewriter 
Simple\SpecialChar \-
Name\SpecialChar \-
Adapter
\family default 
) which is used in the reflection facade as well.
 The name adapter may also be set by the java property 
\family typewriter 
tudresden.\SpecialChar \-
ocl.\SpecialChar \-
lib.\SpecialChar \-
name\SpecialChar \-
adapter
\family default 
.
\layout Subsection

Qualified Associations
\layout Standard

The OCL support was enhanced by adding a simplified form of qualified associatio
ns to the reflection facade and the OCL library.
 
\begin_inset Quotes eld
\end_inset 

Simplified
\begin_inset Quotes erd
\end_inset 

 means, that there may be only one qualifier attribute.
 
\layout Standard

Qualified associations are represented in java with 
\family typewriter 
java.\SpecialChar \-
util.Map
\family default 
 by default, but this may be changed by implementing 
\family typewriter 
Reflection\SpecialChar \-
Adapter.\SpecialChar \-
isMap(Class)
\family default 
.
\layout Subsection

Type Mapping from OCL to Java.
\layout Standard

The mapping between OCL types and java types now supports the collections
 API introduced in JDK version 1.2.
 The changes concern 
\family typewriter 
Default\SpecialChar \-
Ocl\SpecialChar \-
Factory.\SpecialChar \-
getOcl\SpecialChar \-
Representation\SpecialChar \-
For(Object)
\family default 
 and 
\family typewriter 
Default\SpecialChar \-
Reflection\SpecialChar \-
Adapter.\SpecialChar \-
get\SpecialChar \-
Class\SpecialChar \-
ForType
\family default 
.
 
\layout Standard

A special handling of 
\family typewriter 
java.\SpecialChar \-
util.\SpecialChar \-
Vector
\family default 
 supports code generated by Argo/
\family typewriter 
\SpecialChar \-

\family default 
UML.
 The static configuration variable 
\family typewriter 
Ocl.\SpecialChar \-
TAKE_\SpecialChar \-
VECTORS_\SpecialChar \-
AS_SET
\family default 
 causes vectors to be mapped to sets, instead of sequences.
\layout Standard

The new mapping is listed below.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 3 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
0 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Java (java.util)
\newline 
take vectors as set
\newline 
OCL
\newline 
List
\newline 
-
\newline 
Sequence
\newline 
Vector
\newline 
false
\newline 
Sequence
\newline 

\newline 
true
\newline 
Set
\newline 
Set
\newline 
-
\newline 
Set
\newline 
Map
\newline 
-
\newline 
Set (qualified)
\layout Standard

Furthermore, arrays are now supported.
 They are mapped into sequences of the appropriate element type.
\layout Section

OCL Library
\layout Standard

Some modifications occurred in the OCL library only.
\layout Subsection

Undefined Values
\layout Standard

Previous versions of the OCL library implemented undefined values as singletons
 for each type.
 
\layout Standard

This was given up.
 Now undefined values carry the reason for their creation with them.
 When the undefined value is tried to be evaluated, this reason is added
 to the exception message.
 
\layout Standard

This made 
\family typewriter 
Ocl.STRICT_\SpecialChar \-
CHECKING
\family default 
 superfluous, so it was removed.
 Wherever this property was used, the library now produces an undefined
 value, parameterized with the message of the exception formerly thrown.
\layout Standard

Undefined values were introduced at some other operations of OCL objects:
\layout Enumerate

Method 
\family typewriter 
OclCollection.\SpecialChar \-
set\SpecialChar \-
To\SpecialChar \-
Range
\family default 
 now creates an undefined collection (instead of throwing an exception),
 if lower bound is greater than upper bound.
\layout Enumerate

The methods 
\family typewriter 
Ocl.to<OclType>(OclRoot)
\family default 
 now return an undefined value of the appropriate type, if argument is undefined.
 
\layout Subsection

Handling of Null Values
\layout Standard

Previous versions handled a special null value for OCL strings.
 This null value behaved like an empty string for most cases (e.g.
 concatenation).
 However a null string and an empty string were not equal.
 This was removed.
 Now a null string does exactly behave like an empty string.
 
\layout Standard

Previous versions returned an undefined OCL collection, if the java collection
 field was null.
 Now, null collections are treated exactly like empty collections.
\layout Standard

This behavior is encapsulated into a new method 
\family typewriter 
getOcl\SpecialChar \-
Representation\SpecialChar \-
For\SpecialChar \-
Null(Class)
\family default 
 in 
\family typewriter 
OclFactory
\family default 
.
 This method is called in 
\family typewriter 
OclAny\SpecialChar \-
Impl.\SpecialChar \-
get\SpecialChar \-
Feature
\family default 
.
\layout Section

Type Checker
\layout Standard

Previous versions of the type checker missed support for classifier 
\family typewriter 
OclAny
\family default 
 in class 
\family typewriter 
Default\SpecialChar \-
Type\SpecialChar \-
Factory
\family default 
.
 
\layout Standard

Method 
\family typewriter 
getClassifier
\family default 
 in class 
\family typewriter 
Type\SpecialChar \-
Factory
\family default 
 has been removed and replaced by 
\family typewriter 
Type\SpecialChar \-
Factory.get
\family default 
.
\layout Section

Java Code Generator 
\begin_inset LatexCommand \label{Sec:maintainJavaCodeGenerator}

\end_inset 


\layout Subsection

Code Fragments for @pre
\layout Standard

Meaning of code fragments created for @pre expressions (TRANSFER, PREPARATION,
 CODE) has been changed.
 The new behavior is easier and more flexible for different code instrumentation
 tools.
 For a description of the new behavior see section 
\begin_inset LatexCommand \ref{Sec:codegeneration_result}

\end_inset 

.
 
\layout Standard

For the old behavior compare to 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 7.1.2.
 Below, there is a detailed comparison on the example used there.
\layout Standard

The ocl expression is
\layout LyX-Code

context Person::getIncomeAfterTax(tax:Real):Real post:
\newline 

\protected_separator 

\protected_separator 
age = age@pre
\layout Standard

The TRANSFER fragment generated is still the same:
\layout LyX-Code

OclInteger tudOclNode2;
\layout Standard

However, the PREPARATION fragment has changed.
 Below, there is the old version.
 The new version just lacks the parts set in italics.
\layout LyX-Code

final OclAnyImpl tudOclNode0=Ocl.toOclAnyImpl(Ocl.getFor(this));
\layout LyX-Code

final OclReal tudOclOpPar0=Ocl.toOclReal(Ocl.getFor(tax));
\layout LyX-Code

final OclReal tudOclResult0=OclReal.UNDEFINED;
\layout LyX-Code

final OclInteger tudOclNode1=Ocl.toOclInteger(
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
tudOclNode0.getFeature("age"));
\layout LyX-Code


\shape italic 
final OclInteger 
\shape default 
tudOclNode2=Ocl.toOclInteger(
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
tudOclNode0.getFeature("age"));
\layout LyX-Code

final OclBoolean tudOclNode3=tudOclNode1.isEqualTo(tudOclNode2);
\layout LyX-Code


\shape italic 
this.tudOclNode2=tudOclNode2;
\layout Standard

The POST fragment changed as well.
 Again, this is the old version, with the new version lacking the first
 line put in italics.
\layout LyX-Code


\shape italic 
final OclInteger tudOclNode2=this.tudOclNode2;
\layout LyX-Code

final OclAnyImpl tudOclNode0=Ocl.toOclAnyImpl(Ocl.getFor(this));
\layout LyX-Code

final OclReal tudOclOpPar0=Ocl.toOclReal(Ocl.getFor(tax));
\layout LyX-Code

final OclReal tudOclResult0=Ocl.toOclReal(Ocl.getFor(result));
\layout LyX-Code

final OclInteger tudOclNode1=Ocl.toOclInteger(
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
tudOclNode0.getFeature("age"));
\layout LyX-Code

final OclBoolean tudOclNode3=tudOclNode1.isEqualTo(tudOclNode2);
\layout Standard

The old code fragments were intended to be inserted into the user code as
 follows:
\layout LyX-Code

public class Person 
\layout LyX-Code

{
\layout LyX-Code


\protected_separator 

\protected_separator 
TRANSFER 
\layout LyX-Code


\protected_separator 

\layout LyX-Code


\protected_separator 
 public double getIncomeAfterTax(double tax) 
\layout LyX-Code


\protected_separator 

\protected_separator 
{
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 
 PREPARATION
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 
 USER CODE
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 
 POST
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 
 return result;
\layout LyX-Code


\protected_separator 
 }
\layout LyX-Code

}
\layout Standard

With the new fragments, this still works.
 However, it's also possible to insert the TRANSFER fragment into the method,
 thus making it a local variable:
\layout LyX-Code

public class Person 
\layout LyX-Code

{
\layout LyX-Code


\protected_separator 

\layout LyX-Code


\protected_separator 
 public double getIncomeAfterTax(double tax) 
\layout LyX-Code


\protected_separator 

\protected_separator 
{
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
TRANSFER 
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 
 PREPARATION
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 
 USER CODE
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 
 POST
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 
 return result;
\layout LyX-Code


\protected_separator 
 }
\layout LyX-Code

}
\layout Standard

The code instrumentation developed with this paper uses the second insertion
 scheme only.
\layout Subsection

Explicit Package Qualifiers.
\layout Standard

The java code generator now optionally prepends the explicit package qualifier
 
\family typewriter 
tudresden.ocl.lib.

\family default 
 to OCL library classes.
 This makes an import statement superfluous, and therefore fulfills the
 corresponding requirement in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements_reversable}

\end_inset 

.
\layout Chapter

Usage of the OCL Tool
\layout Standard

This chapter describes, how to use the instrumentation tool.
 Section 
\begin_inset LatexCommand \ref{Sec:UsageExample}

\end_inset 

 contains an example quickly demonstrating the main features.
 Section 
\begin_inset LatexCommand \ref{Sec:UsageReference}

\end_inset 

 provides a complete reference of the command line options.
\layout Section

Example
\begin_inset LatexCommand \label{Sec:UsageExample}

\end_inset 


\layout Paragraph

Step 1:
\layout Standard

First, get the following files: dresden-ocl-injector.jar, xerces.jar and royloy.jar.
 These files are available on our website at dresden-ocl.sourceforge.net or
 may be produced from the sources using the 
\family typewriter 
makeJar
\family default 
 script.
 Put these files into one directory and change into that directory.
\layout Standard

The file royloy.jar contains the example code.
 To unzip it type:
\layout LyX-Code

jar -xf royloy.jar
\layout Standard

You may now have a look at the example code, its in tudresden/ocl/test/royloy/.
 The java code already contains ocl expressions in javadoc comments, for
 an easy start see 
\family typewriter 
Person.java
\family default 
 and 
\family typewriter 
Company.java
\family default 
.
 Additional ocl is in the file 
\family typewriter 
oclexpressions
\family default 
.
\layout Paragraph

Step 2:
\layout Standard

Now it's time to start the ocl tool.
 Type the following command on a single line.
 Note, that the wildcards require a Unix shell to be expanded.
\layout LyX-Code

java -jar dresden-ocl-injector.jar 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
-r tudresden.ocl.test.royloy 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
--modify tudresden/ocl/test/royloy/*.java 
\layout Standard

The example java code has now been modified.
 The modified code will have the same behavior as the original code, but
 will additionally check the ocl constraints embedded in the javadoc comments.
\layout Paragraph

Step 3:
\layout Standard

To check this, compile the modified java code (again type everything on
 a single line):
\layout LyX-Code

javac 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
-classpath dresden-ocl-injector.jar 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
tudresden/ocl/test/royloy/*.java
\layout Standard

and 
\layout Paragraph

Step 4:
\layout Standard

Run the test main function provided:
\layout LyX-Code

java 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
-cp .:dresden-ocl-injector.jar 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
tudresden.ocl.test.TestInjectionRoyloy 
\layout Standard

Enjoy the messages about violated ocl constraints running down the screen.
 Messages contain information about the violated constraint and the object
 involved.
\layout Paragraph

Step 5:
\layout Standard

Clean the code from the modifications the ocl tool made.
\layout LyX-Code

java -jar dresden-ocl-injector.jar 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
--clean --modify tudresden/ocl/test/royloy/*.java 
\layout Standard

The example code is now exactly the same as you downloaded it.
\layout Standard

Note, that the code actually was cleaned.
 No backups involved.
 To check this, try the following:
\layout Enumerate

Make a backup of one or more java files just before running the OCL tool
 (step
\protected_separator 
2).
\layout Enumerate

After running the tool make some small modifications to the files, you made
 a backup for.
 For example just add a single System.out.println to a method body.
\layout Enumerate

Proceed until step
\protected_separator 
5.
\layout Enumerate

Compare the cleaned code to your backup.
 
\layout Standard

The difference will be just the small modifications you made.
\layout Section

Reference
\begin_inset LatexCommand \label{Sec:UsageReference}

\end_inset 


\layout Standard

Synopsis is below.
\layout LyX-Code

java tudresden.ocl.injection.Main [options] file.java ..
\layout Standard

Provide all java files to be modified.
 
\layout Standard

Options recognized are below.
 Most options have a short and a long version.
 Long versions try to be self explanatory and should be used in scripts.
\layout LyX-Code

-m --modify
\layout Quotation

Enables modifying java files.
 If not provided, the modified java code is written to 
\family typewriter 
file.java.injected
\family default 
.
 This switch serves as a safety check, whether you 
\emph on 
really
\emph toggle 
 want to replace your source code with the output of the ocl tool.
\layout LyX-Code

-c --clean
\layout Quotation

Performs cleaning of source files instead of instrumentation.
 After cleaning, the source code should show no differences to the version
 before running the ocl tool.
\layout LyX-Code

-f --constraint-file constraints.txt
\layout Quotation

Specifies the text file containing the constraints.
 Usually not needed, since constraints may and should be placed into javadoc
 comments.
 See section 
\begin_inset LatexCommand \ref{Sec:embedConstraints}

\end_inset 

.
\layout LyX-Code

-x --xmi-model model.xmi
\layout Quotation

Specifies the XMI file containing the model covered.
 Is used for type checking only.
 Use this only, if you cannot use 
\family typewriter 
--reflection-model
\family default 
.
\layout LyX-Code

-r
\protected_separator 
--reflection-model modelpackage
\layout Quotation

Specifies the java packages containing the model covered.
 If there is a constraint 
\family typewriter 
context Person
\family default 
, the type checker will look for class Person in all package given by this
 option.
 This is some kind of 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
import
\family default 
 for OCL
\begin_inset Quotes erd
\end_inset 

.
 For multiple packages use multiple options.
\layout LyX-Code

-n --name-adapter [none|argo]
\layout Quotation

Specifies the name adapter.
 Default is 
\family typewriter 
none
\family default 
.
 If you don't use code generated by Argo/UML, the default is sufficient.
 Further information on name adapters is available at 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 3.5.1 and 3.5.6.
\layout LyX-Code

-is --invariant-scope 
\layout LyX-Code


\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
[all|private|protected|package|public|explicit]
\layout Quotation

Specifies the the scope of invariants used.
 See section 
\begin_inset LatexCommand \ref{Sec:temporalScope}

\end_inset 

 for a detailed explanation.
 Access modifiers select methods having the same or a more public access
 modifier.
 Thus, 
\family typewriter 
all
\family default 
 and 
\family typewriter 
private
\family default 
 are equivalent.
 Default is 
\family typewriter 
all
\family default 
.
\layout LyX-Code

-vm --violation-macro macro
\layout Quotation

Specifies what to do, if a constraint fails.
 This string is inserted verbatim into the code.
 The ocl tool appends a pair of parents enclosing a suitable message string.
 Good candidates are 
\family typewriter 
System.\SpecialChar \-
out.\SpecialChar \-
println
\family default 
 (the default) or 
\family typewriter 
throw new RuntimeException
\family default 
.
 Note, that the latter must be enclosed in 
\family typewriter 
""
\family default 
 on Unix shells.
\layout Quotation

The exception thrown must not be a 
\emph on 
checked exception
\emph toggle 
 as specified by 
\begin_inset LatexCommand \cite{JAVA}

\end_inset 

 section 11.2.
 Otherwise the modified code will not compile!
\layout LyX-Code

-tt --trace-types
\layout Quotation

Performs type tracing of collection elements.
 See section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineeringDynamic}

\end_inset 

 for details.
 The information gathered is written to a log file specified by property
 
\family typewriter 
tudresden.\SpecialChar \-
ocl.\SpecialChar \-
injection.\SpecialChar \-
lib.\SpecialChar \-
TypeTracer.log
\family default 
.
\layout Quotation

Note, that the log file must be specified when running the user program,
 not the ocl tool! For example use 
\family typewriter 
-Dtudresden.\SpecialChar \-
ocl.\SpecialChar \-
injection.\SpecialChar \-
lib.TypeTracer.\SpecialChar \-
log=example.\SpecialChar \-
ocl\SpecialChar \-
type\SpecialChar \-
trace
\family default 
.
 If not specified, the type information is written to standard out.
\layout LyX-Code

--insert-immediately
\layout Quotation

Triggers immediate insertion of wrapper methods.
 Otherwise wrapper methods are inserted at the end of each class.
 Immediate insertion allows easier tracing of the modifications.
 This option is mainly useful for debugging.
\layout LyX-Code

--trace-checking
\layout Quotation

Adds code logging each constraint checked on an object to standard out.
 Useful for debugging.
\layout LyX-Code

--simple-hash
\layout Quotation

Uses simple hash functions in 
\family typewriter 
HashSize
\family default 
, instead of the sophisticated hash functions in 
\family typewriter 
HashExact
\family default 
.
 Simple hash functions just return the size of the collection, so they will
 detect insertions/deletions only.
 Reduces CPU load for big models.
\layout LyX-Code

--modcount-hash
\layout Quotation

Uses hash functions in 
\family typewriter 
HashModCount
\family default 
, instead of the hash functions in 
\family typewriter 
HashExact
\family default 
.
 
\family typewriter 
HashModCount
\family default 
 functions are even better in modification detection than functions in 
\family typewriter 
HashExact
\family default 
.
 Also, they are almost as fast as 
\family typewriter 
HashSize
\family default 
.
 However, they heavily depend on internals of the java collections implementatio
n.
 Use at your own risk.
 See section 
\begin_inset LatexCommand \ref{Sec:detectingCollectionChanges}

\end_inset 

.
\layout Chapter

Code Examples
\layout Section

Unreachable Post Condition Code in iContract
\begin_inset LatexCommand \label{sec: unreachableIConstract}

\end_inset 


\layout Standard

This appendix shows, that iContract cannot handle methods with an unreachable
 end of method body as stated in section 
\begin_inset LatexCommand \ref{sec: compareIContract}

\end_inset 

.
\layout Standard

The example is derived from the example code that accompanies iContract.
 The following method provides such a situation: The 
\family typewriter 
throw
\family default 
 statement in the last line prevents the execution path from ever reaching
 the end of the method body.
\layout LyX-Code

/**
\newline 

\protected_separator 
* @post age > 0
\newline 

\protected_separator 
*/
\newline 
public void setAge( int age )
\newline 
{ 
\newline 

\protected_separator 

\protected_separator 
age_ = age;
\newline 

\protected_separator 

\protected_separator 
throw new RuntimeException();
\newline 
}
\layout Standard

Now the post condition has to be included into iContracts configuration,
 so that it actually gets checked.
\layout LyX-Code

iContract.doc.tutorial.Person.Employee.setAge(int) post
\layout Standard

Now iContract performs the instrumentation of source code.
 When trying to compile the instrumented code, the compiler fails:
\layout LyX-Code

Employee.java:166: Statement not reached.
\newline 
/*|*/ try {
\layout Standard

To see why, let's have a look at the instrumented code.
\layout LyX-Code

/**
\newline 
 * @post age > 0
\newline 
 */
\layout LyX-Code

public void setAge(int age )
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/*|*/ //#*#-------------------------------------
\newline 

\protected_separator 

\protected_separator 
/*|*/ 
\emph on 
[ shorted by the author]
\newline 

\emph toggle 

\protected_separator 

\protected_separator 
/*|*/ //-------------------------------------#*#
\newline 

\protected_separator 

\protected_separator 
/*|*/ try {
\newline 

\protected_separator 
 /*|*/ //----------------------------------------
\newline 

\protected_separator 
 /*|*/
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
age_ = age;
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
throw new RuntimeException();
\newline 

\protected_separator 

\protected_separator 
/*|*/ //#*#-------------------------------------
\newline 

\protected_separator 
 /*|*/ try { 
\emph on 
<-- line 166 is here
\emph toggle 

\newline 

\protected_separator 
 /*|*/ if (!(age > 0))
\newline 

\protected_separator 
 /*|*/ 
\protected_separator 

\protected_separator 

\emph on 
[ shortened by the author ]
\emph toggle 

\newline 

\protected_separator 

\protected_separator 
/*|*/ 
\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
}
\newline 

\protected_separator 
 /*|*/ catch ( RuntimeException ex ) {
\newline 

\protected_separator 
 /*|*/ 
\emph on 
[ shortened by the author ]
\emph toggle 
 }
\newline 

\protected_separator 

\protected_separator 
/*|*/
\newline 

\protected_separator 

\protected_separator 
/*|*/ //-----------------------------------#*#
\newline 

\protected_separator 
 /*|*/ 
\newline 

\protected_separator 

\protected_separator 
/*|*/ //#*#-----------------------------------
\newline 

\protected_separator 
 /*|*/ } finally {
\newline 

\protected_separator 

\protected_separator 
/*|*/ 
\emph on 
[ shortened by the author ]
\emph toggle 

\newline 
 
\protected_separator 
/*|*/ }
\layout LyX-Code


\protected_separator 

\protected_separator 
/*|*/ //-----------------------------------#*#
\newline 

\protected_separator 
 /*|*/
\newline 
}
\layout Standard

The original code fragment is followed by generated code checking the post
 condition.
 Since this code isn't reachable, the java compiler fails.
\layout Section

Return Opcodes in Java Byte Code
\begin_inset LatexCommand \label{sec: byteCodeReturn}

\end_inset 


\layout Standard

This appendix lists the example used to verify the statement of section
 
\begin_inset LatexCommand \ref{sec: compareByteCodeInstr}

\end_inset 

, that byte code instrumentation does not need control flow analysis when
 inserting post method code.
\layout Standard

The end of method body below isn't a reachable point of code.
\layout LyX-Code

void method1() 
\newline 
{ 
\newline 

\protected_separator 

\protected_separator 
throw new RuntimeException(); 
\newline 
}
\layout Standard

Thus, the end of the compiled method does not have a return opcode.
 
\layout LyX-Code

Method void method1() 
\newline 
0 new #10 <Class java.lang.RuntimeException> 
\newline 
3 dup 
\newline 
4 invokespecial #14 <Method java.lang.RuntimeException()> 
\newline 
7 athrow 
\layout Standard

The end of the second method 
\emph on 
is
\emph toggle 
 a reachable point of code.
\layout LyX-Code

void method2() 
\newline 
{
\newline 
} 
\layout Standard

Accordingly, the method ends with a return opcode, even if the source code
 did not contain a return statement.
\layout LyX-Code

Method void method2() 
\newline 
0 return 
\layout Standard

Disassembling was done with 
\family typewriter 
javap -c
\family default 
.
\layout Section

The Problem with Versant Database
\begin_inset LatexCommand \label{sec: VersantProblem}

\end_inset 


\layout Standard

This appendix shows why Versant and the Dresden OCL Toolkit don't work together.
 
\layout Standard

The problem is a bug in Java Versant Interface (JVI).
 JVI provides an enhancer, which instruments the user application on byte
 code level.
 The enhancer transforms any access to object fields into a call to a wrapper
 method provided by JVI.
 
\layout Standard

The class used for invariant caching must be database persistent.
 Thus, it also has to be enhanced.
 This class contains the following piece of source code.
\layout LyX-Code

Field f=...;
\newline 
if(f==null)
\newline 

\protected_separator 
 throw new RuntimeException(...);
\newline 
f.setAccessible(true);
\newline 
HashSet observer=(HashSet)(f.get(o));
\protected_separator 
 
\layout Standard

The last line is 
\family typewriter 
Invariant.java:69
\family default 
.
 This line throws the exception shown below.
\layout LyX-Code

java.lang.NoSuchMethodException:
\newline 
_vj_getfield_\SpecialChar \-
com_\SpecialChar \-
net_\SpecialChar \-
linx_\SpecialChar \-
iyp_\SpecialChar \-
businessObject_\SpecialChar \-
InColumnAd_\SpecialChar \-
startOnline
\newline 
at com.versant.trans.Wrappers.method_invoke
\newline 

\protected_separator 

\protected_separator 
(Wrappers.java:209)
\newline 
at com.versant.trans.Wrappers.java_lang_reflect_Field_get_internal
\newline 

\protected_separator 

\protected_separator 
(Wrappers.java:344)
\newline 
at com.versant.trans.Wrappers.java_lang_reflect_Field_get
\newline 

\protected_separator 

\protected_separator 
(Wrappers.java:369)
\newline 
at tudresden.ocl.injection.lib.Invariant.addObserver
\newline 

\protected_separator 

\protected_separator 
(Invariant.java:69)
\newline 
...
\layout Standard

The code line in question contains a method call to 
\family typewriter 
Field.get
\family default 
.
 This method cannot throw a 
\family typewriter 
NoSuchMethodException
\family default 
 under normal circumstances.
\layout Standard

What happened? The enhancer transformed the call to 
\family typewriter 
Field.get
\family default 
 into a call to a wrapper method provided by JVI.
 This method probably does some database stuff, and then tries to access
 the field requested.
 Therefore it tries to invoke another wrapper method 
\family typewriter 
_vj_getfield_\SpecialChar \-
com_\SpecialChar \-
net_\SpecialChar \-
linx_\SpecialChar \-
iyp_\SpecialChar \-
businessObject_\SpecialChar \-
InColumnAd_\SpecialChar \-
startOnline
\family default 
 on the object.
 The class of the object is 
\family typewriter 
InColumnAd
\family default 
, the field requested is 
\family typewriter 
startOnline
\family default 
.
 However, this method does not exist, since the field is inherited from
 its super class.
\layout Standard

This bug prevents any code from accessing object fields via reflection,
 if the objects class inherits this field from a super class.
 This affects the runtime libraries of both the OCL code generator and the
 code instrumentation.
\layout Standard

A possible work-around is to wrap all field accesses with corresponding
 methods.
 These methods would access their field without reflection, thus would not
 be affected by the bug.
 These methods could be created automatically by the OCL code instrumentation.
 This would require a moderate implementation effort.
 However, the design of the OCL toolkit would suffer a much tighter dependency
 between the OCL library and the code instrumentation.
 The author does not plan to implement this work-around.
\layout Standard

On October 13, 2000 Versant support announced a bugfix 
\emph on 

\begin_inset Quotes eld
\end_inset 

available within the next few weeks.
\emph toggle 

\begin_inset Quotes erd
\end_inset 


\layout Standard


\begin_inset LatexCommand \listoffigures

\end_inset 


\layout Bibliography
\bibitem [FF00]{ff3}

Frank Finger.
 Design and Implementation of a Modular OCL Compiler.
 Diplomarbeit.
 TU-Dresden, 2000.
 http://dresden-ocl.\SpecialChar \-
sourceforge.net/.
\layout Bibliography
\bibitem [TP98]{DcC}

Todd Plessel.
 Design By Contract: A Missing Link In The Quest For Quality Software.
 Lockheed Martin / US EPA, August 1998.
 http://www.\SpecialChar \-
elj.\SpecialChar \-
com/\SpecialChar \-
eiffel/\SpecialChar \-
dbc/.
\layout Bibliography
\bibitem [WK99]{Warmer}

Jos Warmer, Anneke Kleppe.
 The Object Constraint Language: Precise Modeling with UML.
 Addison-Wesley, 1999.
\layout Bibliography
\bibitem [WK99e]{WarmerErrata}

Errata for 
\begin_inset LatexCommand \cite{Warmer}

\end_inset 

: http://www.\SpecialChar \-
klasse.\SpecialChar \-
nl/\SpecialChar \-
ocl-boek/\SpecialChar \-
errata.htm.
\layout Bibliography
\bibitem [UML]{UML}

OMG Unified Modeling Language Specification, Version 1.3, June 1999.
\layout Bibliography
\bibitem [OCL]{OCL}

Object Constraint Language Specification.
 Chapter 7 in 
\begin_inset LatexCommand \cite{UML}

\end_inset 

.
\layout Bibliography
\bibitem [JAVA]{JAVA}

James Gosling, Bill Joy, Guy Steele.
 The Java Language Specification.
 Edition 1.0.
 Addison-Wesley, August 1996.
 http://java.\SpecialChar \-
sun.\SpecialChar \-
com/\SpecialChar \-
docs/\SpecialChar \-
books/\SpecialChar \-
jls/\SpecialChar \-
html/\SpecialChar \-
index.html.
\layout Bibliography
\bibitem [JVM]{JVM}

Tim Lindholm, Frank Yellin.
 The Java Virtual Machine Specification, Second Edition.
 Addison-Wesley, 1997.
 http://java.\SpecialChar \-
sun.\SpecialChar \-
com/\SpecialChar \-
docs/\SpecialChar \-
books/\SpecialChar \-
vmspec/.
\layout Bibliography
\bibitem [JW99]{womble}

Daniel Jackson, Allison Waingold.
 Lightweight Extraction of Object Models from Bytecode.
 Proc.
 International Conference on Software Engineering.
 May 1999.
 http://sdg.\SpecialChar \-
lcs.\SpecialChar \-
mit.\SpecialChar \-
edu/\SpecialChar \-
womble/.
\layout Bibliography
\bibitem [KSR00]{kbeans}

Holger Knublauch, Martin Sedlmayr, Thomas Rose.
 Design Patterns for the Implementation of Constraints on JavaBeans.
 http://www.\SpecialChar \-
faw.\SpecialChar \-
uni-ulm.\SpecialChar \-
de/\SpecialChar \-
kbeans/.
\layout Bibliography
\bibitem [DB99]{jassDiplom}

Detlef Bertetzko.
 Parallelitt und Vererbung beim "Programmieren mit Vertrag" - Weiterentwicklung
 von JaWA (in german).
 Master Thesis.
 Universitt Oldenburg 1999.
\layout Bibliography
\bibitem [JASS]{jassWeb}

The Jass Page.
 http://semantik.\SpecialChar \-
informatik.\SpecialChar \-
uni-oldenburg.\SpecialChar \-
de/~jass/.
\layout Bibliography
\bibitem [DH98]{Handshake}

Andrew Duncan, Urs Hlzle.
 Adding Contracts to Java with Handshake.
 Technical Report TRCS98-32, Computer Science Department, University of
 California, Santa Barbara, December 1998.
 http://www.\SpecialChar \-
cs.\SpecialChar \-
ucsb.\SpecialChar \-
edu/\SpecialChar \-
oocsb/\SpecialChar \-
papers/\SpecialChar \-
handshake98.html.
\layout Bibliography
\bibitem [KHB98]{jContractor}

Murat Karaorman, Urs Hlzle, John Bruno.
 jContractor: A Reflective Java Library to Support Design By Contract.
 Technical Report TRCS98-31, Computer Science Department, University of
 California, Santa Barbara, December 1998.
 http://www.\SpecialChar \-
cs.\SpecialChar \-
ucsb.\SpecialChar \-
edu/\SpecialChar \-
oocsb/\SpecialChar \-
papers/\SpecialChar \-
TRCS98-31.html.
\layout Bibliography
\bibitem [MMS]{JMSAssert}

Man Machine Systems.
 JMSAssert.
 http://www.\SpecialChar \-
mmsindia.\SpecialChar \-
com/\SpecialChar \-
JMSAssert.html.
\layout Bibliography
\bibitem [RK98]{iContract}

Reto Kramer.
 iContract - The Java- Design by Contract- Tool.
 http://www.\SpecialChar \-
reliable-systems.\SpecialChar \-
com/\SpecialChar \-
tools/\SpecialChar \-
iContract/\SpecialChar \-
iContract.htm.
\layout Bibliography
\bibitem [PSM98]{findBugsEarly}

Jeffery E.
 Payne, Michael A.
 Schatz, Matthew N.
 Schmid.
 Finding bugs early.
 Dr.
 Dobb's Journal January 1998.
 http://www.\SpecialChar \-
ddj.\SpecialChar \-
com/\SpecialChar \-
articles/\SpecialChar \-
1998/\SpecialChar \-
9801/\SpecialChar \-
9801d/\SpecialChar \-
9801d.htm.
\layout Bibliography
\bibitem [RG00]{USE}

Mark Richters, Martin Gogolla.
 Validating UML Models and OCL Constraints.
 In Andy Evans and Stuart Kent, editors, Proc.
 3rd Int.
 Conf.
 Unified Modeling Language(UML'2000).
 Springer, Berlin, LNCS, 2000.
 http://www.\SpecialChar \-
db.\SpecialChar \-
informatik.\SpecialChar \-
uni-bremen.\SpecialChar \-
de/\SpecialChar \-
projects/USE/.
\layout Bibliography
\bibitem [BS]{Bold}

BoldSoft.
 ModelRun.
 http://www.\SpecialChar \-
boldsoft.\SpecialChar \-
com/\SpecialChar \-
products/\SpecialChar \-
model\SpecialChar \-
run/\SpecialChar \-
index.html.
\layout Bibliography
\bibitem [ELX]{elixir}

Elixir Technology Pte Ltd.
 http://www.\SpecialChar \-
elixirtech.\SpecialChar \-
com/\SpecialChar \-
index.html.
\layout Bibliography
\bibitem [CMA]{CodeInstrumentation}

Glen McCluskey & Associates LLC.
 Java Test Coverage and Instrumentation Toolkits.
 http://www.\SpecialChar \-
glenmccl.\SpecialChar \-
com/\SpecialChar \-
instr/\SpecialChar \-
index.htm.
\layout Bibliography
\bibitem [CIG]{Cybernetic}

Cybernetic Intelligence GmbH.
 OCL Compiler.
 http://www.\SpecialChar \-
cybernetic.\SpecialChar \-
org/\SpecialChar \-
prodocl.htm.
\layout Bibliography
\bibitem [OIJV]{jvision}

Object Insight, Inc.
 JVISION.
 http://www.\SpecialChar \-
object-insight.\SpecialChar \-
com/\SpecialChar \-
html/\SpecialChar \-
product_info.html.
\layout Bibliography
\bibitem [RW00]{rw7}

Ralf Wiebicke.
 XML Query Languages for Repositories Based on XML Documents.
 Groer Beleg.
 TU-Dresden 2000.
 http://dresden-ocl.\SpecialChar \-
sourceforge.net/.
\layout Bibliography
\bibitem [FSF00]{freesw}

Free Software Foundation.
 What is Free Software? 1996-2000.
 http://www.\SpecialChar \-
gnu.\SpecialChar \-
org/\SpecialChar \-
philosophy/\SpecialChar \-
free-sw.html.
\the_end
