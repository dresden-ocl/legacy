#This file was created by <wiera> Wed Jul 26 17:15:22 2000
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass report
\begin_preamble
\usepackage{textcomp}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Diploma Thesis:
\newline 
Utility Support for Checking OCL Business Rules in Java Programs
\layout Author

Ralf Wiebicke
\layout Date

May 2000
\layout Section*

Copyright
\layout Standard

Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke.
\layout Standard

Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.1 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is available at http://www.gnu.org/copyleft/fdl.html.
\layout Standard

The source code developed together with this paper is Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke and published under the GNU Lesser General Public License.
\layout Section*

Availability
\layout Standard

This document is available at http://dresden-ocl.sourceforge.net/diploma_rw7/
 in several electronic forms including 
\latex latex 

\backslash 
LaTeX{}
\latex default 
, Postscript, PDF, Html and the original kLyx version.
 
\layout Standard

The source code developed together with this paper is available at http://dresde
n-ocl.sourceforge.net/.
\layout Standard


\begin_inset LatexCommand \tableofcontents

\end_inset 


\layout Chapter

Introduction
\layout Section

OCL and Extreme Programming
\layout Chapter

Code Generation
\layout Section

Representation Of Associations
\layout Subsection

Possibilities
\layout Itemize

Collections named by the role name (maps for qualified associations)
\layout Itemize

Methods (isEmployed)
\layout Subsection

CASE-Tools
\layout Subsection

Net-Linx
\layout Standard

adaptability an legacy Quellcode.
\layout Section

Model Information
\begin_inset LatexCommand \label{Sec:element_type_tag}

\end_inset 


\layout Standard

Needed for Type Checking.
\layout Standard

See 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 5.3.3
\layout Standard

There is already the Reflection Facade, which is pretty cool with two exception:
 
\layout Enumerate

no element types of associations.
 
\layout Enumerate

no isquery tag
\layout Standard

Solution: extend the java language.
 The new tag has a syntax like 
\family typewriter 
@see
\family default 
, but restricted to classes only.
\layout LyX-Code

class Company
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
All persons employed
\protected_separator 
by this company.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
 
\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Collection employees;
\newline 
}
\layout Standard

The this is extended to Maps, which represent qualified associations of
 the UML model.
\layout LyX-Code

class Bank
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
Customers qualified by
\protected_separator 
their account number.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@key-type Integer
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Map customers;
\newline 
}
\layout Standard

Cool implementation: an extension of the reflection API and the java compiler.
\layout Standard

My implementation: An extension of the reflection facade scanning the source
 code for these comments.
 Encapsulated in tudresden.ocl.check.types.ReflectionExtender.
\layout Paragraph

Where comes the tag?
\layout Itemize

CASE-Tools
\layout Itemize

handmade: good-practice of programming.
 Should be there already in the comments, the tag makes it available formally.
\layout Itemize

reverse engineering.
 see chapter 
\begin_inset LatexCommand \ref{Sec:ReverseEngineering}

\end_inset 

.
\layout Standard

Will be tested automatically by the injected code.
\layout Standard

Is a good help for further reverse engineering from Java to UML (diploma
 Stefan Frisch?)
\layout Section

Looking at @pre-vious States
\layout Standard

only 1 @pre pro navigation, may be proposal
\layout Chapter

Code Injection
\layout Standard

Injection of generated code into java programs is the main subject of this
 paper.
 It covers anything beyond code generation, to get a java model checking
 it's own constraints.
 For an idea, where code generation ends and injection starts, see section
 
\begin_inset LatexCommand \ref{Sec:codegeneration_result}

\end_inset 

.
 
\layout Standard

This is followed by an analysis of requirements for the code injection and
 resulting design decisions in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements}

\end_inset 

.
 Sections 
\begin_inset LatexCommand \ref{Sec:wrappingMethods}

\end_inset 

 and 
\begin_inset LatexCommand \ref{Sec:cleaningCode}

\end_inset 

 describe the solution in detail.
\layout Standard

Finally sections 
\begin_inset LatexCommand \ref{Sec:structuralScope}

\end_inset 

 and 
\begin_inset LatexCommand \ref{Sec:temporalScope}

\end_inset 

 discuss the more fundamental issue, when and how often invariants have
 to be checked.
\layout Section

Results of Code Generation
\begin_inset LatexCommand \label{Sec:codegeneration_result}

\end_inset 


\layout Standard

The java code generator developed in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 produces a set of code fragments (
\family typewriter 
tudresden.ocl.codegen.CodeFragment
\family default 
).
 These code fragment have the following properties:
\layout Description

Constrained
\protected_separator 
type is the default navigation context of this constraint.
\layout Description

Kind specifies, whether this constraint is an invariant, a pre- or a postconditi
on.
 For each postcondition containing a @pre expression there are two additional
 codefragments called preparation and transfer.
 See below.
\layout Description

Constrained
\protected_separator 
operation is the operation, this constraint applies to (valid for pre- and
 postconditions only).
\layout Description

Code contains the actual java code to be executed.
\layout Description

Result
\protected_separator 
variable specifies the boolean value, which contains the result of the ocl
 expression after code execution.
\layout Subsection

Preparation and Transfer Fragments
\layout Standard

The meaning of preparation and transfer fragments is explained on a dramatically
 simplified example.
 
\layout Standard

Suppose a post condition for operation 
\family typewriter 
employ()
\family default 
, that leaves the attribute 
\family typewriter 
age
\family default 
 unchanged:
\layout LyX-Code

context Person::employ() 
\newline 
post: age=age@pre
\layout Standard

the following codefragments will be produced:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 1 0 0
0 0 0 0
0 1 0 0
2 0 0 "" ""
2 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Kind
\newline 
 Code
\newline 
Transfer
\newline 

\family typewriter 
int node1;
\family default 
 
\newline 
Preparation
\newline 

\family typewriter 
node1=this.age;
\family default 

\newline 
Post Condition
\newline 

\family typewriter 
int node2=this.age;
\family default 

\newline 

\newline 

\family typewriter 
boolean result=(node1==node2)
\layout Standard

Typically these fragments would be injected as follows:
\layout LyX-Code

class Person
\newline 
{
\newline 

\protected_separator 
 void employ()
\newline 

\protected_separator 

\protected_separator 
{
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
int node1;
\family default 
 
\protected_separator 
 
\protected_separator 
 
\protected_separator 
 // transfer fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
node1=this.age;
\family default 
 
\protected_separator 
// preparation fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// original code of employ()
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// post condition fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
node1=this.age;
\family default 

\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
boolean result=(node1==node2)
\family default 

\newline 

\protected_separator 

\protected_separator 
}
\newline 
}
\layout Standard

Note, that precise semantics of codefragments involving the @pre expression
 has been changed, so that the original meaning described in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 7.1.2 is no longer fully correct.
 For a detailed comparison see section 
\begin_inset LatexCommand \ref{Sec:maintainJavaCodeGenerator}

\end_inset 

.
\layout LyX-Code


\protected_separator 

\layout Section

Requirements and Design Decisions
\begin_inset LatexCommand \label{Sec:injection_requirements}

\end_inset 


\layout Standard

This section analyzes the requirements for the injector tool and derives
 some fundamental design decisions.
\layout Subsection

Reversable Modification
\layout Standard

The most important feature is the reversability of the code injection.
 It must be possible
\layout Itemize

to clean the code tracelessly from all injected fragments.
\layout Itemize

to redo the injection on source code that has already been modified (i.e.
 when constraints have been changed).
\layout Itemize

to edit the modified source code without losing all changes at the next
 injection.
 
\layout Standard

This requirement makes things quite a bit more difficult, but there are
 serious reasons for this.
 Otherwise there would be two versions of source code: the original and
 the modified version.
 This raises some unpleasant problems:
\layout Enumerate

Configuration management must handle two source code trees.
\layout Enumerate

Developers must be careful to edit the original version only.
\layout Enumerate

Running the ocl injector is required after every change of the java source
 code, not only when the constraints have been changed.
 
\layout Enumerate

Stack traces of runtime exceptions point to the modified source code.
 Developers must look for the corresponding place in the original version.
\layout Standard

The implementation of reversable modification requires a strategy of minimally
 invasive modification.
 This is realized by two design decisions:
\layout Enumerate

Method wrappers, explained detailed in section 
\begin_inset LatexCommand \ref{Sec:wrappingMethods}

\end_inset 

.
\layout Enumerate

Explicit package qualifiers for the ocl library in the generated code.
 Otherwise, an import statement for the ocl library would be necessary.
 This would be just another spot, were the original source code has to be
 touched.
 Additionally, this may introduce name conflicts beetween ocl library and
 user code.
\layout Subsection

Embedding Constraints in Java Source Code.
\layout Standard

It should be possible to embed constraints in the java documentation comments.
 The placement of embedded constraints implicates (and replaces) the context
 of the constraint.
 See the example below.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@invariant age>0
\newline 
*/
\newline 
class Person
\newline 
{
\newline 

\protected_separator 

\protected_separator 
int age;
\newline 

\protected_separator 

\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@postcondition age=age@pre
\newline 

\protected_separator 

\protected_separator 
*/
\newline 
 
\protected_separator 
void employ();
\newline 
}
\layout Standard

It is necessary to put the constraints directly under the nose of the developer.
 The author is strongly convinced, that constraints stored in an extra text
 file are too far away from attention.
\layout Subsection

Checking the Element Type.
\layout Standard

The injected code must check, that collection attributes comply to the 
\family typewriter 
@element-type
\family default 
 and 
\family typewriter 
@key-type
\family default 
 tags introduced in section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

.
 This is quite easily done just before checking invariants.
\layout Standard

Note, that this feature may be be used standalone, without ocl expressions
 at all.
 Then it provides a runtime check for typed collections.
\layout Section

Methods Wrappers
\begin_inset LatexCommand \label{Sec:wrappingMethods}

\end_inset 


\layout Standard

Touching the code of each method is needed, because the generated code must
 be run on each call to the method.
\layout Standard

Using wrapper methods avoids many problems which arise if there are several
 return statements in a method or a complex expression in the return statement.
 Also, there are no name conflicts anymore beetween the original and the
 generated code.
\layout Paragraph

Example.
\layout Standard

This is, how it works: A method
\layout LyX-Code

int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
} 
\layout Standard

is transformed into two methods:
\layout LyX-Code

int someMethod_wrappedbyocl(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
}
\newline 

\protected_separator 

\newline 
int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/preconditions.
\newline 

\protected_separator 

\protected_separator 
int result=someMethod_wrappedbyocl(x);
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/postconditions.
\newline 

\protected_separator 

\protected_separator 
return result;
\newline 
}
\layout Standard

Slightly different and a bit tricky for constructors:
\layout LyX-Code

SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\layout Standard

gets to
\layout LyX-Code

SomeClass(String x, Void void)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\newline 

\protected_separator 

\newline 
SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
this(x, new Void());
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants.
\newline 
}
\layout Section

Cleaning the Code
\begin_inset LatexCommand \label{Sec:cleaningCode}

\end_inset 


\layout Standard

One of my goals for the injector tool is the following:
\layout Quote

The user may inject generated code into arbitrary user code in place, edit
 the modified source code, redo the injection in place when the ocl constraints
 have changed, and clean the code from the injected code.
 Cleaning means, that there is not a single byte left in the source.
\layout Standard

This section explains, how the injector tool accomplishes this goal.
\layout Standard

The injector tool touches the user code in two different ways:
\layout Enumerate

renaming the wrapped methods
\layout Enumerate

adding new class features, i.e.
 wrapper methods, semaphore attributes
\layout Paragraph

Renaming Wrapped Methods.
\layout Standard

For each method to be wrapped the suffix 
\family typewriter 
_wrappedbyocl
\family default 
 is appended to the name.
 This transformation is done in the unparsed method header, so all typographical
 extras in the header (line breaks, comments etc.) are preserved.
 This transformation is easily reversed, when the code has to be cleaned.
\layout Paragraph

Cleaning Generated Class Features
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@author ocl_injector
\newline 
*/
\newline 
int someMethod(double x);
\newline 

\layout Section

Structural Scope of Invariants
\begin_inset LatexCommand \label{Sec:structuralScope}

\end_inset 


\layout Standard

hen to check which invariants
\layout Section

Temporal Scope of Invariants
\begin_inset LatexCommand \label{Sec:temporalScope}

\end_inset 


\layout Enumerate

all methods
\layout Enumerate

public methods
\layout Enumerate

transactions
\layout Standard

refere to tutorial parameters of injector
\layout Chapter

Reverse Engineering
\begin_inset LatexCommand \label{Sec:ReverseEngineering}

\end_inset 


\layout Standard

Avoid the UML model for type checking.
\layout Standard

An interactive tool for injecting 
\family typewriter 
@element-type
\family default 
 tags into the code using information obtained from the source code or dynamical
ly on run time.
\layout Section

Static Information
\layout Standard

Information about element types may be derived from static properties of
 the class, such as parameter types of methods and tags in doccomments.
 The following example suggests some of these properties.
 
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
All employees of this company.
\newline 

\protected_separator 
 
\protected_separator 
@see 
\bar under 
Person
\bar default 

\newline 
*/
\newline 
Collection employees;
\newline 

\protected_separator 

\newline 
boolean isEmployee(
\bar under 
Person
\bar default 
);
\newline 
void addEmployee(
\bar under 
Person
\bar default 
);
\newline 
void removeEmployee(
\bar under 
Person
\bar default 
);
\layout Standard

An interactive tool should support the developer by presenting these properties
 in a comfortable way.
 There should be a special indication, if several properties suggest different
 element types.
\layout Standard

Note, that the example above requires linguistic knowledge about plural
 and singular form of nouns (employee here).
 This gets far more difficult, if identifiers are not English.
\layout Section

Tracing Dynamic Type Information
\layout Itemize

Enrich the code with tracing the object types inside collections.
\layout Itemize

compile and run the program (regression tests if available)
\layout Chapter

Maintaining the OCL Compiler
\layout Standard

This chapter describes all major changes to Frank Fingers OCL compiler.
 This includes bugfixes too, if they caused changes of internal or external
 interfaces.
\layout Section

Using reflection in ReflectionFacade and ocl library
\layout Enumerate

Added polymorphism of operation parameters (ReflectionFacade.\SpecialChar \-
navigateParameterize
d and OclAnyImpl.getFeature).
 This made ReflectionAdapter.getClassForType superfluous, so removed.
\layout Enumerate

Now its mandatory to provide a NameAdapter to the ocl library.
 Otherwise NullPointerExceptions are thrown.
 The default functionality if no NameAdapter is given has been moved into
 a separate NameAdapter (SimpleNameAdapter) which is used in ReflectionFacade
 as well.
 
\layout Enumerate

Added a simplified form of qualified associations to ReflectionFacade and
 ocl library.
 Simplification means, that there may be only one qualifier attribute.
 Qualified associations are represented by java.util.Map.
 ReflectionAdapter.isMap.
\layout Enumerate

New mapping beetween collections in OCL and Java conforming to JDK1.2.
 The special handling of Vector is used for older code generators.
 (DefaultOclFactory.getOclRepresentationFor(Object) and DefaultReflectionAdapter.g
etClassForType)
\begin_deeper 
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 3 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
0 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Java (java.util)
\newline 
Ocl.TAKE_VECTORS_AS_SET
\newline 
OCL
\newline 
List
\newline 
-
\newline 
Sequence
\newline 
Vector
\newline 
false
\newline 
Sequence
\newline 

\newline 
true
\newline 
Set
\newline 
Set
\newline 
-
\newline 
Set
\newline 
Map
\newline 
-
\newline 
Set (qualified)
\end_deeper 
\layout Section

ocl lib
\layout Enumerate

removed 
\family typewriter 
Ocl.STRICT_CHECKING
\family default 
, replaced exceptions by undefined values, parameterized with the reason
 for the undefined value.
\layout Enumerate

Ocl.Collection.setToRange makes an undefined collection (instead of throwing
 an exception), if lower bound is greater than upper bound.
\layout Enumerate

Ocl.to<OclType>(OclRoot) methods check for undefined arguments.
\layout Section

Typechecker
\layout Enumerate

added OclAny to TypeChecker (DefaultTypeFactory).
 
\layout Enumerate

Bugfix, removed TypeFactory.getClassifier - replaced all calls by TypeFactory.get
\layout Section

JavaCodeGenerator: 
\begin_inset LatexCommand \label{Sec:maintainJavaCodeGenerator}

\end_inset 


\layout Enumerate

different meaning of Codefragments created for @pre expressions (TRANSFER,
 PREPARATION, CODE), makes it easier and more flexible for different code
 injector tools.
 compare to 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 7.1.2, description of new behavior in section 
\begin_inset LatexCommand \ref{Sec:codegeneration_result}

\end_inset 

, TODO comparison to Franks example
\layout Enumerate

explicit package qualifier for ocl library is optionally prepended.
 Replaces the import statement and therefore fulfills the corresponding
 requirement in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements}

\end_inset 

.
\layout Section

Silly Bugfixes
\layout Enumerate

JavaCodeGenerator: order on arrow
\layout Enumerate

Basic.navigate: max[1]
\layout Enumerate

DefaultOclFactory.getOclRepresentationFor(Object): dealing with Float and
 Double
\layout Enumerate

OclCollection.setToRange: exchanged bounds in error condition
\layout Chapter
\start_of_appendix 
Injector Tutorial
\layout Standard

This chapter describes, how to use the injector tool.
\layout Bibliography
\bibitem [FF00]{ff3}

Frank Finger.
 Design and Implementation of a Modular OCL Compiler.
 Diplomarbeit.
 TU-Dresden 2000.
 http://www-st.inf.tu-dresden.de/ocl/
\layout Bibliography
\bibitem [UML]{UML}

OMG Unified Modeling Language Specification, Version 1.3, June 1999.
\layout Bibliography
\bibitem [OCL]{OCL}

Object Constraint Language Specification.
 Chapter 7 in 
\begin_inset LatexCommand \cite{UML}

\end_inset 

.
\the_end
