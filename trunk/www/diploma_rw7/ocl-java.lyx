#This file was created by <wiera> Mon Aug  7 17:43:59 2000
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass report
\begin_preamble
\usepackage{textcomp}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Diploma Thesis:
\newline 
Utility Support for Checking OCL Business Rules in Java Programs
\layout Author

Ralf Wiebicke
\layout Date

May 2000
\layout Section*

Copyright
\layout Standard

Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke.
\layout Standard

Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.1 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is available at http://www.gnu.org/copyleft/fdl.html.
\layout Standard

The source code developed together with this paper is Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke and published under the GNU Lesser General Public License.
\layout Section*

Availability
\layout Standard

This document is available at http://dresden-ocl.sourceforge.net/diploma_rw7/
 in several electronic forms including 
\latex latex 

\backslash 
LaTeX{}
\latex default 
, Postscript, PDF, Html and the original kLyx version.
 
\layout Standard

The source code developed together with this paper is available at http://dresde
n-ocl.sourceforge.net/.
\layout Standard


\begin_inset LatexCommand \tableofcontents

\end_inset 


\layout Chapter

Introduction
\layout Section

OCL and Extreme Programming
\layout Chapter

Code Generation
\layout Section

Representation Of Associations
\layout Subsection

Possibilities
\layout Itemize

Collections named by the role name (maps for qualified associations)
\layout Itemize

Methods (isEmployed)
\layout Subsection

CASE-Tools
\layout Subsection

Net-Linx
\layout Standard

adaptability to legacy Quellcode.
\layout Section

Model Information
\begin_inset LatexCommand \label{Sec:element_type_tag}

\end_inset 


\layout Standard

The OCL compiler needs model information for type checking.
 How this works is explained in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 5.3.3.
 The sources for model information may be a UML model exported from a CASE
 tool, or the java source code, which is accessed through reflection API
\begin_float footnote 
\layout Standard

see class 
\family typewriter 
tudresden.ocl.check.types.ReflectionFacade
\family default 
.
\end_float 
.
 The latter approach is very convenient, since most java projects don't
 have a (up to date) UML representation of their business model.
 
\layout Standard

However, java reflection lacks some model properties which are important
 for type checking.
\layout Enumerate

Element types of collections, particularly collections representing associations.
 
\layout Enumerate

Qualifier types of maps, representing qualified associations.
\layout Enumerate

The isQuery tag of operations.
 Note, that OCL expressions may use operations without side effects (queries)
 only.
\layout Standard

The solution is to put the additional information needed into java documentation
 comments.
 See the example below.
 
\layout LyX-Code

class Company
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
All persons employed
\protected_separator 
by this company.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
 
\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Collection employees;
\newline 
}
\layout Standard

The new 
\family typewriter 
@element-type
\family default 
 tag has a syntax like 
\family typewriter 
@see
\family default 
 as defined in 
\begin_inset LatexCommand \cite{JAVA}

\end_inset 

 section 18.4.1, but may refer to classes and interfaces only.
 This tag is valid for attributes only, and there may be only one of such
 tags per documentation comment.
 The tag is not restricted to attributes of type 
\family typewriter 
java.util.Collection
\family default 
, since future implementations could use other collection API's as well.
\layout Standard

Analogously, the 
\family typewriter 
@key-type
\family default 
 tag is introduced for association qualifiers.
 
\layout LyX-Code

class Bank
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
Customers qualified by
\protected_separator 
their account number.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@key-type Integer
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Map customers;
\newline 
}
\layout Standard

Note, that the reflection model is restricted to qualified associations
 with one qualifier only.
 
\begin_inset LatexCommand \cite{UML}

\end_inset 

 allows multiple qualifiers, but there is no convenient representation for
 this in java.
 
\layout Standard

Furthermore, UML specifies the unqualified association feature to be a set,
 i.e.
 there must be no duplicates.
 Since this is not enforced by 
\family typewriter 
java.util.Map
\family default 
 (only keys are guaranteed to be unique), the injector provides an appropriate
 runtime check.
\layout Paragraph

Implementation.
\layout Standard

A really comfortable implementation would let the java compiler do the parsing,
 and provide the information through an extended reflection API.
 This would be similar to the 
\family typewriter 
@deprecated
\family default 
 tag.
 My implementation extends
\begin_float footnote 
\layout Standard

Encapsulated in 
\family typewriter 
tudresden.ocl.check.types.ReflectionExtender
\family default 
.
\end_float 
 the reflection facade by scanning the source code for these comments on
 demand.
 This implies, that the java source code is necessary for type checking
 OCL constraints in addition to the class files.
\layout Standard

There is a crucial question left: Where do the tags come? Possible sources
 are:
\layout Itemize

A UML model.
 The code generator of a CASE tool could generate these tags.
 
\layout Itemize

Maintained by hand.
 It is good-practice of programming, to specify which kind of objects are
 supposed to be in a collection attribute.
 The tags just make this information available formally.
 
\layout Itemize

Reverse Engineering.
 This is discussed in detail in chapter 
\begin_inset LatexCommand \ref{Sec:ReverseEngineering}

\end_inset 

.
\layout Standard

Collection attributes with type tags are verified on runtime by the injected
 code.
 Note, that this kind of type information is useful for reverse engineering
 a UML model from given java code.
\layout Section

Looking at @pre-vious States
\layout Standard

only 1 @pre pro navigation, may be proposal
\layout Chapter

Code Injection
\layout Standard

Injection of generated code into java programs is the main subject of this
 paper.
 It covers anything beyond code generation, to get a java model checking
 its own constraints.
 For an idea, where code generation ends and injection starts, see section
 
\begin_inset LatexCommand \ref{Sec:codegeneration_result}

\end_inset 

.
 
\layout Standard

This is followed by an analysis of requirements for the code injection and
 resulting design decisions in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements}

\end_inset 

.
 Sections 
\begin_inset LatexCommand \ref{Sec:wrappingMethods}

\end_inset 

 and 
\begin_inset LatexCommand \ref{Sec:cleaningCode}

\end_inset 

 describe the solution in detail.
\layout Standard

Finally sections 
\begin_inset LatexCommand \ref{Sec:temporalScope}

\end_inset 

 and 
\begin_inset LatexCommand \ref{Sec:structuralScope}

\end_inset 

 discuss the more fundamental issue, when and how often invariants have
 to be checked.
\layout Section

Results of Code Generation
\begin_inset LatexCommand \label{Sec:codegeneration_result}

\end_inset 


\layout Standard

The java code generator developed in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 produces a set of code fragments
\begin_float footnote 
\layout Standard

see class 
\family typewriter 
tudresden.ocl.codegen.CodeFragment.
\end_float 
.
 These code fragment have the following properties:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "70mm" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Property 
\newline 

\newline 
Constrained
\protected_separator 
type 
\newline 
The default navigation context of this constraint.
\newline 
Kind 
\newline 
Specifies, whether this constraint is an invariant, a pre- or a postcondition.
 
\newline 
Constrained
\protected_separator 
operation 
\newline 
The operation, this constraint applies to (valid for pre- and postconditions
 only).
\newline 
Code 
\newline 
Contains the actual java code to be executed.
\newline 
Result
\protected_separator 
variable 
\newline 
Specifies the boolean value, which contains the result of the ocl expression
 after code execution.
\layout Standard

For each postcondition containing a @pre expression there are two additional
 codefragments called preparation and transfer.
 See below.
\layout Subsection

Preparation and Transfer Fragments
\layout Standard

The meaning of preparation and transfer fragments is explained on a dramatically
 simplified example.
 
\layout Standard

Suppose a post condition for operation 
\family typewriter 
employ()
\family default 
, that leaves the attribute 
\family typewriter 
age
\family default 
 unchanged:
\layout LyX-Code

context Person::employ() 
\newline 
post: age=age@pre
\layout Standard

the following codefragments will be produced:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 1 0 0
0 0 0 0
0 1 0 0
2 0 0 "" ""
2 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Kind
\newline 
 Code
\newline 
Transfer
\newline 

\family typewriter 
int node1;
\family default 
 
\newline 
Preparation
\newline 

\family typewriter 
node1=this.age;
\family default 

\newline 
Post Condition
\newline 

\family typewriter 
int node2=this.age;
\family default 

\newline 

\newline 

\family typewriter 
boolean result=(node1==node2)
\layout Standard

Typically these fragments would be injected as follows:
\layout LyX-Code

class Person
\newline 
{
\newline 

\protected_separator 
 void employ()
\newline 

\protected_separator 

\protected_separator 
{
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
int node1;
\family default 
 
\protected_separator 
 
\protected_separator 
 
\protected_separator 
 // transfer fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
node1=this.age;
\family default 
 
\protected_separator 
// preparation fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// original code of employ()
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// post condition fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
node1=this.age;
\family default 

\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
boolean result=(node1==node2)
\family default 

\newline 

\protected_separator 

\protected_separator 
}
\newline 
}
\layout Standard

Note, that precise semantics of codefragments involving the @pre expression
 has been changed, so that the original meaning described in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 7.1.2 is no longer fully correct.
 For a detailed comparison see section 
\begin_inset LatexCommand \ref{Sec:maintainJavaCodeGenerator}

\end_inset 

.
\layout LyX-Code


\protected_separator 

\layout Section

Requirements and Design Decisions
\begin_inset LatexCommand \label{Sec:injection_requirements}

\end_inset 


\layout Standard

This section analyzes the requirements for the injector tool and derives
 some fundamental design decisions.
\layout Subsection

Reversable Modification
\begin_inset LatexCommand \label{Sec:injection_requirements_reversable}

\end_inset 


\layout Standard

The most important feature is the reversability of the code injection.
 It must be possible
\layout Itemize

to clean the code tracelessly from all injected fragments.
\layout Itemize

to redo the injection on source code that has already been modified (i.e.
 when constraints have been changed).
\layout Itemize

to edit the modified source code without losing all changes at the next
 injection.
 
\layout Standard

This requirement makes things quite a bit more difficult, but there are
 serious reasons for this.
 Otherwise there would be two versions of source code: the original and
 the modified version.
 This raises some unpleasant problems:
\layout Enumerate

Configuration management must handle two source code trees.
\layout Enumerate

Developers must be careful to edit the original version only.
\layout Enumerate

Running the ocl injector is required after every change of the java source
 code, not only when the constraints have been changed.
 
\layout Enumerate

Stack traces of runtime exceptions point to the modified source code.
 Developers must look for the corresponding place in the original version.
\layout Standard

The implementation of reversable modification requires a strategy of minimally
 invasive modification.
 This is realized by two design decisions:
\layout Enumerate

Method wrappers, explained detailed in section 
\begin_inset LatexCommand \ref{Sec:wrappingMethods}

\end_inset 

.
\layout Enumerate

Explicit package qualifiers for the ocl library in the generated code.
 Otherwise, an import statement for the ocl library would be necessary.
 This would be just another spot, were the original source code has to be
 touched.
 Additionally, this may introduce name conflicts beetween ocl library and
 user code.
\layout Subsection

Embedding Constraints in Java Source Code.
\layout Standard

It should be possible to embed constraints in the java documentation comments.
 The placement of embedded constraints implicates (and replaces) the context
 of the constraint.
 See the example below.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@invariant age>0
\newline 
*/
\newline 
class Person
\newline 
{
\newline 

\protected_separator 

\protected_separator 
int age;
\newline 

\protected_separator 

\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@postcondition age=age@pre
\newline 

\protected_separator 

\protected_separator 
*/
\newline 
 
\protected_separator 
void employ();
\newline 
}
\layout Standard

It is necessary to put the constraints directly under the nose of the developer.
 The author is strongly convinced, that constraints stored in an extra text
 file are too far away from attention.
\layout Standard

This feature is not implemented yet.
 TODO.
\layout Subsection

Checking the Element Type.
\layout Standard

The injected code must check, that collection attributes comply to the 
\family typewriter 
@element-type
\family default 
 and 
\family typewriter 
@key-type
\family default 
 tags introduced in section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

.
 This is quite easily done just before checking invariants.
\layout Standard

Note, that this feature may be be used standalone, without ocl expressions
 at all.
 Then it provides a runtime check for typed collections.
\layout Section

Methods Wrappers
\begin_inset LatexCommand \label{Sec:wrappingMethods}

\end_inset 


\layout Standard

The main task of code injection is to have some code executed immediately
 before and after all methods (and after all constructors too).
 This section describes, how this is done by the ocl injector.
\layout Paragraph

Simple Approach.
\layout Standard

The simple approach of adding the code directly into the method raises some
 severe problems.
 
\layout Enumerate

The postcondition code to be executed after the method has to be inserted
 at any return statement.
\layout Enumerate

A return expression has to be computed in advance, if the post condition
 code refers to the return value and/or the the return expression produces
 side effects.
\layout Enumerate

There may be name conflicts beetween the original and the generated code.
\layout Enumerate

A complete java parser is needed.
\layout Enumerate

The original code has to be touched at many different places and in a complicate
d way.
 This runs contrary to the strategy of minimally invasive modification as
 decided in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements_reversable}

\end_inset 

.
\layout Standard

Method wrappers solve all these problems in a nifty but simple way.
\layout Paragraph

Wrapping Methods.
\layout Standard

Some code tells more than thousand words, so I use an example to explain.
 Consider the following method.
\layout LyX-Code

int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
} 
\layout Standard

The code injector transforms this into two methods.
\layout LyX-Code

int someMethod_wrappedbyocl(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
}
\newline 

\protected_separator 

\newline 
int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/preconditions.
\newline 

\protected_separator 

\protected_separator 
int result=someMethod_wrappedbyocl(x);
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/postconditions.
\newline 

\protected_separator 

\protected_separator 
return result;
\newline 
}
\layout Standard

The reader may have a look back at the problems encountered for the simple
 approach.
 Non of them exists anymore.
 Especially, a very inchoate java parser is sufficient, which understands
 anything outside of method bodies and attribute initializers only.
\layout Paragraph

Wrapping Constructors (not yet implemented).
\layout Standard

Another transformation is used for constructors, since they cannot be renamed.
\layout LyX-Code

SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\layout Standard

Instead of renaming, the original constructor gets an additional dummy argument.
\layout LyX-Code

SomeClass(String x, Void dummy)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\newline 

\protected_separator 

\newline 
SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
this(x, new Void());
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants.
\newline 
}
\layout Standard

If a class provides no explicit constructor, then there is the default construct
or as specified in 
\begin_inset LatexCommand \cite{JAVA}

\end_inset 

 section 8.6.7.
 This default constructor is not wrapped, but replaced by an explicit constructo
r with the same access modifier.
\layout Section

Cleaning the Code
\begin_inset LatexCommand \label{Sec:cleaningCode}

\end_inset 


\layout Standard

One of the requirements was, that the injector is able clean the modified
 code without leaving any traces.
 This section explains, how this requirement is met.
 The user code is touched in two different ways only:
\layout Enumerate

Renaming the wrapped methods.
\layout Enumerate

Adding new object features, i.e.
 wrapper methods, a method for checking invariants and a semaphore attribute.
\layout Paragraph

Renaming Wrapped Methods.
\layout Standard

For each method to be wrapped the suffix 
\family typewriter 
_wrappedbyocl
\family default 
 is appended to the name.
 This transformation is done on the unparsed method header, so all typographical
 extras (line breaks, comments etc.) are preserved.
 This transformation is easily reversed, when the code has to be cleaned.
\layout Paragraph

Removing Generated Features.
\layout Standard

Removing generated class features relies on the fact, that the injector
 tags all generated features as shown below.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@author ocl_injector
\newline 
*/
\newline 
void checkOclInvariants();
\layout Standard

This is quite simple and functional.
\layout Section

Scope of Invariants
\begin_inset LatexCommand \label{Sec:temporalScope}

\end_inset 


\layout Standard

This section discusses the issue, when an invariant is required to be fulfilled.
 
\begin_inset LatexCommand \cite{Warmer}

\end_inset 

 section 5.4.2 suggests to check invariants immediately after an object has
 changed.
 This is not workable, even if runtime efficiency is ignored.
 Modifications on the model often produce intermediate states, which are
 not consistent according to the constraints.
\layout Standard

When using databases the answer is simple: invariants must be valid outside
 of transactions.
 Since the java system does not provide transactions, the code injector
 offers several strategies for various user requirements.
\layout Standard

Invariants may be required to be fulfilled on:
\layout Itemize

All methods.
 This may be too strict, since private methods may intentionally leave an
 object in an inconsistent state.
 
\layout Itemize

Public methods (or any other access modifier).
 This may be not strict enough.
\layout Itemize

Tagged methods.
 A special tag in the documentation comment declares, that a method promises
 to leave the system in a consistent state.
 This tag is then part of the interface contract.
 This is the best solution, but requires additional effort spent by the
 developer.
\layout Itemize

Explicit request.
 This is the way of choice, if the model is held in a database backend.
 Then the checking of invariants is simply done immediately before committing.
\layout Standard

These strategies may used in conjunction.
 Except of 
\emph on 
All Methods
\emph toggle 
 together with 
\emph on 
Public Methods
\emph toggle 
 and/or 
\emph on 
Tagged Methods
\emph toggle 
 all other combinations make sense for special user requirements.
\layout Standard

The current implementation does not yet provide tagged methods.
 TODO.
\layout Section

Caching Results of Invariants
\begin_inset LatexCommand \label{Sec:structuralScope}

\end_inset 


\layout Standard

The previous section discussed, when we have to make sure, that all invariants
 are fulfilled.
 But even then it's not absolutely necessary to evaluate all invariants.
 The implementation developed along with this paper checks only those invariants
, whose result may possibly have changed by recent changes of the model.
\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 244
file observingInvariants.eps
width 4 100
flags 15

\end_inset 


\layout Caption

Model for Observing Invariants
\end_float 
 
\layout Chapter

Reverse Engineering
\begin_inset LatexCommand \label{Sec:ReverseEngineering}

\end_inset 


\layout Standard

Section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

 explained, how to store additional type information of a java model in
 java documentation tags.
 This section discusses, how to generate this information.
\layout Standard

An interactive tool for injecting 
\family typewriter 
@element-type
\family default 
 and 
\family typewriter 
@key-type
\family default 
 tags into the code using information obtained from the source code or dynamical
ly on run time.
\layout Section

Static Information
\layout Standard

Information about element types may be derived from static properties of
 the class, such as parameter types of methods and tags in doccomments.
 The following example suggests some of these properties.
 
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
All employees of this company.
\newline 

\protected_separator 
 
\protected_separator 
@see 
\bar under 
Person
\bar default 

\newline 
*/
\newline 
Collection employees;
\newline 

\protected_separator 

\newline 
boolean isEmployee(
\bar under 
Person
\bar default 
);
\newline 
void addEmployee(
\bar under 
Person
\bar default 
);
\newline 
void removeEmployee(
\bar under 
Person
\bar default 
);
\layout Standard

An interactive tool should support the developer by presenting these properties
 in a comfortable way.
 There should be a special indication, if several properties suggest different
 element types.
\layout Standard

Note, that the example above requires linguistic knowledge about plural
 and singular form of nouns (employee here).
 This gets far more difficult, if identifiers are not English.
\layout Section

Tracing Dynamic Type Information
\layout Itemize

Enrich the code with tracing the object types inside collections.
\layout Itemize

compile and run the program (regression tests if available)
\layout Chapter

Maintaining the OCL Compiler
\layout Standard

This chapter describes all major changes to Frank Fingers OCL compiler.
 This includes bugfixes too, if they caused changes of internal or external
 interfaces.
\layout Section

Using reflection in ReflectionFacade and ocl library
\layout Enumerate

Added polymorphism of operation parameters (ReflectionFacade.\SpecialChar \-
navigateParameterize
d and OclAnyImpl.getFeature).
 This made ReflectionAdapter.getClassForType superfluous, so removed.
\layout Enumerate

Now its mandatory to provide a NameAdapter to the ocl library.
 Otherwise NullPointerExceptions are thrown.
 The default functionality if no NameAdapter is given has been moved into
 a separate NameAdapter (SimpleNameAdapter) which is used in ReflectionFacade
 as well.
 
\layout Enumerate

Added a simplified form of qualified associations to ReflectionFacade and
 ocl library.
 Simplification means, that there may be only one qualifier attribute.
 Qualified associations are represented by java.util.Map.
 ReflectionAdapter.isMap.
\layout Enumerate

New mapping beetween collections in OCL and Java conforming to JDK1.2.
 The special handling of Vector is used for older code generators.
 (DefaultOclFactory.getOclRepresentationFor(Object) and DefaultReflectionAdapter.g
etClassForType)
\begin_deeper 
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 3 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
0 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Java (java.util)
\newline 
Ocl.TAKE_VECTORS_AS_SET
\newline 
OCL
\newline 
List
\newline 
-
\newline 
Sequence
\newline 
Vector
\newline 
false
\newline 
Sequence
\newline 

\newline 
true
\newline 
Set
\newline 
Set
\newline 
-
\newline 
Set
\newline 
Map
\newline 
-
\newline 
Set (qualified)
\end_deeper 
\layout Section

ocl lib
\layout Enumerate

removed 
\family typewriter 
Ocl.STRICT_CHECKING
\family default 
, replaced exceptions by undefined values, parameterized with the reason
 for the undefined value.
\layout Enumerate

Ocl.Collection.setToRange makes an undefined collection (instead of throwing
 an exception), if lower bound is greater than upper bound.
\layout Enumerate

Ocl.to<OclType>(OclRoot) methods check for undefined arguments.
\layout Section

Typechecker
\layout Enumerate

added OclAny to TypeChecker (DefaultTypeFactory).
 
\layout Enumerate

Bugfix, removed TypeFactory.getClassifier - replaced all calls by TypeFactory.get
\layout Section

JavaCodeGenerator: 
\begin_inset LatexCommand \label{Sec:maintainJavaCodeGenerator}

\end_inset 


\layout Enumerate

different meaning of Codefragments created for @pre expressions (TRANSFER,
 PREPARATION, CODE), makes it easier and more flexible for different code
 injector tools.
 compare to 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 7.1.2, description of new behavior in section 
\begin_inset LatexCommand \ref{Sec:codegeneration_result}

\end_inset 

, TODO comparison to Franks example
\layout Enumerate

explicit package qualifier for ocl library is optionally prepended.
 Replaces the import statement and therefore fulfills the corresponding
 requirement in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements}

\end_inset 

.
\layout Section

Silly Bugfixes
\layout Enumerate

JavaCodeGenerator: order on arrow
\layout Enumerate

Basic.navigate: max[1]
\layout Enumerate

DefaultOclFactory.getOclRepresentationFor(Object): dealing with Float and
 Double
\layout Enumerate

OclCollection.setToRange: exchanged bounds in error condition
\layout Chapter
\start_of_appendix 
Injector Tutorial
\layout Standard

This chapter describes, how to use the injector tool.
\layout Standard


\begin_inset LatexCommand \listoffigures

\end_inset 


\layout Bibliography
\bibitem [FF00]{ff3}

Frank Finger.
 Design and Implementation of a Modular OCL Compiler.
 Diplomarbeit.
 TU-Dresden 2000.
 http://www-st.inf.tu-dresden.de/ocl/
\layout Bibliography
\bibitem [WK99]{Warmer}

Jos Warmer, Anneke Kleppe.
 The Object Constraint Language: Precise Modeling with UML.
 Addison-Wesley, 1999.
\layout Bibliography
\bibitem [UML]{UML}

OMG Unified Modeling Language Specification, Version 1.3, June 1999.
\layout Bibliography
\bibitem [OCL]{OCL}

Object Constraint Language Specification.
 Chapter 7 in 
\begin_inset LatexCommand \cite{UML}

\end_inset 

.
\layout Bibliography
\bibitem [JAVA]{JAVA}

James Gosling, Bill Joy, Guy Steele.
 The Java Language Specification.
 Edition 1.0.
 August 1996.
\the_end
