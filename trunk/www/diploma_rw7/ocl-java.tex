%% This LaTeX-file was created by <rw7> Sun Jun 18 12:26:52 2000
%% LyX 0.12 (C) 1995-1998 by Matthias Ettrich and the LyX Team

%% Do not edit this file unless you know what you are doing.
\documentclass[english]{report}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{babel}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\newcommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\spacefactor1000}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxcode}
  {\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \ttfamily}%
   \item[]}
  {\end{list}}

\makeatother

\begin{document}


\title{Diploma Thesis:\\
Utility Support for Checking OCL Business Rules in Java Programs}


\author{Ralf Wiebicke}


\date{May 2000}

\maketitle

\section*{Copyright}

Copyright \copyright~2000 Ralf Wiebicke.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later version
published by the Free Software Foundation; with no Invariant Sections, no Front-Cover
Texts, and no Back-Cover Texts. A copy of the license is available at http://www.gnu.org/copyleft/fdl.html.


\section*{Availability}

This document is available at http://www.inf.tu-dresden.de/\~{}rw7/diplom00/
in several electronic forms including PostScript, PDF, Html and the original
kLyx version.


\chapter{Introduction}


\section{OCL and Extreme Programming}


\chapter{Code Generation}


\section{Representation Of Associations}


\subsection{Possibilities}

\begin{itemize}
\item Collections named by the role name (maps for qualified associations)
\item Methods (isEmployed)
\end{itemize}

\subsection{CASE-Tools}


\subsection{Net-Linx}

Anpassbarkeit an vorhandenen Quellcode.


\section{Model Information}

Needed for Type Checking.

5.3.3

There is already the Reflection Facade, which is pretty cool with two exception: 

\begin{enumerate}
\item no element types of associations. 
\item no isquery tag
\end{enumerate}
Solution: extend the java language. The new tag has a syntax like @see, but
restricted to classes only.

\begin{lyxcode}
class~Company\\
\{\\
~~/{*}{*}\\
~~~~~All~persons~currently~employed~\\
~~~~~by~this~company.\\
~~~~~~~@element-type~Person\\
~~{*}/\\
~~Collection~employees;\\
\}
\end{lyxcode}
Cool implementation: an extension of the reflection api and the java compiler.

My implementation: A skript scanning the source code for these comments, and
an extension of the reflection facade to use this information. (royloy.Person\#employees=Person)


\paragraph{Where comes the tag?}

\begin{itemize}
\item CASE-Tools
\item handmade: good-practice of programming. Should be there already in the comments,
the tag makes it available formally.
\item reverse enginieering. see chapter {[}reverse enginieering{]}
\end{itemize}
Will be tested automatically by the injected code.

Is a good help for further reengineering from Java to UML (Diplomarbeit Stefan
Frisch?)


\chapter{Code Injection}


\section{Major Decisions}

\begin{itemize}
\item Reversable Transformation: 

\begin{itemize}
\item Must be possible to clean the code from all injected fragments.
\item Must be possible to edit the transformed source code without losing all changes
at the next injection.
\item Major reasons: 

\begin{itemize}
\item the error messages pointing to the source code.
\item injection must be done only when the contraints heve been changed, not if the
java source has been changed.
\end{itemize}
\end{itemize}
\item Method Wrapper
\item no import statements, explicit package qualifying in the generated code instead.
\item checking the @element-type
\item may be: Auslagerung von möglichst viel code auf eine Extraklasse pro Klasse
oder pro Package. Entlastung des CVS. Das hat niedrige Priorität.
\end{itemize}

\section{Wrapping Methods}

Touching the code of each method is needed, because the generated code must
be run on each call to the method.

Using wrapper methods avoids many problems which arise if there are several
return statements in a method or a complex expression in the return statement.
Also, there are no name conflicts anymore beetween the original and the generated
code.


\paragraph{Example.}

This is, how it works: A method

\begin{lyxcode}
int~someMethod(double~x)\\
\{\\
~~//~here~comes~the~code.\\
\}~
\end{lyxcode}
is transformed into two methods:

\begin{lyxcode}
int~someMethod\_wrappedbyocl(double~x)\\
\{\\
~~//~here~comes~the~code.\\
\}\\
~\\
/{*}{*}\\
~~~@author~ocl~injector

{*}/\\
int~someMethod(double~x)\\
\{\\
~~//~some~code~checking~invariants/preconditions.\\
~~int~result=someMethod\_wrappedbyocl(x);\\
~~//~some~code~checking~postconditions/invariants.\\
~~return~result;\\
\}
\end{lyxcode}
Slightly different and a bit tricky for constructors:

\begin{lyxcode}
SomeClass(String~x)\\
\{\\
~~//~here~comes~the~code\\
\}
\end{lyxcode}
gets to

\begin{lyxcode}
SomeClass(String~x,~Void~void)\\
\{\\
~~//~here~comes~the~code\\
\}\\
~\\
SomeClass(String~x)\\
\{\\
~~this(x,~new~Void());\\
~~//~some~code~checking~postconditions/invariants.\\
\}
\end{lyxcode}

\chapter{Reverse Engineering}

Avoid the UML model for type checking.

An interactive tool for injecting \texttt{@element-type} tags into the code
using information obtained staticly from the source code or dynamicly on run
time.


\section{Static}

Given \texttt{Collection~employees} look for \texttt{void~addEmployee(Person)}
or \texttt{boolean~isEmployee(Person)}. 

Or look for a \texttt{@see} tag in the corresponding doc comment.


\section{Dynamic}

\begin{itemize}
\item Enriche the code with tracing the object types inside collections.
\item compile and run the program (regression tests if available)
\end{itemize}
\begin{thebibliography}{UML}
\bibitem[FF]{ff3}Frank Finger. Design and Implementation of a Modular OCL Compiler. Diplomarbeit.
TU-Dresden 2000. http://www-st.inf.tu-dresden.de/ocl/
\bibitem[UML]{UML}OMG Unified Modeling Language Specification, Version 1.3, June 1999.
\bibitem[OCL]{OCL}Object Constraint Language Specification. Chapter 7 in \cite{UML}.
\end{thebibliography}
\end{document}
