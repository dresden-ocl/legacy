package tudresden.ocl20.util;import java.io.PrintWriter;import java.io.PushbackReader;import java.io.StringReader;import java.io.StringWriter;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import java.util.List;import java.util.Vector;import javax.jmi.reflect.JmiException;import javax.jmi.reflect.RefObject;import tudresden.ocl20.core.MetaModelConst;import tudresden.ocl20.core.OclModel;import tudresden.ocl20.core.OclModelException;import tudresden.ocl20.core.jmi.ocl.commonmodel.Classifier;import tudresden.ocl20.core.jmi.ocl.commonmodel.Constraint;import tudresden.ocl20.core.jmi.ocl.expressions.ExpressionInOcl;import tudresden.ocl20.core.jmi.uml15.uml15.Uml15Package;import tudresden.ocl20.core.parser.astgen.Heritage;import tudresden.ocl20.core.parser.astgen.LAttrAstGenerator;import tudresden.ocl20.core.parser.sablecc.analysis.AttrEvalException;import tudresden.ocl20.core.parser.sablecc.lexer.Lexer;import tudresden.ocl20.core.parser.sablecc.node.Start;import tudresden.ocl20.core.parser.sablecc.node.Token;import tudresden.ocl20.core.parser.sablecc.parser.Parser;import tudresden.ocl20.core.parser.util.SimpleMessageSink;/** * Provides some helper and example methods for using the toolkit * * @author Jordi Cabot Sagrera  * @version 1.00  * * */public class Utility implements SimpleMessageSink {	// implementing SimpleMessageSink (required for log output / error messages)	public void processMessage(String message) {		System.out.println("logger: " + message);	}	/** Loads a UML model from a XMI file */	public OclModel loadUMLModel(String url)	{		OclModel newModel = null;		String metaModelName = MetaModelConst.UML15;		try {			newModel = new OclModel(metaModelName, url);		} catch (OclModelException ex) {			System.out.println("Error loading OCL model. " + ex.getMessage()					+ ", check system error stream for details.");			ex.printStackTrace(System.err);		}		return newModel;	}	/** Loads a UML/OCL model */	public OclModel loadUMLModel(String urlModel, String urlOCL)	{		OclModel newModel = loadUMLModel(urlModel);		Start cst = null;		String text = ""; // text will contain the OCL constraints		try {			java.io.BufferedReader br = new java.io.BufferedReader(			new java.io.InputStreamReader(new java.io.FileInputStream(urlOCL)));			String line = br.readLine();			while (line != null) {				text = text + line + "\n";				line = br.readLine();			}			br.close();		} catch (java.io.IOException ex) {			System.out.println("Error reading file " + urlOCL					+ "! Check system error stream for details.");			ex.printStackTrace(System.err);		}		// Parsing the constraints		try {			// create lexer			Lexer lexer = new Lexer(new PushbackReader(new StringReader(text)));			// parser program			Parser parser = new Parser(lexer);			cst = parser.parse();		} catch (Exception e) {			System.out.println("Cannot parse OCL constraint: "					+ e.getLocalizedMessage());			e.printStackTrace();		}		// Running the attribute Evaluator. Transformt the cst into an abstract		// syntax tree		LAttrAstGenerator astgen = null;		try {			astgen = new LAttrAstGenerator(newModel);			astgen.setMessageSink(this);			Heritage hrtg = new Heritage();			newModel.beginTrans(true);			cst.apply(astgen, hrtg);			newModel.endTrans(false);			processMessage("Attribute evaluation completed successfully.");		} catch (AttrEvalException evex) {			newModel.endTrans(true);			String message = evex.getMessage();			String position = null;			Token tk = astgen.getCurrentToken();			if (tk != null) {				position = "" + tk.getLine() + ":" + tk.getPos();			} else {				position = "<unknown>";			}			processMessage("===[ Contextual Analysis Error at " + position					+ "]===");			processMessage(message);			StringWriter swriter = new StringWriter(1024);			PrintWriter pwriter = new PrintWriter(swriter);			evex.printStackTrace(pwriter);			pwriter.flush();			swriter.flush();			processMessage(swriter.toString());			Throwable cause = evex.getCause();			if (cause != null) {				processMessage("Cause: " + cause.getMessage());				swriter = new StringWriter(1024);				pwriter = new PrintWriter(swriter);				cause.printStackTrace(pwriter);				pwriter.flush();				swriter.flush();				processMessage(swriter.toString());			}			processMessage("=======");		} catch (JmiException jmix) {			newModel.endTrans(true);			String message = jmix.getMessage();			String position = null;			Token tk = astgen.getCurrentToken();			if (tk != null) {				position = "" + tk.getLine() + ":" + tk.getPos();			} else {				position = "<unknown>";			}			processMessage("===[ JMI Exception during contextual analysis at "					+ position + "]===");			RefObject elInErr = jmix.getElementInError();			Object objInErr = jmix.getObjectInError();			if (objInErr != null) {				processMessage("Object in error (class name): "						+ objInErr.getClass().getName());				processMessage("Object in error (toString): " + objInErr);			}			if (elInErr != null) {				processMessage("Element in error (clas name): "						+ elInErr.getClass().getName());				processMessage("Element in error (MOF Id): "						+ elInErr.refMofId());				processMessage("Element in error (toString) " + elInErr);			}			processMessage("=== Exception message and stack trace follows ===");			processMessage(message);			StringWriter swriter = new StringWriter(1024);			PrintWriter pwriter = new PrintWriter(swriter);			jmix.printStackTrace(pwriter);			pwriter.flush();			swriter.flush();			processMessage(swriter.toString());		} catch (Exception e) {			newModel.endTrans(true); // rollback			System.out.println("Error running attribute evaluator. "					+ e.getMessage());			e.printStackTrace();		}		;		return newModel;	}	/** Saves an UML/OCL model */	public void saveModel(OclModel model, String url)	{		try {			model.save(url);		} catch (OclModelException ex) {			processMessage("Error saving OCL model. " + ex.getMessage());			ex.printStackTrace(System.err);		}	}	public Collection getConstraintsClassifier(OclModel model, String name)	{		List pathName = new ArrayList();		pathName.add(name);		Classifier cl = (tudresden.ocl20.core.jmi.uml15.core.Classifier) model				.getTopPackage().findClassifier(pathName);		Collection exps = cl.getExpressionInOclA();		// ATTN: these are *not* constraints, but only OCL expressions (there's		// a subtle difference)		// there may be more OCL expressions attached to a classifier than		// constraints (e. g. for		// initial value constraints etc.)		Vector constraints = new Vector();		Iterator it = exps.iterator();		while (it.hasNext()) {			ExpressionInOcl exp = (ExpressionInOcl) it.next();			Constraint cons = exp.getConstraintA();			if (cons != null)				constraints.add(cons);		}		return constraints;	}		/**	 * Find all Constraints a model has	 * @param model the model (UML15)	 * @return all constraints	 */	public Collection getAllConstraintsModel(OclModel model)	{		Uml15Package uml15pkg = (Uml15Package) model.getModel();		// uses UML15-specific model: (does work): Using constraint class proxy		// instance		tudresden.ocl20.core.jmi.uml15.core.ConstraintClass consclz = uml15pkg				.getCore().getConstraint();		Collection consAll = consclz.refAllOfType();		return consAll;	}		/**	 * Adds a Constraint to the Model by a given URL, parses it and creates the AST	 * @param model the model	 * @param urlOCL URL of the constraint	 * @return the model 	 */	public OclModel addConstraintsToUMLModel(OclModel model, String urlOCL)	{		OclModel newModel = model;		Start cst = null;		String text = ""; // text will contain the OCL constraints		try {			java.io.BufferedReader br = new java.io.BufferedReader(			new java.io.InputStreamReader(new java.io.FileInputStream(urlOCL)));			String line = br.readLine();			while (line != null) {				text = text + line + "\n";				line = br.readLine();			}			br.close();		} catch (java.io.IOException ex) {			System.out.println("Error reading file " + urlOCL					+ "! Check system error stream for details.");			ex.printStackTrace(System.err);		}		// Parsing the constraints		try {			// create lexer			Lexer lexer = new Lexer(new PushbackReader(new StringReader(text)));			// parser program			Parser parser = new Parser(lexer);			cst = parser.parse();		} catch (Exception e) {			System.out.println("Cannot parse OCL constraint: "					+ e.getLocalizedMessage());			e.printStackTrace();		}		// Running the attribute Evaluator. Transformt the cst into an abstract		// syntax tree		LAttrAstGenerator astgen = null;		try {			astgen = new LAttrAstGenerator(newModel);			astgen.setMessageSink(this);			Heritage hrtg = new Heritage();			newModel.beginTrans(true);			cst.apply(astgen, hrtg);			newModel.endTrans(false);			processMessage("Attribute evaluation completed successfully.");		} catch (AttrEvalException evex) {			newModel.endTrans(true);			String message = evex.getMessage();			String position = null;			Token tk = astgen.getCurrentToken();			if (tk != null) {				position = "" + tk.getLine() + ":" + tk.getPos();			} else {				position = "<unknown>";			}			processMessage("===[ Contextual Analysis Error at " + position					+ "]===");			processMessage(message);			StringWriter swriter = new StringWriter(1024);			PrintWriter pwriter = new PrintWriter(swriter);			evex.printStackTrace(pwriter);			pwriter.flush();			swriter.flush();			processMessage(swriter.toString());			Throwable cause = evex.getCause();			if (cause != null) {				processMessage("Cause: " + cause.getMessage());				swriter = new StringWriter(1024);				pwriter = new PrintWriter(swriter);				cause.printStackTrace(pwriter);				pwriter.flush();				swriter.flush();				processMessage(swriter.toString());			}			processMessage("=======");		} catch (JmiException jmix) {			newModel.endTrans(true);			String message = jmix.getMessage();			String position = null;			Token tk = astgen.getCurrentToken();			if (tk != null) {				position = "" + tk.getLine() + ":" + tk.getPos();			} else {				position = "<unknown>";			}			processMessage("===[ JMI Exception during contextual analysis at "					+ position + "]===");			RefObject elInErr = jmix.getElementInError();			Object objInErr = jmix.getObjectInError();			if (objInErr != null) {				processMessage("Object in error (class name): "						+ objInErr.getClass().getName());				processMessage("Object in error (toString): " + objInErr);			}			if (elInErr != null) {				processMessage("Element in error (clas name): "						+ elInErr.getClass().getName());				processMessage("Element in error (MOF Id): "						+ elInErr.refMofId());				processMessage("Element in error (toString) " + elInErr);			}			processMessage("=== Exception message and stack trace follows ===");			processMessage(message);			StringWriter swriter = new StringWriter(1024);			PrintWriter pwriter = new PrintWriter(swriter);			jmix.printStackTrace(pwriter);			pwriter.flush();			swriter.flush();			processMessage(swriter.toString());		} catch (Exception e) {			newModel.endTrans(true); // rollback			System.out.println("Error running attribute evaluator. "					+ e.getMessage());			e.printStackTrace();		}		;		return newModel;	}	/**	 * Returns all (UML-)classes of a model	 * @param m the model	 * @return Collection of classes	 */	public Collection getAllClassesModel(OclModel m)	{		// uses UML15-specific model		Uml15Package uml15pkg = (Uml15Package) m.getModel();		return uml15pkg.getCore().getUmlClass().refAllOfClass();	}}