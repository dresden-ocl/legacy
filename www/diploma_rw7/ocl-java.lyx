#This file was created by <wiera> Wed Oct  4 18:27:10 2000
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass report
\begin_preamble
\usepackage{textcomp}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Diploma Thesis:
\newline 
Utility Support for Checking OCL Business Rules in Java Programs
\layout Author

Ralf Wiebicke
\layout Date

May 2000
\layout Section*

Copyright
\layout Standard

Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke.
\layout Standard

Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.1 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is available at http://www.gnu.org/copyleft/fdl.html.
\layout Standard

The source code developed together with this paper is Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke and published under the GNU Lesser General Public License.
\layout Section*

Availability
\layout Standard

This document is available at http://dresden-ocl.sourceforge.net/diploma_rw7/
 in several electronic forms including 
\latex latex 

\backslash 
LaTeX{}
\latex default 
, Postscript, PDF, Html and the original kLyx version.
 
\layout Standard

The source code developed together with this paper is available at http://dresde
n-ocl.sourceforge.net/.
\layout Section*

Neu
\layout Enumerate

Section 
\begin_inset LatexCommand \ref{Sec:WrapperLoop}

\end_inset 

.
 Avoiding the Wrapper Loop
\layout Enumerate

Chapter 2 
\begin_inset Quotes eld
\end_inset 

Related Work
\begin_inset Quotes erd
\end_inset 


\layout Standard


\begin_inset LatexCommand \tableofcontents

\end_inset 


\layout Chapter

Introduction
\layout Standard

Wishlist in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 3.6.
\layout Chapter

Related Work
\layout Standard

Simpler approach in 
\begin_inset LatexCommand \cite{kbeans}

\end_inset 

, easier to write, less complex, but less flexible.
\layout Section

Reverse Engineering
\layout Standard

A powerful approach to reverse engineering has been developed at the MIT
 
\begin_inset LatexCommand \cite{womble}

\end_inset 

.
 The tool superwomble extracts an object model from java byte code.
 Object models are roughly a subset of UML class diagrams, featuring inheritance
 and object associations.
 The main challenge for the analysis is the detection of element types of
 container attributes.
 The tool performes this very efficiently, without requiring any additional
 help from the user.
 Thus, it complements the two approaches presented in chapter 
\begin_inset LatexCommand \ref{Sec:ReverseEngineering}

\end_inset 

.
\layout Chapter

Code Injection
\layout Standard

Injection of generated code into java programs is the main subject of this
 paper.
 It covers anything beyond code generation, to get a java model checking
 its own constraints.
 For an idea, where code generation ends and injection starts, see section
 
\begin_inset LatexCommand \ref{Sec:codegeneration_result}

\end_inset 

.
 
\layout Standard

This is followed by an analysis of requirements for the code injection and
 resulting design decisions in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements}

\end_inset 

.
 Sections 
\begin_inset LatexCommand \ref{Sec:wrappingMethods}

\end_inset 

 and 
\begin_inset LatexCommand \ref{Sec:cleaningCode}

\end_inset 

 describe the solution in detail.
\layout Standard

Finally sections 
\begin_inset LatexCommand \ref{Sec:temporalScope}

\end_inset 

 and 
\begin_inset LatexCommand \ref{Sec:structuralScope}

\end_inset 

 discuss the more fundamental issue, when and how often invariants have
 to be checked.
\layout Section

Results of Code Generation
\begin_inset LatexCommand \label{Sec:codegeneration_result}

\end_inset 


\layout Standard

The java code generator developed in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 produces a set of code fragments
\begin_float footnote 
\layout Standard

see class 
\family typewriter 
tudresden.ocl.codegen.CodeFragment.
\end_float 
.
 These code fragment have the following properties:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 2 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
2 1 0 "" ""
2 1 1 "70mm" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Property 
\newline 

\newline 
Constrained
\protected_separator 
type 
\newline 
The default navigation context of this constraint.
\newline 
Kind 
\newline 
Specifies, whether this constraint is an invariant, a pre- or a postcondition.
 
\newline 
Constrained
\protected_separator 
operation 
\newline 
The operation, this constraint applies to (valid for pre- and postconditions
 only).
\newline 
Code 
\newline 
Contains the actual java code to be executed.
\newline 
Result
\protected_separator 
variable 
\newline 
Specifies the boolean value, which contains the result of the ocl expression
 after code execution.
\layout Standard

For each postcondition containing a @pre expression there are two additional
 codefragments called preparation and transfer.
 See below.
\layout Subsection

Preparation and Transfer Fragments
\layout Standard

The meaning of preparation and transfer fragments is explained on a dramatically
 simplified example.
 
\layout Standard

Suppose a post condition for operation 
\family typewriter 
employ()
\family default 
, that leaves the attribute 
\family typewriter 
age
\family default 
 unchanged:
\layout LyX-Code

context Person::employ() 
\newline 
post: age=age@pre
\layout Standard

the following codefragments will be produced:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 2 0 0 -1 -1 -1 -1
1 1 0 0
1 0 0 0
1 1 0 0
0 0 0 0
0 1 0 0
2 0 0 "" ""
2 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Kind
\newline 
 Code
\newline 
Transfer
\newline 

\family typewriter 
int node1;
\family default 
 
\newline 
Preparation
\newline 

\family typewriter 
node1=this.age;
\family default 

\newline 
Post Condition
\newline 

\family typewriter 
int node2=this.age;
\family default 

\newline 

\newline 

\family typewriter 
boolean result=(node1==node2)
\layout Standard

Typically these fragments would be injected as follows:
\layout LyX-Code

class Person
\newline 
{
\newline 

\protected_separator 
 void employ()
\newline 

\protected_separator 

\protected_separator 
{
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
int node1;
\family default 
 
\protected_separator 
 
\protected_separator 
 
\protected_separator 
 // transfer fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
node1=this.age;
\family default 
 
\protected_separator 
// preparation fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// original code of employ()
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// post condition fragment
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
node
\family default 
2
\family typewriter 
=this.age;
\family default 

\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\family typewriter 
boolean result=(node1==node2)
\family default 

\newline 

\protected_separator 

\protected_separator 
}
\newline 
}
\layout Standard

Note, that precise semantics of codefragments involving the @pre expression
 has been changed, so that the original meaning described in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 7.1.2 is no longer fully correct.
 For a detailed comparison see section 
\begin_inset LatexCommand \ref{Sec:maintainJavaCodeGenerator}

\end_inset 

.
\layout LyX-Code


\protected_separator 

\layout Section

Requirements and Design Decisions
\begin_inset LatexCommand \label{Sec:injection_requirements}

\end_inset 


\layout Standard

This section analyzes the requirements for the injector tool and derives
 some fundamental design decisions.
\layout Subsection

Reversable Modification
\begin_inset LatexCommand \label{Sec:injection_requirements_reversable}

\end_inset 


\layout Standard

The most important feature is the reversability of code injection.
 It must be possible to
\layout Itemize

Clean the code tracelessly from all injected fragments.
\layout Itemize

Redo the injection on source code that has already been modified, for instance
 when constraints have been changed.
 
\layout Itemize

Edit the modified source code without losing all changes at the next injection.
 
\layout Standard

These requirements makes things quite a bit more difficult, but there are
 serious reasons for this.
 Otherwise there would be two versions of source code: the original and
 the modified version.
 This raises some unpleasant problems:
\layout Enumerate

Configuration management must handle two source code trees.
\layout Enumerate

Developers must be careful to edit the original version only.
\layout Enumerate

Running the ocl injector is required after every change of the java source
 code, not only when the constraints have been changed.
 
\layout Enumerate

Stack traces of runtime exceptions point to the modified source code.
 Developers must look for the corresponding place in the original version.
\layout Standard

The implementation of reversable modification requires a strategy of minimally
 invasive modification.
 This is realized by two design decisions:
\layout Enumerate

Method wrappers, explained detailed in section 
\begin_inset LatexCommand \ref{Sec:wrappingMethods}

\end_inset 

.
\layout Enumerate

Explicit package qualifiers for the ocl library in the generated code.
 Otherwise, an import statement for the ocl library would be necessary.
 This would be just another spot, were the original source code had to be
 touched.
 Additionally, this may introduce name conflicts beetween ocl library and
 user code.
\layout Subsection

Embedding Constraints in Java Source Code.
\begin_inset LatexCommand \label{Sec:embedConstraints}

\end_inset 


\layout Standard

It should be possible to embed constraints in the java documentation comments.
 The placement of embedded constraints implicates (and replaces) the context
 of the constraint.
 See the example below.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@invariant ageGreaterZero: age>0
\newline 
*/
\newline 
class Person
\newline 
{
\newline 

\protected_separator 

\protected_separator 
int age;
\newline 

\protected_separator 

\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@postcondition: age=age@pre
\newline 

\protected_separator 

\protected_separator 
*/
\newline 
 
\protected_separator 
void employ();
\newline 
}
\layout Standard

It is necessary to put the constraints directly under the nose of the developer.
 The author is strongly convinced, that constraints stored in an extra text
 file are too far away from attention.
\layout Standard

Invariants may also placed on an attribute or method of their context class.
 This is for convinience, since most invariants are clearly related to one
 specific attribute or method.
\layout Subsection

Checking the Element Type.
\layout Standard

The injected code must check, that collection attributes comply to the 
\family typewriter 
@element-type
\family default 
 and 
\family typewriter 
@key-type
\family default 
 tags introduced in section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

.
 This is quite easily done just before checking invariants.
\layout Standard

Note, that this feature may be be used standalone, without ocl expressions
 at all.
 Then it provides a runtime check for typed collections.
\layout Section

Code Insertion
\begin_inset LatexCommand \label{Sec:wrappingMethods}

\end_inset 


\layout Standard

The main task of code injection is to have some code executed immediately
 before and after all methods (and after all constructors too).
 This section describes, how this is done by the ocl injector.
\layout Subsection

A Simple Approach
\layout Standard

A straight-forward solution would add the code directly into the method.
 But this raises some severe problems.
 
\layout Enumerate

The code to be executed after the method (postcondition and invariants)
 has to be inserted before any return statement.
\layout Enumerate

The post condition code must have the return value available.
 Thus, a return expression has to be computed in advance, if the post condition
 code refers to the return value and/or the the return expression produces
 side effects.
\layout Enumerate

There may be name conflicts beetween the original and the generated code,
 since the generated code defines local variables.
\layout Enumerate

For methods with return type void it must be decided, whether the post condition
 code has to be inserted at the end of the method.
 This depends on whether the end of the method is a reachable point of code.
 For the decision it needs a complete control flow analysis of the method.
 Note, that if the post condition code is wrongly inserted at the end of
 the method, the java compiler will fail due to unreachable statements.
\layout Standard

An implementation would need a complete java parser, which touches the original
 code at many different places and in a complicated way.
 This runs contrary to the strategy of minimally invasive modification as
 decided in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements_reversable}

\end_inset 

.
 
\layout Standard

Additionally, item 4 requires much of the semantic analysis performed by
 a java compiler.
 This makes the simple approach very hard to implement.
\layout Standard

Method wrappers solve all these problems in a nifty but simple way.
\layout Subsection

Wrapping Methods
\begin_inset LatexCommand \label{Sec:wrappingMethodsSub}

\end_inset 


\layout Standard

Some code tells more than thousand words, so I use an example to explain.
 Consider the following method.
\layout LyX-Code

int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
} 
\layout Standard

The code injector transforms this into two methods.
\layout LyX-Code

int someMethod_wrappedbyocl
\begin_float footnote 
\layout Standard

This is not yet the full truth, see section 
\begin_inset LatexCommand \ref{Sec:WrapperLoop}

\end_inset 

.
\end_float 
(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
}
\newline 

\protected_separator 

\newline 
int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/preconditions.
\newline 

\protected_separator 

\protected_separator 
int result=someMethod_wrappedbyocl(x);
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/postconditions.
\newline 

\protected_separator 

\protected_separator 
return result;
\newline 
}
\layout Standard

Now let's have a look back at the problems encountered for the simple approach.
 Non of them exists anymore.
 
\layout Itemize

The code to be executed after the method has to be inserted once only.
\layout Itemize

When the post condition code is executed, the return expression is already
 evaluated and ready to use.
\layout Itemize

No name conflicts are possible, since user code and generated code are strictly
 separated into different methods.
\layout Itemize

No control flow analysis is needed.
\layout Standard

The user code is modified in a simple way: a suffix is appended to the method
 name.
 For an implementation a very inchoate java parser is sufficient, which
 understands 
\begin_inset Quotes eld
\end_inset 

java meta level
\begin_inset Quotes erd
\end_inset 

 only.
 The meta level covers anything outside of method bodies and attribute initializ
ers.
 This is a very small part of the java language and easily to be analyzed
 by a hand-crafted parser.
\layout Standard

This kind of method wrapping still has a problem, I called the wrapper loop.
 See section 
\begin_inset LatexCommand \ref{Sec:WrapperLoop}

\end_inset 

 how this is solved.
\layout Subsection

Wrapping Constructors
\layout Standard

Another transformation is used for constructors, since they cannot be renamed.
 Suppose a example constructor
\layout LyX-Code

SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\layout Standard

Instead of renaming, the original constructor gets an additional dummy argument.
\layout LyX-Code

SomeClass(String x, Dummy
\begin_float footnote 
\layout Standard

Actually this is class 
\family typewriter 
tudresden.ocl.injection.lib.WrapperDummy
\family default 
.
\end_float 
 oclwrapperdummy)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\newline 

\protected_separator 

\newline 
SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
this(x, (Dummy)null);
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants.
\newline 
}
\layout Standard

A special case occurs if a class provides no explicit constructor.
 Then there is the default constructor as specified in 
\begin_inset LatexCommand \cite{JAVA}

\end_inset 

 section 8.6.7.
 This default constructor is not wrapped, but replaced by an explicit constructo
r with the same access modifier.
\layout Subsection

Avoiding the Wrapper Loop
\begin_inset LatexCommand \label{Sec:WrapperLoop}

\end_inset 


\layout Standard

Wrapping methods as described in section 
\begin_inset LatexCommand \ref{Sec:wrappingMethodsSub}

\end_inset 

 causes a problem for a special situation.
 This sections describes this situation and the solution provided by the
 ocl injector.
\layout Standard

The critical situation is shown in the figure below:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 121 141
file WrapperLoop1.eps
height 1 5
flags 13

\end_inset 


\layout Standard

The dotted arrow represents a method call: 
\family typewriter 
Sub.method()
\family default 
 contains a statement 
\family typewriter 
super.method();
\family default 
 somewhere.
\layout Standard

The ocl injector changes the structure as shown below:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 210 141
file WrapperLoop2.eps
height 1 5
flags 13

\end_inset 


\layout Standard

The arrows show the problem: there's an infinite loop of method calls.
 In detail the following happens:
\layout Enumerate

Method 
\family typewriter 
Sub.method()
\family default 
 is called somewhere in the user program.
 This is a wrapper method replacing the original method, which is named
 
\family typewriter 
method_wrappedbyocl()
\family default 
 now.
\layout Enumerate


\family typewriter 
Sub.method()
\family default 
 does some ocl specific things, before it executes the statement 
\family typewriter 
method_wrappedbyocl()
\family default 
.
 This calls the original method 
\family typewriter 
Sub.method_wrappedbyocl()
\family default 
 as it is supposed to be.
\layout Enumerate


\family typewriter 
Sub.method_wrappedbyocl()
\family default 
 contains the 
\family typewriter 
super.method();
\family default 
 statement, therefore calls 
\family typewriter 
Super.method()
\family default 
.
\layout Enumerate


\family typewriter 
Super.method()
\family default 
 is a wrapper method replacing the original method, which is called 
\family typewriter 
Super.method_wrappedbyocl()
\family default 
 now.
 It does some ocl specific thing, before it executes the statement 
\family typewriter 
method_wrappedbyocl()
\family default 
.
 But this statement does not call 
\family typewriter 
Super.method_wrappedbyocl()
\family default 
 as it is supposed to be, but 
\family typewriter 
Sub.method_wrappedbyocl()
\family default 
, which finally causes the infinite loop.
\layout Standard

The principal solution approach is simple: method 
\family typewriter 
Super.method()
\family default 
 should force 
\family typewriter 
Super.method_wrappedbyocl()
\family default 
 to be executed, although this method was overridden in class 
\family typewriter 
Sub
\family default 
.
 Java language does not provide a way, to call a method, which was overridden.
 Therefore we do a small trick:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 229 141
file WrapperLoop3.eps
height 1 5
flags 13

\end_inset 


\layout Standard

Wrapped methods get the class name appended.
 Thus, a wrapper method can call the wrapped method of it's own class.
\layout Section

Cleaning the Code
\begin_inset LatexCommand \label{Sec:cleaningCode}

\end_inset 


\layout Standard

Reversable modification means, that the injector is able clean the modified
 code without leaving any traces.
 This section explains, how this requirement is met.
 
\layout Standard

The user code is modified in two different ways only:
\layout Enumerate

Renaming the wrapped methods/constructors.
\layout Enumerate

Adding new object features, i.e.
 wrapper methods, methods for checking invariants and observing attributes.
\layout Standard

For each method to be wrapped the suffix 
\family typewriter 
_wrappedbyocl
\family default 
 is appended to the name.
 This transformation is done on the unparsed method header, so all typographical
 extras (line breaks, comments etc.) are preserved.
 This transformation is easily reversed, when the code has to be cleaned.
 For constructors, this works similarly with appending the dummy parameter
 to the parameter list.
\layout Standard

Removing generated class features relies on the fact, that the injector
 tags all generated features as shown below.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@author ocl_injector
\newline 
*/
\newline 
void checkOclInvariants();
\layout Standard

When cleaning the code, the injector simply removes all object features
 carrying such an 
\family typewriter 
@author
\family default 
 tag.
 This is quite simple and functional.
\layout Section

Scope of Invariants
\begin_inset LatexCommand \label{Sec:temporalScope}

\end_inset 


\layout Standard

This section discusses the issue, when an constraint is required to be fulfilled.
 This is trivially for pre/post conditions, but for invariants it's not
 so easy.
\layout Standard


\begin_inset LatexCommand \cite{Warmer}

\end_inset 

 section 5.4.2 suggests to check invariants immediately after an object has
 changed
\begin_float footnote 
\layout Standard

This is partially corrected in the errata 
\begin_inset LatexCommand \cite{WarmerErrata}

\end_inset 

.
\end_float 
.
 This is not workable, even if runtime efficiency is ignored.
 Modifications on the model often produce intermediate states, which are
 not consistent according to the constraints.
 
\layout Standard

When using databases the answer is simple: invariants must be valid outside
 of transactions.
 Since the java system does not provide transactions, the code injector
 offers several strategies for various user requirements.
\layout Standard

Invariants may be required to be fulfilled on:
\layout Itemize

All methods.
 This may be too strict, since private methods may intentionally leave an
 object in an inconsistent state.
 
\layout Itemize

Public methods (or any other access modifier).
 This may be not strict enough.
\layout Itemize

Tagged methods.
 A special tag in the documentation comment declares, that a method promises
 to leave the system in a consistent state.
 This tag is then part of the interface contract.
 This is the best solution, but requires additional effort spent by the
 developer.
\layout Itemize

Explicit request.
 This is the way of choice, if the model is held in a database backend.
 Then the checking of invariants is simply done immediately before committing.
\layout Standard

These strategies may be used in conjunction.
 Except of 
\emph on 
All Methods
\emph toggle 
 together with 
\emph on 
Public Methods
\emph toggle 
 and/or 
\emph on 
Tagged Methods
\emph toggle 
 all other combinations make sense for special user requirements.
\layout Standard

There won't be a single solution for this problem.
 Many applications will require their own individual scope of invariants.
 The scope may even differ beetween several classes of invariants.
 
\layout Standard

Current implementation supports scopes needed during the ongoing diploma
 thesis only.
 Up to now, all invariants share the same scope.
 Also, tagged methods are not yet supported.
\layout Section

Caching Results of Invariants
\begin_inset LatexCommand \label{Sec:structuralScope}

\end_inset 


\layout Standard

The previous section discussed, when we have to make sure, that all invariants
 are fulfilled.
 But even then it's not absolutely necessary to evaluate all invariants.
 The implementation developed along with this paper checks only those invariants
, whose result may possibly have changed by recent changes of the model.
\layout Subsection

Design
\layout Standard

Caching is realized with an observer design.
 Each invariant determines all object attributes it depends on and registers
 to these attributes as observer.
 Figure 
\begin_inset LatexCommand \ref{Abb:observingInvariants}

\end_inset 

 shows the meta model of the principal design.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 253
file observingInvariants.eps
width 4 100
flags 15

\end_inset 


\layout Caption

Design for Observing Invariants
\begin_inset LatexCommand \label{Abb:observingInvariants}

\end_inset 


\end_float 
 
\layout Standard

The classes in the UML chart have the following meaning:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 3 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
2 1 0 "" ""
2 1 0 "5cm" ""
2 1 1 "3cm" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 2 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Class
\newline 

\newline 
Example
\newline 
Class
\newline 
An arbitrary class of the user model
\newline 

\family typewriter 
class Person
\family default 

\newline 
Invariant
\newline 
An invariant in the context of a class
\newline 

\family typewriter 
context Person inv: age>=0
\family default 

\newline 
Object
\newline 
An instance of a class
\newline 
Person John
\newline 
InvariantInstance
\newline 
An invariant in the context of an object.
\newline 
Has John a positive age?
\newline 
Feature
\newline 
A feature (attribute or query method) of an object.
\newline 
John's age
\layout Standard

For now, lets think of features as attributes only.
 How to deal with query methods is explained below.
 
\layout Standard

The cycle of checking invariants contains two stages.
\layout Enumerate

Evaluating invariants.
 When evaluating an invariant instance, this invariant instance registers
 to all object attributes used during evaluation as observer.
 This means, the attribute promises to notify the invariant instance, when
 the attributes value changes.
\layout Enumerate

Running the model.
 When an attribute changed its value during execution of user code, it notifies
 all observing invariant instances.
 Then, the attribute unregisters all observers, so they must register again
 on the next evaluation stage.
\layout Standard

This design can be extended to query
\begin_float footnote 
\layout Standard

Operations used in ocl expressions must not have side effects.
\end_float 
 methods.
 If the query does not have parameters, it's exactly like attributes.
 Things get a bit more complex, if the queries are parameterized.
 See figure 
\begin_inset LatexCommand \ref{Abb:observingMethods}

\end_inset 

.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 196
file observingMethods.eps
width 4 100
flags 15

\end_inset 


\layout Caption

Design for Observing Methods
\begin_inset LatexCommand \label{Abb:observingMethods}

\end_inset 


\end_float 
\layout Standard

The point is, that not methods but method invocations are features observed
 by invariants.
 A method invocation is a method together with a parameter sequence suitable
 to invoke this method.
 
\layout Standard

Up to now, the implementation observes attributes only.
\layout Subsection

Implementation
\layout Standard

Not all of these classes exist explicitly in the implementation.
 
\emph on 
Class
\emph toggle 
 and 
\emph on 
Object
\emph toggle 
 are provided by the user model already.
 
\emph on 
Invariant
\emph toggle 
 exists only as an additional method 
\family typewriter 
checkOclInvariant_<name>
\family default 
 of its context class.
 
\emph on 
InvariantInstance
\emph toggle 
 is an explicit class
\begin_float footnote 
\layout Standard

called a bit confusingly 
\family typewriter 
tudresden.ocl.injection.lib.Invariant
\family default 
.
\end_float 
 of the injection library.
 Finally 
\emph on 
Feature
\emph toggle 
 is provided by the user model, but cannot be referred as a single java
 object.
 (
\family typewriter 
java.lang.reflect.Field
\family default 
 is a field of a class, not of an object.) Whenever a feature has to be referred,
 it is represented by it's observer collection object, which sufficient
 for the needs of this implementation.
\layout Standard

Changes of object features are detected with polling.
 For each feature the ocl injector adds a backup to the class.
 
\layout LyX-Code

class Person
\newline 
{
\newline 

\protected_separator 

\protected_separator 
int age;
\newline 

\protected_separator 

\protected_separator 
int age_oclbackup=age;
\newline 
}
\layout Standard

Additionally there is a utility method added comparing each attribute to
 it's backup.
 If there is a difference, the observers of the attribute are notified.
 
\layout LyX-Code

private void checkForChangedFeatures()
\newline 
{
\newline 

\protected_separator 

\protected_separator 
if(age!=age_oclbackup)
\newline 

\protected_separator 

\protected_separator 
{
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
age_oclbackup=age;
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
// notify observers of age
\newline 

\protected_separator 

\protected_separator 
}
\newline 

\protected_separator 

\protected_separator 
// ...
 further attributes
\newline 
}
\layout LyX-Code


\protected_separator 

\layout Standard

This method is called immediately before and after each method of the class.
 If the attribute contains an object reference, the comparison tests object
 identity, not object equality.
 This means, the 
\family typewriter 
!=
\family default 
 operator is used as for basic types and not the 
\family typewriter 
equals()
\family default 
 method.
 For collections the backup stores a hashcode
\begin_float footnote 
\layout Standard

see 
\family typewriter 
tudresden.ocl.injection.HashExact.identityHashCode
\family default 
.
\end_float 
 of the collection to avoid the overhead of maintaining a complete backup
 collection.
\layout Chapter

Model Information
\layout Standard

The OCL compiler needs model information for type checking.
 How this works is explained in 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 5.3.3.
 
\layout Standard

One possible source of model information may be a UML model exported from
 a CASE tool.
 This is probably the most elegant way.
 But since most real-world projects don't have a (up to date) UML representation
 of their business model, this isn't feasable in practice.
\layout Standard

Another source is the java code itself, accessed through reflection API
\begin_float footnote 
\layout Standard

see class 
\family typewriter 
tudresden.ocl.check.types.ReflectionFacade
\family default 
.
\end_float 
.
 This very convenient, since no additional model is needed.
 However, java reflection lacks some model properties which are important
 for type checking.
\layout Enumerate

Element types of collections, particularly collections representing associations.
 From a C++ perspective, java lacks templates implementing parameterized
 container classes.
\layout Enumerate

Qualifier types of maps, representing qualified associations.
\layout Enumerate

The isQuery tag of operations.
 Note, that OCL expressions may use operations without side effects (queries)
 only.
\layout Standard

This chapter present a solution to the first two items above.
 The information needed is put into the source code.
 Section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

 explaines, how this information is stored, while section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineering}

\end_inset 

 presents several approaches, how this information is generated.
\layout Section

Representing Element Types
\begin_inset LatexCommand \label{Sec:element_type_tag}

\end_inset 


\layout Standard

Element types and qualifier types are specified special tags in java documentati
on comments.
 See the example below.
 
\layout LyX-Code

class Company
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
All persons employed
\protected_separator 
by this company.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
 
\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Collection employees;
\newline 
}
\layout Standard

The 
\family typewriter 
@element-type
\family default 
 tag has a syntax like 
\family typewriter 
@see
\family default 
 as defined in 
\begin_inset LatexCommand \cite{JAVA}

\end_inset 

 section 18.4.1, but may refer to classes and interfaces only.
 This tag is valid for attributes only, and there may be only one of such
 tags per documentation comment.
 The tag is not restricted to attributes of type 
\family typewriter 
java.util.Collection
\family default 
, since future implementations could use other collection API's as well.
\layout Standard

Analogously, the 
\family typewriter 
@key-type
\family default 
 tag is introduced for association qualifiers.
 
\layout LyX-Code

class Bank
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
Customers qualified by
\protected_separator 
their account number.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
@key-type Integer
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Map customers;
\newline 
}
\layout Standard

Note, that the reflection model is restricted to qualified associations
 with one qualifier only.
 
\begin_inset LatexCommand \cite{UML}

\end_inset 

 allows multiple qualifiers, but there is no convenient representation for
 this in java.
 
\layout Standard

Furthermore, UML specifies the unqualified association feature to be a set,
 i.e.
 there must be no duplicates.
 Since this is not enforced by 
\family typewriter 
java.util.Map
\family default 
 (only keys are guaranteed to be unique), the ocl library provides an appropriat
e runtime check.
\layout Paragraph

Implementation.
\layout Standard

A really comfortable implementation would let the java compiler do the parsing,
 and provide the information through an extended reflection API.
 This would be similar to the 
\family typewriter 
@deprecated
\family default 
 tag.
 My implementation extends
\begin_float footnote 
\layout Standard

Encapsulated in 
\family typewriter 
tudresden.ocl.check.types.ReflectionExtender
\family default 
.
\end_float 
 the reflection facade by scanning the source code for these comments on
 demand.
 This implies, that the java source code is necessary for type checking
 OCL constraints in addition to the class files.
\layout Standard

There is a crucial question left: Where do the tags come? Possible sources
 are:
\layout Itemize

A UML model.
 The code generator of a CASE tool could generate these tags.
 
\layout Itemize

Maintained by hand.
 It is good-practice of programming, to specify which kind of objects are
 supposed to be in a collection attribute.
 The tags just make this information available formally.
 
\layout Itemize

Reverse Engineering.
 This is discussed in detail in section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineering}

\end_inset 

 below.
\layout Standard

Collection attributes with type tags are verified on runtime by the injected
 code.
 Note, that this kind of type information is useful for reverse engineering
 a UML model from given java code.
\layout Section

Reverse Engineering
\begin_inset LatexCommand \label{Sec:ReverseEngineering}

\end_inset 


\layout Standard

Section 
\begin_inset LatexCommand \ref{Sec:element_type_tag}

\end_inset 

 explained, how to store additional type information of a java model in
 java documentation tags.
 This section discusses, how to create this information.
\layout Standard

Actually, these type tags have to be created manually.
 This chapter tries to support the developer with an interactive tool for
 injecting 
\family typewriter 
@element-type
\family default 
 and 
\family typewriter 
@key-type
\family default 
 tags into the code.
 There are two main features of this tool:
\layout Enumerate

Graphical User Interface: Clear presentation of missing type tags and comfortabl
e editing facilities.
 
\layout Enumerate

Decision Support: Giving hints to the developer.
 These hints are either derived statically from the java source code (section
 
\begin_inset LatexCommand \ref{Sec:ReverseEngineeringStatic}

\end_inset 

) or gathered dynamically on run time (section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineeringDynamic}

\end_inset 

).
 There is a special indication, if several hints suggest different types.
\layout Subsection

Static Information
\begin_inset LatexCommand \label{Sec:ReverseEngineeringStatic}

\end_inset 


\layout Standard

Information about element types may be derived from static properties of
 the class, such as parameter types of methods and other tags in doccomments.
 
\layout Standard

The following example suggests some of these properties.
 The element type of 
\family typewriter 
employees
\family default 
 is obviously 
\family typewriter 
Person
\family default 
, but this information is not yet available to the OCL compiler.
 The tool can derive an appropriate hint for the developer from one of the
 underlined features.
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
All employed {@link 
\bar under 
Person
\bar default 
 persons} of this company.
\newline 

\protected_separator 
 
\protected_separator 
@see 
\bar under 
Person
\bar default 

\newline 
*/
\newline 
Collection employees;
\newline 

\protected_separator 

\newline 
boolean isEmployee(
\bar under 
Person
\bar default 
);
\newline 
void addEmployee(
\bar under 
Person
\bar default 
);
\newline 
void removeEmployee(
\bar under 
Person
\bar default 
);
\layout Standard

Note, that the example above requires linguistic knowledge about plural
 and singular form of nouns (employee here).
 This gets far more difficult, if identifiers are not English.
\layout Subsection

Runtime Type Tracing
\begin_inset LatexCommand \label{Sec:ReverseEngineeringDynamic}

\end_inset 


\layout Standard

This section describes, how to trace element types of collections on runtime.
 This is useful, if there is no static type information available, as described
 in the previous section.
 
\layout Standard

For each collection attribute, the object types encountered during a run
 of the program are collected and fed into the interactive tool.
 This requires the program to be executable.
 Additionally there must be extensive test cases available, otherwise only
 a subset of all possible element types will be encountered.
\layout Standard

The interactive tool presents the set of object types for every collection
 attribute.
 Additionally, the tool highlights all types, for which there is no super
 type in this set.
 Formally, this are the local minima of the set respective to the generalization
 partial order.
 These local minima are good candidates for a element type, especially if
 there is only one minimum.
 Presenting minima simplifies the decision if there are many types encountered
 in the collection attribute.
\layout Paragraph

Implementation.
\layout Standard

The ocl injector makes a static method 
\family typewriter 
traceTypes
\begin_float footnote 
\layout Standard

actually 
\family typewriter 
tudresden.ocl.injection.lib.TypeTracer.traceTypes
\family default 
.
\end_float 
 to be executed whenever a collection attribute changes it's contents.
 Class 
\family typewriter 
TypeTracer
\family default 
 maintains a static data structure containing all element types and key
 types for all attributes, as well as the minima of these type sets.
 This information is continuesly written to a log file.
 The interactive tool reads this log file on startup.
\layout Subsection

Byte Code Analysis Using Womble
\layout Chapter

Maintaining the OCL Compiler
\layout Standard

This chapter describes all major changes to Frank Fingers OCL compiler.
 This includes bugfixes too, if they caused changes of internal or external
 interfaces.
 It it some kind of update for 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

, listing everything changed since.
\layout Section

Reflection Facade and OCL Library
\layout Standard

Many changes occurred both in the reflection type facade and in the ocl
 library.
 This section groups these changes.
\layout Subsection

Polymorphism of Operation Parameters
\layout Standard

Both 
\family typewriter 
ReflectionFacade.\SpecialChar \-
navigateParameterized
\family default 
 and 
\family typewriter 
OclAnyImpl.\SpecialChar \-
getFeature
\family default 
 lacked polymorphism of operation parameters.
 This means, that a method is found only if actual parameter types match
 formal parameter types exactly.
 The correct behavior is, that actual parameter types may also be subtypes
 of formal parameter types.
 For a detailed description see 
\begin_inset LatexCommand \cite{rw7}

\end_inset 

 section 3.1.5.
 
\layout Standard

The new implementation made 
\family typewriter 
ReflectionAdapter.\SpecialChar \-
getClassForType
\family default 
 superfluous, so it was removed from the interface.
\layout Subsection

Mandatory Name Adapters
\layout Standard

Previous versions of the ocl library provided a default functionality, if
 no name adapter had been set explicitly.
\layout Standard

Now its mandatory to set a name adapter.
 Otherwise a NullPointerException is thrown.
 The default functionality has been moved into a separate name adapter (
\family typewriter 
SimpleNameAdapter
\family default 
) which is used in the reflection facade as well.
 The name adapter may also be set by the java property 
\family typewriter 
tudresden.ocl.lib.nameadapter
\family default 
.
\layout Subsection

Qualified Associations
\layout Standard

The OCL support was enhanced by adding a simplified form of qualified associatio
ns to the reflection facade and the ocl library.
 
\begin_inset Quotes eld
\end_inset 

Simplified
\begin_inset Quotes erd
\end_inset 

 means, that there may be only one qualifier attribute.
 
\layout Standard

Qualified associations are represented in java with 
\family typewriter 
java.util.Map
\family default 
 by default, but this may be changed by implementing 
\family typewriter 
ReflectionAdapter.isMap()
\family default 
.
\layout Subsection

Type Mapping from OCL to Java.
\layout Standard

The mapping beetween ocl types and java types now supports the collections
 API introduced in JDK version 1.2.
 The changes concern 
\family typewriter 
DefaultOclFactory.\SpecialChar \-
getOcl\SpecialChar \-
Representation\SpecialChar \-
For(Object)
\family default 
 and 
\family typewriter 
DefaultReflection\SpecialChar \-
Adapter.getClass\SpecialChar \-
ForType
\family default 
.
 
\layout Standard

A special handling of 
\family typewriter 
java.util.Vector
\family default 
 supports code generated by Argo/UML.
 The static configuration variable 
\family typewriter 
Ocl.TAKE_VECTORS_AS_SET
\family default 
 causes vectors to be mapped to sets, instead of sequences.
\layout Standard

The new mapping is listed below.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
6 3 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
0 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Java (java.util)
\newline 
take vectors as set
\newline 
OCL
\newline 
List
\newline 
-
\newline 
Sequence
\newline 
Vector
\newline 
false
\newline 
Sequence
\newline 

\newline 
true
\newline 
Set
\newline 
Set
\newline 
-
\newline 
Set
\newline 
Map
\newline 
-
\newline 
Set (qualified)
\layout Standard

Furthermore, arrays are now supported.
 They are mapped into sequences of the appropriate element type.
\layout Section

Undefined Values in the OCL Library
\layout Standard

Previous versions of the ocl library implemented undefined values as singletons
 for each type.
 
\layout Standard

This was given up.
 Now undefined values carry the reason for their creation with them.
 When the undefined value is tried to be evaluated, this reason is added
 to the exception message.
 
\layout Standard

This made 
\family typewriter 
Ocl.STRICT_CHECKING
\family default 
 superfluous, so it was removed.
 replaced exceptions by undefined values, parameterized with the reason
 for the undefined value.
\layout Standard

Additionally some other parts 
\layout Enumerate

Method 
\family typewriter 
OclCollection.setToRange
\family default 
 now creates an undefined collection (instead of throwing an exception),
 if lower bound is greater than upper bound.
\layout Enumerate

The methods 
\family typewriter 
Ocl.to<OclType>(OclRoot)
\family default 
 now return a undefined value of the appropriate type, if argument is undefined.
 
\layout Section

Typechecker
\layout Enumerate

added OclAny to TypeChecker (DefaultTypeFactory).
 
\layout Enumerate

Bugfix, removed TypeFactory.getClassifier - replaced all calls by TypeFactory.get
\layout Section

JavaCodeGenerator: 
\begin_inset LatexCommand \label{Sec:maintainJavaCodeGenerator}

\end_inset 


\layout Enumerate

different meaning of Codefragments created for @pre expressions (TRANSFER,
 PREPARATION, CODE), makes it easier and more flexible for different code
 injector tools.
 compare to 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 7.1.2, description of new behavior in section 
\begin_inset LatexCommand \ref{Sec:codegeneration_result}

\end_inset 

, TODO comparison to Franks example
\layout Enumerate

explicit package qualifier for ocl library is optionally prepended.
 Replaces the import statement and therefore fulfills the corresponding
 requirement in section 
\begin_inset LatexCommand \ref{Sec:injection_requirements}

\end_inset 

.
\layout Section

Silly Bugfixes
\layout Enumerate

JavaCodeGenerator: order on arrow
\layout Enumerate

Basic.navigate: max[1]
\layout Enumerate

DefaultOclFactory.getOclRepresentationFor(Object): dealing with Float and
 Double
\layout Enumerate

OclCollection.setToRange: exchanged bounds in error condition
\layout Chapter
\start_of_appendix 
Usage of Injector 
\layout Standard

This chapter describes, how to use the injector tool.
 
\layout Standard

Synopsis is below.
\layout LyX-Code

java tudresden.ocl.injection.Main [options] file.java ...
\layout Standard

Provide all java files, you want to modify.
 
\layout Standard

Options recognized are below.
 Most options have a short and a long version.
 Long versions try to be self explanatory and should be used in scripts.
\layout LyX-Code

-m --modify
\layout Quotation

Enables modifying java files.
 If not provided, the modified java code is written to 
\family typewriter 
file.java.injected
\family default 
.
 This switch serves as a safety check, whether you 
\emph on 
really
\emph toggle 
 want to replace your source code with the output of the injector.
\layout LyX-Code

-c --clean
\layout Quotation

Performs cleaning of source files instead of injection.
 After cleaning, the source code should show no differences to the version
 before injecting.
\layout LyX-Code

-f --constraint-file constraints.txt
\layout Quotation

Specifies the text file containing the constraints.
 Usually not needed, since constraints may and should be inlined into java
 doc comments.
 See section 
\begin_inset LatexCommand \ref{Sec:embedConstraints}

\end_inset 

.
\layout LyX-Code

-x --xmi-model model.xmi
\layout Quotation

Specifies the XMI file containing the model covered.
 Is used for type checking only.
 Use this only, if you cannot use 
\family typewriter 
--reflection-model
\family default 
.
\layout LyX-Code

-r
\protected_separator 
--reflection-model modelpackage
\layout Quotation

Specifies the java packages containing the model covered.
 If there is a constraint 
\family typewriter 
context Person
\family default 
, the type checker will look for class Person in all package given by this
 option.
 This is some kind of 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
import
\family default 
 for ocl
\begin_inset Quotes erd
\end_inset 

.
 For multiple packages use multiple options.
\layout LyX-Code

-n --name-adapter [none|argo]
\layout Quotation

Specifies the name adapter.
 Default is 
\family typewriter 
none
\family default 
.
 If you don't use code generated by Argo/UML, the default is sufficient.
 Further information on name adapters is available at 
\begin_inset LatexCommand \cite{ff3}

\end_inset 

 section 3.5.1 and 3.5.6.
\layout LyX-Code

-is --invariant-scope [all|private|protected|package|public|explicit]
\layout Quotation

Specifies the the scope of invariants used.
 See section 
\begin_inset LatexCommand \ref{Sec:temporalScope}

\end_inset 

 for a detailed explanation.
 Access modifiers select methods having the same or a more public access
 modifier.
 Thus, 
\family typewriter 
all
\family default 
 and 
\family typewriter 
private
\family default 
 are equivalent.
 Default is 
\family typewriter 
all
\family default 
.
\layout LyX-Code

-vm --violation-macro macro
\layout Quotation

Specifies what to do, if a constraint fails.
 This string is inserted verbatim into the code.
 The injector appends a pair of parents enclosing a suitable message string.
 Good candidates are 
\family typewriter 
System.out.println
\family default 
 (the default) or 
\family typewriter 
throw new RuntimeException
\family default 
.
 Note, that the latter must be enclosed in 
\family typewriter 
""
\family default 
 on Unix shells.
\layout Quotation

The exception thrown must not be a 
\emph on 
checked exception
\emph toggle 
 as specified by 
\begin_inset LatexCommand \cite{JAVA}

\end_inset 

 section 11.2.
 Otherwise the modified code will not compile!
\layout LyX-Code

-tt --trace-types
\layout Quotation

Performs type tracing of collection elements.
 See section 
\begin_inset LatexCommand \ref{Sec:ReverseEngineeringDynamic}

\end_inset 

 for details.
 The information gathered is written to a log file specified by property
 
\family typewriter 
tudresden.\SpecialChar \-
ocl.injection.\SpecialChar \-
lib.TypeTracer.log
\family default 
.
\layout Quotation

Note, that the log file must be specified when running the user program,
 not the injector! For example use 
\family typewriter 
-Dtudresden.\SpecialChar \-
ocl.injection.\SpecialChar \-
lib.TypeTracer.\SpecialChar \-
log=ocltypetrace.txt
\family default 
.
 If not specified, the type information is written to standard out.
\layout LyX-Code

--insert-immediately
\layout Quotation

Triggers immediate insertion of wrapper methods.
 Otherwise wrapper methods are inserted at the end of each class.
 Immediate insertion allows easier tracing of the modifications.
 This option is mainly useful for debugging.
\layout LyX-Code

--trace-checking
\layout Quotation

Adds code logging each constraint checked on an object to standard out.
 Useful for debugging.
\layout LyX-Code

--simple-hash
\layout Quotation

Uses simple hash functions in 
\family typewriter 
HashSimple
\family default 
, instead of the sophisticated hash functions in 
\family typewriter 
HashExact
\family default 
.
 Simple hash functions just return the size of the collection, so they will
 detect insertions/deletion only.
 Reduces cpu load for big models.
\layout Standard


\begin_inset LatexCommand \listoffigures

\end_inset 


\layout Bibliography
\bibitem [FF00]{ff3}

Frank Finger.
 Design and Implementation of a Modular OCL Compiler.
 Diplomarbeit.
 TU-Dresden 2000.
 http://dresden-ocl.sourceforge.net/
\layout Bibliography
\bibitem [WK99]{Warmer}

Jos Warmer, Anneke Kleppe.
 The Object Constraint Language: Precise Modeling with UML.
 Addison-Wesley, 1999.
\layout Bibliography
\bibitem [WK99e]{WarmerErrata}

Errata for 
\begin_inset LatexCommand \cite{Warmer}

\end_inset 

: http://www.klasse.nl/ocl-boek/errata.htm
\layout Bibliography
\bibitem [UML]{UML}

OMG Unified Modeling Language Specification, Version 1.3, June 1999.
\layout Bibliography
\bibitem [OCL]{OCL}

Object Constraint Language Specification.
 Chapter 7 in 
\begin_inset LatexCommand \cite{UML}

\end_inset 

.
\layout Bibliography
\bibitem [JAVA]{JAVA}

James Gosling, Bill Joy, Guy Steele.
 The Java Language Specification.
 Edition 1.0.
 August 1996.
\layout Bibliography
\bibitem [JW99]{womble}

Daniel Jackson, Allison Waingold.
 Lightweight Extraction of Object Models from Bytecode.
 Proc.
 International Conference on Software Engineering.
 May 1999.
 http://sdg.lcs.mit.edu/womble/
\layout Bibliography
\bibitem [KSR00]{kbeans}

Holger Knublauch, Martin Sedlmayr, Thomas Rose.
 Design Patterns for the Implementation of Constraints on JavaBeans.
 TODO http://www.faw.uni-ulm.de/kbeans/
\layout Bibliography
\bibitem [RW00]{rw7}

Ralf Wiebicke.
 XML Query Languages for Repositories Based on XML Documents.
 Groer Beleg.
 TU-Dresden 2000.
 http://dresden-ocl.sourceforge.net/
\the_end
