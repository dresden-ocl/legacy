#This file was created by <wiera> Wed Jun 28 13:06:48 2000
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass report
\begin_preamble
\usepackage{textcomp}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Diploma Thesis:
\newline 
Utility Support for Checking OCL Business Rules in Java Programs
\layout Author

Ralf Wiebicke
\layout Date

May 2000
\layout Section*

Copyright
\layout Standard

Copyright 
\latex latex 

\backslash 
copyright
\latex default 

\protected_separator 
2000 Ralf Wiebicke.
\layout Standard

Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.1 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is available at http://www.gnu.org/copyleft/fdl.html.
\layout Section*

Availability
\layout Standard

This document is available at http://www.inf.tu-dresden.de/~rw7/diplom00/ in
 several electronic forms including PostScript, PDF, Html and the original
 kLyx version.
\layout Standard


\begin_inset LatexCommand \tableofcontents

\end_inset 


\layout Chapter

Introduction
\layout Section

OCL and Extreme Programming
\layout Chapter

Code Generation
\layout Section

Representation Of Associations
\layout Subsection

Possibilities
\layout Itemize

Collections named by the role name (maps for qualified associations)
\layout Itemize

Methods (isEmployed)
\layout Subsection

CASE-Tools
\layout Subsection

Net-Linx
\layout Standard

Anpassbarkeit an vorhandenen Quellcode.
\layout Section

Model Information
\layout Standard

Needed for Type Checking.
\layout Standard

5.3.3
\layout Standard

There is already the Reflection Facade, which is pretty cool with two exception:
 
\layout Enumerate

no element types of associations.
 
\layout Enumerate

no isquery tag
\layout Standard

Solution: extend the java language.
 The new tag has a syntax like 
\family typewriter 
@see
\family default 
, but restricted to classes only.
\layout LyX-Code

class Company
\newline 
{
\newline 

\protected_separator 

\protected_separator 
/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
All persons currently employed 
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
by this company.
\newline 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 

\protected_separator 
 
\protected_separator 
@element-type Person
\newline 

\protected_separator 

\protected_separator 
*/
\newline 

\protected_separator 
 Collection employees;
\newline 
}
\layout Standard

Cool implementation: an extension of the reflection api and the java compiler.
\layout Standard

My implementation: An extension of the reflection facade scanning the source
 code for these comments.
 Encapsulated in tudresden.ocl.check.types.ReflectionExtender.
\layout Paragraph

Where comes the tag?
\layout Itemize

CASE-Tools
\layout Itemize

handmade: good-practice of programming.
 Should be there already in the comments, the tag makes it available formally.
\layout Itemize

reverse enginieering.
 see chapter [reverse enginieering]
\layout Standard

Will be tested automatically by the injected code.
\layout Standard

Is a good help for further reengineering from Java to UML (Diplomarbeit
 Stefan Frisch?)
\layout Chapter

Code Injection
\layout Section

Major Decisions
\layout Itemize

Reversable Transformation: 
\begin_deeper 
\layout Itemize

Must be possible to clean the code from all injected fragments.
\layout Itemize

Must be possible to edit the transformed source code without losing all
 changes at the next injection.
\layout Itemize

Major reasons: 
\begin_deeper 
\layout Itemize

the error messages pointing to the source code.
\layout Itemize

injection must be done only when the contraints heve been changed, not if
 the java source has been changed.
\end_deeper 
\end_deeper 
\layout Itemize

Method Wrapper
\layout Itemize

no import statements, explicit package qualifying in the generated code
 instead.
\layout Itemize

checking the @element-type
\layout Itemize

able to read arbitrary java files, which have passed sucessfully a the java
 compiler.
\layout Itemize

may be: Auslagerung von möglichst viel code auf eine Extraklasse pro Klasse
 oder pro Package.
 Entlastung des CVS.
 Das hat niedrige Priorität.
\layout Section

Wrapping Methods
\layout Standard

Touching the code of each method is needed, because the generated code must
 be run on each call to the method.
\layout Standard

Using wrapper methods avoids many problems which arise if there are several
 return statements in a method or a complex expression in the return statement.
 Also, there are no name conflicts anymore beetween the original and the
 generated code.
\layout Paragraph

Example.
\layout Standard

This is, how it works: A method
\layout LyX-Code

int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
} 
\layout Standard

is transformed into two methods:
\layout LyX-Code

int someMethod_wrappedbyocl(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code.
\newline 
}
\newline 

\protected_separator 

\newline 
int someMethod(double x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// some code checking invariants/preconditions.
\newline 

\protected_separator 

\protected_separator 
int result=someMethod_wrappedbyocl(x);
\newline 

\protected_separator 

\protected_separator 
// some code checking postconditions/invariants.
\newline 

\protected_separator 

\protected_separator 
return result;
\newline 
}
\layout Standard

Slightly different and a bit tricky for constructors:
\layout LyX-Code

SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\layout Standard

gets to
\layout LyX-Code

SomeClass(String x, Void void)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
// here comes the code
\newline 
}
\newline 

\protected_separator 

\newline 
SomeClass(String x)
\newline 
{
\newline 

\protected_separator 

\protected_separator 
this(x, new Void());
\newline 

\protected_separator 

\protected_separator 
// some code checking postconditions/invariants.
\newline 
}
\layout Section

Cleaning the Code
\layout Standard

One of my goals for the injector tool is the following:
\layout Quote

The user may inject generated code into arbitrary user code in place, edit
 the modified source code, redo the injection in place when the ocl constraints
 have changed, and clean the code from the injected code.
 Cleaning means, that there is not a single byte left in the source.
\layout Standard

This section explains, how the injector tool accomplishes this goal.
\layout Standard

The injector tool touches the user code in two different ways:
\layout Enumerate

renaming the wrapped methods
\layout Enumerate

adding new class features, i.e.
 wrapper methods, semaphore attributes
\layout Paragraph

Renaming Wrapped Methods.
\layout Standard

For each method to be wrapped the suffix 
\family typewriter 
_wrappedbyocl
\family default 
 is appended to the name.
 This transformation is done in the unparsed method header, so all typographical
 extras in the header (line breaks, comments etc.) are preserved.
 This transformation is easily reversed, when the code has to be cleaned.
\layout Paragraph

Cleaning Generated Class Features
\layout LyX-Code

/**
\newline 

\protected_separator 

\protected_separator 

\protected_separator 
@author ocl_injector
\newline 
*/
\newline 
int someMethod(double x);
\newline 

\layout Chapter

Reverse Engineering
\layout Standard

Avoid the UML model for type checking.
\layout Standard

An interactive tool for injecting 
\family typewriter 
@element-type
\family default 
 tags into the code using information obtained staticly from the source
 code or dynamicly on run time.
\layout Section

Static
\layout Standard

Given 
\family typewriter 
Collection employees
\family default 
 look for 
\family typewriter 
void addEmployee(Person)
\family default 
 or 
\family typewriter 
boolean isEmployee(Person)
\family default 
.
 
\layout Standard

Or look for a 
\family typewriter 
@see
\family default 
 tag in the corresponding doc comment.
\layout Section

Dynamic
\layout Itemize

Enriche the code with tracing the object types inside collections.
\layout Itemize

compile and run the program (regression tests if available)
\layout Chapter

Maintaining the OCL Compiler
\layout Enumerate

Using reflection in ReflectionFacade and ocl library
\begin_deeper 
\layout Enumerate

Added polymorphism of operation parameters (ReflectionFacade.\SpecialChar \-
navigateParameterize
d and OclAnyImpl.getFeature).
 This made ReflectionAdapter.getClassForType superflucous, so removed.
\layout Enumerate

Now its mandatory to provide a NameAdapter to the ocl library.
 Otherwise NullPointerExceptions are thrown.
 The default functionality if no NameAdapter is given has been moved into
 a separate NameAdapter (SimpleNameAdapter) which is used in ReflectionFacade
 as well.
 
\layout Enumerate

New mapping beetween collections in OCL and Java conforming to JDK1.2.
 The special handling of Vector is used for older CodeGenerators.
 (DefaultOclFactory.getOclRepresentationFor(Object) and DefaultReflectionAdapter.g
etClassForType)
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol5
5 3 0 0 -1 -1 -1 -1
1 1 0 0
1 1 0 0
0 0 0 0
0 1 0 0
0 1 0 0
8 1 0 "" ""
8 1 0 "" ""
8 1 1 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Java (java.util)
\newline 
Ocl.TAKE_VECTORS_AS_SET
\newline 
OCL
\newline 
List
\newline 
-
\newline 
Sequence
\newline 
Vector
\newline 
false
\newline 
Sequence
\newline 

\newline 
true
\newline 
Set
\newline 
Set
\newline 
-
\newline 
Set
\end_deeper 
\layout Enumerate

Typechecker
\begin_deeper 
\layout Enumerate

added OclAny to TypeChecker (DefaultTypeFactory).
 
\layout Enumerate

Bugfix, removed TypeFactory.getClassifier replaced all calls by TypeFactor.get
\end_deeper 
\layout Enumerate

JavaCodegenerator: 
\begin_deeper 
\layout Enumerate

different meaning of Codefragments created for @pre expressions (TRANSFER,
 PREPARATION, CODE), makes it easier and more flexible for different code
 injector tools
\layout Enumerate

explicit package qualifier for ocl library is optionally prepended, replaces
 the import statement.
 Why?
\begin_deeper 
\layout Enumerate

Fewer spots were the code ahs to be touched
\layout Enumerate

Avoid name confict beetween ocl library and user code.
\end_deeper 
\end_deeper 
\layout Bibliography
\bibitem [FF]{ff3}

Frank Finger.
 Design and Implementation of a Modular OCL Compiler.
 Diplomarbeit.
 TU-Dresden 2000.
 http://www-st.inf.tu-dresden.de/ocl/
\layout Bibliography
\bibitem [UML]{UML}

OMG Unified Modeling Language Specification, Version 1.3, June 1999.
\layout Bibliography
\bibitem [OCL]{OCL}

Object Constraint Language Specification.
 Chapter 7 in 
\begin_inset LatexCommand \cite{UML}

\end_inset 

.
\the_end
