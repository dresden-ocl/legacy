%% This LaTeX-file was created by <wiera> Mon Jul 31 13:29:07 2000
%% LyX 0.12 (C) 1995-1998 by Matthias Ettrich and the LyX Team

%% Do not edit this file unless you know what you are doing.
\documentclass[a4paper,english]{report}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{babel}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\newcommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\spacefactor1000}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxcode}
  {\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \ttfamily}%
   \item[]}
  {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{textcomp}
\makeatother

\begin{document}


\title{Diploma Thesis:\\
Utility Support for Checking OCL Business Rules in Java Programs}


\author{Ralf Wiebicke}


\date{May 2000}

\maketitle

\section*{Copyright}

Copyright \copyright~2000 Ralf Wiebicke.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later version
published by the Free Software Foundation; with no Invariant Sections, no Front-Cover
Texts, and no Back-Cover Texts. A copy of the license is available at http://www.gnu.org/copyleft/fdl.html.

The source code developed together with this paper is Copyright \copyright~2000
Ralf Wiebicke and published under the GNU Lesser General Public License.


\section*{Availability}

This document is available at http://dresden-ocl.sourceforge.net/diploma\_rw7/
in several electronic forms including \LaTeX{}, Postscript, PDF, Html and the
original kLyx version. 

The source code developed together with this paper is available at http://dresden-ocl.sourceforge.net/.

\tableofcontents


\chapter{Introduction}


\section{OCL and Extreme Programming}


\chapter{Code Generation}


\section{Representation Of Associations}


\subsection{Possibilities}

\begin{itemize}
\item Collections named by the role name (maps for qualified associations)
\item Methods (isEmployed)
\end{itemize}

\subsection{CASE-Tools}


\subsection{Net-Linx}

adaptability to legacy Quellcode.


\section{Model Information\label{Sec:element_type_tag}}

The OCL compiler needs model information for type checking. How this works is
explained in \cite{ff3} section 5.3.3. The sources for model information may
be a UML model exported from a CASE tool, or the java source code, which is
accessed through reflection API\footnote{
see class \texttt{tudresden.ocl.check.types.ReflectionFacade}.
}. The latter approach is very convenient, since most java projects don't have
a (up to date) UML representation of their business model. 

However, java reflection lacks some model properties which are important for
type checking.

\begin{enumerate}
\item Element types of collections, particularly collections representing associations. 
\item Qualifier types of maps, representing qualified associations.
\item The isQuery tag of operations. Note, that OCL expressions may use operations
without side effects (queries) only.
\end{enumerate}
The solution is to put the additional information needed into java documentation
comments. See the example below. 

\begin{lyxcode}
class~Company\\
\{\\
~~/{*}{*}\\
~~~~~All~persons~employed~by~this~company.\\
~~~~~@element-type~Person\\
~~{*}/\\
~~Collection~employees;\\
\}
\end{lyxcode}
The new \texttt{@element-type} tag has a syntax like \texttt{@see} as defined
in \cite{JAVA} section 18.4.1, but may refer to classes and interfaces only.
This tag is valid for attributes only, and there may be only one of such tags
per documentation comment. The tag is not restricted to attributes of type \texttt{java.util.Collection},
since future implementations could use other collection API's as well.

Analogously, the \texttt{@key-type} tag is introduced for association qualifiers. 

\begin{lyxcode}
class~Bank\\
\{\\
~~/{*}{*}\\
~~~~~Customers~qualified~by~their~account~number.\\
~~~~~@element-type~Person\\
~~~~~@key-type~Integer\\
~~{*}/\\
~~Map~customers;\\
\}
\end{lyxcode}
Note, that the reflection model is restricted to qualified associations with
one qualifier only. \cite{UML} allows multiple qualifiers, but there is no
convenient representation for this in java.


\paragraph{Implementation.}

A really comfortable implementation would let the java compiler do the parsing,
and provide the information through an extended reflection API. This would be
similar to the \texttt{@deprecated} tag. My implementation extends\footnote{
Encapsulated in \texttt{tudresden.ocl.check.types.ReflectionExtender}.
} the reflection facade by scanning the source code for these comments on demand.
This implies, that the java source code is necessary for type checking OCL constraints
in addition to the class files.


\paragraph{Where comes the tag?}

\begin{itemize}
\item CASE-Tools
\item handmade: good-practice of programming. Should be there already in the comments,
the tag makes it available formally.
\item reverse engineering. see chapter \ref{Sec:ReverseEngineering}.
\end{itemize}
Will be tested automatically by the injected code.

Is a good help for further reverse engineering from Java to UML (diploma Stefan
Frisch?)


\section{Looking at @pre-vious States}

only 1 @pre pro navigation, may be proposal


\chapter{Code Injection}

Injection of generated code into java programs is the main subject of this paper.
It covers anything beyond code generation, to get a java model checking its
own constraints. For an idea, where code generation ends and injection starts,
see section \ref{Sec:codegeneration_result}. 

This is followed by an analysis of requirements for the code injection and resulting
design decisions in section \ref{Sec:injection_requirements}. Sections \ref{Sec:wrappingMethods}
and \ref{Sec:cleaningCode} describe the solution in detail.

Finally sections \ref{Sec:temporalScope} and \ref{Sec:structuralScope} discuss
the more fundamental issue, when and how often invariants have to be checked.


\section{Results of Code Generation\label{Sec:codegeneration_result}}

The java code generator developed in \cite{ff3} produces a set of code fragments\footnote{
see class \texttt{tudresden.ocl.codegen.CodeFragment.}
}. These code fragment have the following properties:

\vspace{0.3cm}
{\centering \begin{tabular}{|l|p{70mm}|}
\hline 
Property &
\\
\hline 
\hline 
Constrained~type &
The default navigation context of this constraint.\\
\hline 
Kind &
Specifies, whether this constraint is an invariant, a pre- or a postcondition.
\\
\hline 
Constrained~operation &
The operation, this constraint applies to (valid for pre- and postconditions
only).\\
\hline 
Code &
Contains the actual java code to be executed.\\
\hline 
Result~variable &
Specifies the boolean value, which contains the result of the ocl expression
after code execution.\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

For each postcondition containing a @pre expression there are two additional
codefragments called preparation and transfer. See below.


\subsection{Preparation and Transfer Fragments}

The meaning of preparation and transfer fragments is explained on a dramatically
simplified example. 

Suppose a post condition for operation \texttt{employ()}, that leaves the attribute
\texttt{age} unchanged:

\begin{lyxcode}
context~Person::employ()~\\
post:~age=age@pre
\end{lyxcode}
the following codefragments will be produced:

\vspace{0.3cm}
{\centering \begin{tabular}{ll}
\hline 
Kind&
 Code\\
\hline 
\hline 
Transfer&
\texttt{int~node1;} \\
\hline 
Preparation&
\texttt{node1=this.age;}\\
\hline 
Post Condition&
\texttt{int~node2=this.age;}\\
&
\texttt{boolean~result=(node1==node2)}\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

Typically these fragments would be injected as follows:

\begin{lyxcode}
class~Person\\
\{\\
~~void~employ()\\
~~\{\\
~~~~int~node1;~~~~~~~//~transfer~fragment\\
~~~~node1=this.age;~~//~preparation~fragment\\
~~~~//~original~code~of~employ()\\
~~~~//~post~condition~fragment\\
~~~~node1=this.age;\\
~~~~boolean~result=(node1==node2)\\
~~\}\\
\}
\end{lyxcode}
Note, that precise semantics of codefragments involving the @pre expression
has been changed, so that the original meaning described in \cite{ff3} section
7.1.2 is no longer fully correct. For a detailed comparison see section \ref{Sec:maintainJavaCodeGenerator}.

\begin{lyxcode}
~
\end{lyxcode}

\section{Requirements and Design Decisions\label{Sec:injection_requirements}}

This section analyzes the requirements for the injector tool and derives some
fundamental design decisions.


\subsection{Reversable Modification\label{Sec:injection_requirements_reversable}}

The most important feature is the reversability of the code injection. It must
be possible

\begin{itemize}
\item to clean the code tracelessly from all injected fragments.
\item to redo the injection on source code that has already been modified (i.e. when
constraints have been changed).
\item to edit the modified source code without losing all changes at the next injection. 
\end{itemize}
This requirement makes things quite a bit more difficult, but there are serious
reasons for this. Otherwise there would be two versions of source code: the
original and the modified version. This raises some unpleasant problems:

\begin{enumerate}
\item Configuration management must handle two source code trees.
\item Developers must be careful to edit the original version only.
\item Running the ocl injector is required after every change of the java source code,
not only when the constraints have been changed. 
\item Stack traces of runtime exceptions point to the modified source code. Developers
must look for the corresponding place in the original version.
\end{enumerate}
The implementation of reversable modification requires a strategy of minimally
invasive modification. This is realized by two design decisions:

\begin{enumerate}
\item Method wrappers, explained detailed in section \ref{Sec:wrappingMethods}.
\item Explicit package qualifiers for the ocl library in the generated code. Otherwise,
an import statement for the ocl library would be necessary. This would be just
another spot, were the original source code has to be touched. Additionally,
this may introduce name conflicts beetween ocl library and user code.
\end{enumerate}

\subsection{Embedding Constraints in Java Source Code.}

It should be possible to embed constraints in the java documentation comments.
The placement of embedded constraints implicates (and replaces) the context
of the constraint. See the example below.

\begin{lyxcode}
/{*}{*}\\
~~~@invariant~age>0\\
{*}/\\
class~Person\\
\{\\
~~int~age;\\
~\\
~~/{*}{*}\\
~~~~~@postcondition~age=age@pre\\
~~{*}/\\
~~void~employ();\\
\}
\end{lyxcode}
It is necessary to put the constraints directly under the nose of the developer.
The author is strongly convinced, that constraints stored in an extra text file
are too far away from attention.


\subsection{Checking the Element Type.}

The injected code must check, that collection attributes comply to the \texttt{@element-type}
and \texttt{@key-type} tags introduced in section \ref{Sec:element_type_tag}.
This is quite easily done just before checking invariants.

Note, that this feature may be be used standalone, without ocl expressions at
all. Then it provides a runtime check for typed collections.


\section{Methods Wrappers\label{Sec:wrappingMethods}}

The main task of code injection is to have some code executed immediately before
and after all methods (and after all constructors too). This section describes,
how this is done by the ocl injector.


\paragraph{Simple Approach.}

The simple approach of adding the code directly into the method raises some
severe problems. 

\begin{enumerate}
\item The postcondition code to be executed after the method has to be inserted at
any return statement.
\item A return expression has to be computed in advance, if the post condition code
refers to the return value and/or the the return expression produces side effects.
\item There may be name conflicts beetween the original and the generated code.
\item A complete java parser is needed.
\item The original code has to be touched at many different places and in a complicated
way. This runs contrary to the strategy of minimally invasive modification as
decided in section \ref{Sec:injection_requirements_reversable}.
\end{enumerate}
Method wrappers solve all these problems in a nifty but simple way.


\paragraph{Wrapping Methods.}

Some code tells more than thousand words, so I use an example to explain. Consider
the following method.

\begin{lyxcode}
int~someMethod(double~x)\\
\{\\
~~//~here~comes~the~code.\\
\}~
\end{lyxcode}
The code injector transforms this into two methods.

\begin{lyxcode}
int~someMethod\_wrappedbyocl(double~x)\\
\{\\
~~//~here~comes~the~code.\\
\}\\
~\\
int~someMethod(double~x)\\
\{\\
~~//~some~code~checking~invariants/preconditions.\\
~~int~result=someMethod\_wrappedbyocl(x);\\
~~//~some~code~checking~invariants/postconditions.\\
~~return~result;\\
\}
\end{lyxcode}
The reader may have a look back at the problems encountered for the simple approach.
Non of them exists anymore. Especially, a very inchoate java parser is sufficient,
which understands anything outside of method bodies and attribute initializers
only.


\paragraph{Wrapping Constructors (not yet implemented).}

Another transformation is used for constructors, since they cannot be renamed.

\begin{lyxcode}
SomeClass(String~x)\\
\{\\
~~//~here~comes~the~code\\
\}
\end{lyxcode}
Instead of renaming, the original constructor gets an additional dummy argument.

\begin{lyxcode}
SomeClass(String~x,~Void~dummy)\\
\{\\
~~//~here~comes~the~code\\
\}\\
~\\
SomeClass(String~x)\\
\{\\
~~this(x,~new~Void());\\
~~//~some~code~checking~invariants.\\
\}
\end{lyxcode}
If a class provides no explicit constructor, then there is the default constructor
as specified in \cite{JAVA} section 8.6.7. This default constructor is not
wrapped, but replaced by an explicit constructor with the same access modifier.


\section{Cleaning the Code\label{Sec:cleaningCode}}

One of the requirements was, that the injector is able clean the modified code
without leaving any traces. This section explains, how this requirement is met.
The user code is touched in two different ways only:

\begin{enumerate}
\item Renaming the wrapped methods.
\item Adding new object features, i.e. wrapper methods, a method for checking invariants
and a semaphore attribute.
\end{enumerate}

\paragraph{Renaming Wrapped Methods.}

For each method to be wrapped the suffix \texttt{\_wrappedbyocl} is appended
to the name. This transformation is done on the unparsed method header, so all
typographical extras (line breaks, comments etc.) are preserved. This transformation
is easily reversed, when the code has to be cleaned.


\paragraph{Removing Generated Features.}

Removing generated class features relies on the fact, that the injector tags
all generated features as shown below.

\begin{lyxcode}
/{*}{*}\\
~~~@author~ocl\_injector\\
{*}/\\
void~checkOclInvariants();
\end{lyxcode}
This is quite simple and functional.


\section{Temporal Scope of Invariants\label{Sec:temporalScope}}

\begin{enumerate}
\item all methods
\item public methods
\item transactions
\end{enumerate}
refere to tutorial parameters of injector


\section{Structural Scope of Invariants\label{Sec:structuralScope}}

when to check which invariants


\chapter{Reverse Engineering\label{Sec:ReverseEngineering}}

Avoid the UML model for type checking.

An interactive tool for injecting \texttt{@element-type} tags into the code
using information obtained from the source code or dynamically on run time.


\section{Static Information}

Information about element types may be derived from static properties of the
class, such as parameter types of methods and tags in doccomments. The following
example suggests some of these properties. 

\begin{lyxcode}
/{*}{*}\\
~~~All~employees~of~this~company.\\
~~~@see~\underbar{Person}\\
{*}/\\
Collection~employees;\\
~\\
boolean~isEmployee(\underbar{Person});\\
void~addEmployee(\underbar{Person});\\
void~removeEmployee(\underbar{Person});
\end{lyxcode}
An interactive tool should support the developer by presenting these properties
in a comfortable way. There should be a special indication, if several properties
suggest different element types.

Note, that the example above requires linguistic knowledge about plural and
singular form of nouns (employee here). This gets far more difficult, if identifiers
are not English.


\section{Tracing Dynamic Type Information}

\begin{itemize}
\item Enrich the code with tracing the object types inside collections.
\item compile and run the program (regression tests if available)
\end{itemize}

\chapter{Maintaining the OCL Compiler}

This chapter describes all major changes to Frank Fingers OCL compiler. This
includes bugfixes too, if they caused changes of internal or external interfaces.


\section{Using reflection in ReflectionFacade and ocl library}

\begin{enumerate}
\item Added polymorphism of operation parameters (ReflectionFacade.\-navigateParameterized
and OclAnyImpl.getFeature). This made ReflectionAdapter.getClassForType superfluous,
so removed.
\item Now its mandatory to provide a NameAdapter to the ocl library. Otherwise NullPointerExceptions
are thrown. The default functionality if no NameAdapter is given has been moved
into a separate NameAdapter (SimpleNameAdapter) which is used in ReflectionFacade
as well. 
\item Added a simplified form of qualified associations to ReflectionFacade and ocl
library. Simplification means, that there may be only one qualifier attribute.
Qualified associations are represented by java.util.Map. ReflectionAdapter.isMap.
\item New mapping beetween collections in OCL and Java conforming to JDK1.2. The special
handling of Vector is used for older code generators. (DefaultOclFactory.getOclRepresentationFor(Object)
and DefaultReflectionAdapter.getClassForType)

\vspace{0.3cm}
{\centering \begin{tabular}{|c|c|c|}
\hline 
Java (java.util)&
Ocl.TAKE\_VECTORS\_AS\_SET&
OCL\\
\hline 
\hline 
List&
-&
Sequence\\
\hline 
Vector&
false&
Sequence\\
&
true&
Set\\
\hline 
Set&
-&
Set\\
\hline 
Map&
-&
Set (qualified)\\
\hline 
\end{tabular}\par}
\vspace{0.3cm}

\end{enumerate}

\section{ocl lib}

\begin{enumerate}
\item removed \texttt{Ocl.STRICT\_CHECKING}, replaced exceptions by undefined values,
parameterized with the reason for the undefined value.
\item Ocl.Collection.setToRange makes an undefined collection (instead of throwing
an exception), if lower bound is greater than upper bound.
\item Ocl.to<OclType>(OclRoot) methods check for undefined arguments.
\end{enumerate}

\section{Typechecker}

\begin{enumerate}
\item added OclAny to TypeChecker (DefaultTypeFactory). 
\item Bugfix, removed TypeFactory.getClassifier - replaced all calls by TypeFactory.get
\end{enumerate}

\section{JavaCodeGenerator: \label{Sec:maintainJavaCodeGenerator}}

\begin{enumerate}
\item different meaning of Codefragments created for @pre expressions (TRANSFER, PREPARATION,
CODE), makes it easier and more flexible for different code injector tools.
compare to \cite{ff3} section 7.1.2, description of new behavior in section
\ref{Sec:codegeneration_result}, TODO comparison to Franks example
\item explicit package qualifier for ocl library is optionally prepended. Replaces
the import statement and therefore fulfills the corresponding requirement in
section \ref{Sec:injection_requirements}.
\end{enumerate}

\section{Silly Bugfixes}

\begin{enumerate}
\item JavaCodeGenerator: order on arrow
\item Basic.navigate: max{[}1{]}
\item DefaultOclFactory.getOclRepresentationFor(Object): dealing with Float and Double
\item OclCollection.setToRange: exchanged bounds in error condition
\end{enumerate}
\appendix

\chapter{Injector Tutorial}

This chapter describes, how to use the injector tool.

\begin{thebibliography}{UML}
\bibitem[FF00]{ff3}Frank Finger. Design and Implementation of a Modular OCL Compiler. Diplomarbeit.
TU-Dresden 2000. http://www-st.inf.tu-dresden.de/ocl/
\bibitem[UML]{UML}OMG Unified Modeling Language Specification, Version 1.3, June 1999.
\bibitem[OCL]{OCL}Object Constraint Language Specification. Chapter 7 in \cite{UML}.
\bibitem[JAVA]{JAVA}James Gosling, Bill Joy, Guy Steele. The Java Language Specification. Edition
1.0. August 1996.
\end{thebibliography}
\end{document}
