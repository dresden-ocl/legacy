
/* This file was generated by SableCC (http://www.sablecc.org/). */

/* Generator for LAttrEvalAdapter written by Ansgar Konermann */
/* (c) 2004, 2005 Ansgar Konermann                            */
/* Contact: <konermann@itikko.net>                            */

package tudresden.ocl20.pivot.ocl2parser.testcasegenerator.gen.testcasegenerator.analysis;

import tudresden.ocl20.pivot.ocl2parser.testcasegenerator.gen.testcasegenerator.node.*;
/*import tudresden.ocl20.pivot.ocl2parser.testcasegenerator.gen.testcasegenerator.util.*;*/
import tudresden.ocl20.pivot.ocl2parser.testcasegenerator.util.*;
import tudresden.ocl20.pivot.ocl2parser.testcasegenerator.abstractsyntax.*;

import java.util.*;


public abstract class LAttrEvalAdapter implements AnalysisWithReturn {

    public static final boolean verbose = false;

    protected Token currentToken = null;
    public Token getCurrentToken() { return currentToken; }
    public void setCurrentToken(Token tk) { this.currentToken = tk; }
    public boolean hasCurrentToken() { return (this.currentToken != null); }

    protected IGenModelFactory factory = null;
 
    public void setNodeFactory(IGenModelFactory f) { this.factory = f; }

    public final Object caseStart(Start node, Object param) throws AttrEvalException  {  
        Object result = null;
        try {
            result = node.getPTestpackage().apply(this, param);
        } catch (AttrEvalException ex) {
            if ( (! ex.hasToken()) && ( this.hasCurrentToken()) ) {
                ex.setToken( this.getCurrentToken() );
            }
            throw ex;
        }
        // node.getEOF().apply(this, param);
        return result;
        // override
    }

    public final Object caseEOF(EOF node, Object param) throws AttrEvalException  {
        return node.apply(this, param);
    }

    public final ITestSuite caseASuiteTestpackage(ASuiteTestpackage node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PTestsuite childTestsuite = node.getTestsuite();
        ITestSuite astTestsuite = null;
        if( childTestsuite != null) {
            if (verbose) System.out.println("   descending into child 'Testsuite' of alternative ASuiteTestpackage... ");
            astTestsuite = (ITestSuite) childTestsuite.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Testsuite'.");
        }
        // create AST node for current CST node here.
        ITestSuite myAst = astTestsuite;
        return myAst;
    }

    public final ITestcase caseATestcaseTestpackage(ATestcaseTestpackage node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PTestcasefile childTestcasefile = node.getTestcasefile();
        ITestcase astTestcasefile = null;
        if( childTestcasefile != null) {
            if (verbose) System.out.println("   descending into child 'Testcasefile' of alternative ATestcaseTestpackage... ");
            astTestcasefile = (ITestcase) childTestcasefile.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Testcasefile'.");
        }
        // create AST node for current CST node here.
        ITestcase myAst = astTestcasefile;
        return myAst;
    }

    public final ITestSuite caseATestsuite(ATestsuite node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PNames childNames = node.getNames();
        ITokenAS astNames = null;
        if( childNames != null) {
            if (verbose) System.out.println("   descending into child 'Names' of alternative ATestsuite... ");
            astNames = (ITokenAS) childNames.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Names'.");
        }
        PPackageDeclaration childPackageDeclaration = node.getPackageDeclaration();
        IPackageDeclaration astPackageDeclaration = null;
        if( childPackageDeclaration != null) {
            if (verbose) System.out.println("   descending into child 'PackageDeclaration' of alternative ATestsuite... ");
            astPackageDeclaration = (IPackageDeclaration) childPackageDeclaration.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'PackageDeclaration'.");
        }
        List astListSuiteElement = new java.util.LinkedList(); // contains ITokenAS instances
        {
            PSuiteElement childSuiteElement = null;
            ITokenAS astSuiteElement = null;
            Object temp[] = node.getSuiteElement().toArray();
            for(int i = 0; i < temp.length; i++) {
                childSuiteElement = (PSuiteElement) temp[i];
                if (verbose) System.out.println("   descending into child 'SuiteElement' of alternative ATestsuite... ");
                astSuiteElement = (ITokenAS) childSuiteElement.apply(this, nodeHrtg.copy());
                if (verbose) System.out.println("   back from 'SuiteElement'.");
                astListSuiteElement.add(astSuiteElement);
            }
        }
        // create AST node for current CST node here.
        ITestSuite myAst = (ITestSuite) factory.createNode("ITestSuite");
        myAst = computeAstFor_ATestsuite(myAst, nodeHrtg,
            astNames,
            astPackageDeclaration,
            astListSuiteElement);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PTestsuite:ATestsuite.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astNames a reference to an instance of class ITokenAS
     * @param  astPackageDeclaration a reference to an instance of class IPackageDeclaration
     * @param  astListSuiteElement a reference to a List of ITokenAS instances
     * @return the initialized AST node, which is an instance of ITestSuite (AST
     * type of production is ITestSuite).
     */
    public abstract ITestSuite computeAstFor_ATestsuite(ITestSuite myAst, Heritage nodeHrtg,
        ITokenAS astNames,
        IPackageDeclaration astPackageDeclaration,
        List astListSuiteElement) throws AttrEvalException;

    public final ITokenAS caseANames(ANames node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TIdent childIdent = node.getIdent();
        ITokenAS astIdent = null;
        if( childIdent != null) {
            if (verbose) System.out.println("   descending into child 'Ident' of alternative ANames... ");
            astIdent = (ITokenAS) childIdent.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Ident'.");
        }
        // create AST node for current CST node here.
        ITokenAS myAst = astIdent;
        return myAst;
    }

    public final ITokenAS caseASuiteElement(ASuiteElement node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TStringLiteral childStringLiteral = node.getStringLiteral();
        ITokenAS astStringLiteral = null;
        if( childStringLiteral != null) {
            if (verbose) System.out.println("   descending into child 'StringLiteral' of alternative ASuiteElement... ");
            astStringLiteral = (ITokenAS) childStringLiteral.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'StringLiteral'.");
        }
        // create AST node for current CST node here.
        ITokenAS myAst = astStringLiteral;
        return myAst;
    }

    public final ITestcase caseATestcasefile(ATestcasefile node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PName childName = node.getName();
        ITokenAS astName = null;
        if( childName != null) {
            if (verbose) System.out.println("   descending into child 'Name' of alternative ATestcasefile... ");
            astName = (ITokenAS) childName.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Name'.");
        }
        PPackageDeclaration childPackageDeclaration = node.getPackageDeclaration();
        IPackageDeclaration astPackageDeclaration = null;
        if( childPackageDeclaration != null) {
            if (verbose) System.out.println("   descending into child 'PackageDeclaration' of alternative ATestcasefile... ");
            astPackageDeclaration = (IPackageDeclaration) childPackageDeclaration.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'PackageDeclaration'.");
        }
        PModelDeclaration childModelDeclaration = node.getModelDeclaration();
        IDeclarationContainer astModelDeclaration = null;
        if( childModelDeclaration != null) {
            if (verbose) System.out.println("   descending into child 'ModelDeclaration' of alternative ATestcasefile... ");
            astModelDeclaration = (IDeclarationContainer) childModelDeclaration.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'ModelDeclaration'.");
        }
        List astListTestcaseElement = new java.util.LinkedList(); // contains ITestcaseElement instances
        {
            PTestcaseElement childTestcaseElement = null;
            ITestcaseElement astTestcaseElement = null;
            Object temp[] = node.getTestcaseElement().toArray();
            for(int i = 0; i < temp.length; i++) {
                childTestcaseElement = (PTestcaseElement) temp[i];
                if (verbose) System.out.println("   descending into child 'TestcaseElement' of alternative ATestcasefile... ");
                astTestcaseElement = (ITestcaseElement) childTestcaseElement.apply(this, nodeHrtg.copy());
                if (verbose) System.out.println("   back from 'TestcaseElement'.");
                astListTestcaseElement.add(astTestcaseElement);
            }
        }
        // create AST node for current CST node here.
        ITestcase myAst = (ITestcase) factory.createNode("ITestcase");
        myAst = computeAstFor_ATestcasefile(myAst, nodeHrtg,
            astName,
            astPackageDeclaration,
            astModelDeclaration,
            astListTestcaseElement);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PTestcasefile:ATestcasefile.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astName a reference to an instance of class ITokenAS
     * @param  astPackageDeclaration a reference to an instance of class IPackageDeclaration
     * @param  astModelDeclaration a reference to an instance of class IDeclarationContainer
     * @param  astListTestcaseElement a reference to a List of ITestcaseElement instances
     * @return the initialized AST node, which is an instance of ITestcase (AST
     * type of production is ITestcase).
     */
    public abstract ITestcase computeAstFor_ATestcasefile(ITestcase myAst, Heritage nodeHrtg,
        ITokenAS astName,
        IPackageDeclaration astPackageDeclaration,
        IDeclarationContainer astModelDeclaration,
        List astListTestcaseElement) throws AttrEvalException;

    public final ITokenAS caseAName(AName node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TIdent childIdent = node.getIdent();
        ITokenAS astIdent = null;
        if( childIdent != null) {
            if (verbose) System.out.println("   descending into child 'Ident' of alternative AName... ");
            astIdent = (ITokenAS) childIdent.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Ident'.");
        }
        // create AST node for current CST node here.
        ITokenAS myAst = astIdent;
        return myAst;
    }

    public final IPackageDeclaration caseAPackageDeclaration(APackageDeclaration node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TPackageName childPackageName = node.getPackageName();
        ITokenAS astPackageName = null;
        if( childPackageName != null) {
            if (verbose) System.out.println("   descending into child 'PackageName' of alternative APackageDeclaration... ");
            astPackageName = (ITokenAS) childPackageName.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'PackageName'.");
        }
        // create AST node for current CST node here.
        IPackageDeclaration myAst = (IPackageDeclaration) factory.createNode("IPackageDeclaration");
        myAst = computeAstFor_APackageDeclaration(myAst, nodeHrtg,
            astPackageName);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PPackageDeclaration:APackageDeclaration.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astPackageName a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of IPackageDeclaration (AST
     * type of production is IPackageDeclaration).
     */
    public abstract IPackageDeclaration computeAstFor_APackageDeclaration(IPackageDeclaration myAst, Heritage nodeHrtg,
        ITokenAS astPackageName) throws AttrEvalException;

    public final IDeclarationContainer caseAMetamodelModelDeclaration(AMetamodelModelDeclaration node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PMetamodelDesc childMetamodelDesc = node.getMetamodelDesc();
        IMetamodelReference astMetamodelDesc = null;
        if( childMetamodelDesc != null) {
            if (verbose) System.out.println("   descending into child 'MetamodelDesc' of alternative AMetamodelModelDeclaration... ");
            astMetamodelDesc = (IMetamodelReference) childMetamodelDesc.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'MetamodelDesc'.");
        }
        PModelDesc childModelDesc = node.getModelDesc();
        IModelReference astModelDesc = null;
        if( childModelDesc != null) {
            if (verbose) System.out.println("   descending into child 'ModelDesc' of alternative AMetamodelModelDeclaration... ");
            astModelDesc = (IModelReference) childModelDesc.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'ModelDesc'.");
        }
        // create AST node for current CST node here.
        IDeclarationContainer myAst = (IDeclarationContainer) factory.createNode("IDeclarationContainer");
        myAst = computeAstFor_AMetamodelModelDeclaration(myAst, nodeHrtg,
            astMetamodelDesc,
            astModelDesc);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PModelDeclaration:AMetamodelModelDeclaration.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astMetamodelDesc a reference to an instance of class IMetamodelReference
     * @param  astModelDesc a reference to an instance of class IModelReference
     * @return the initialized AST node, which is an instance of IDeclarationContainer (AST
     * type of production is IDeclarationContainer).
     */
    public abstract IDeclarationContainer computeAstFor_AMetamodelModelDeclaration(IDeclarationContainer myAst, Heritage nodeHrtg,
        IMetamodelReference astMetamodelDesc,
        IModelReference astModelDesc) throws AttrEvalException;

    public final IDeclarationContainer caseAModelModelDeclaration(AModelModelDeclaration node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PModelDesc childModelDesc = node.getModelDesc();
        IModelReference astModelDesc = null;
        if( childModelDesc != null) {
            if (verbose) System.out.println("   descending into child 'ModelDesc' of alternative AModelModelDeclaration... ");
            astModelDesc = (IModelReference) childModelDesc.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'ModelDesc'.");
        }
        PMetamodelDesc childMetamodelDesc = node.getMetamodelDesc();
        IMetamodelReference astMetamodelDesc = null;
        if( childMetamodelDesc != null) {
            if (verbose) System.out.println("   descending into child 'MetamodelDesc' of alternative AModelModelDeclaration... ");
            astMetamodelDesc = (IMetamodelReference) childMetamodelDesc.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'MetamodelDesc'.");
        }
        // create AST node for current CST node here.
        IDeclarationContainer myAst = (IDeclarationContainer) factory.createNode("IDeclarationContainer");
        myAst = computeAstFor_AModelModelDeclaration(myAst, nodeHrtg,
            astModelDesc,
            astMetamodelDesc);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PModelDeclaration:AModelModelDeclaration.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astModelDesc a reference to an instance of class IModelReference
     * @param  astMetamodelDesc a reference to an instance of class IMetamodelReference
     * @return the initialized AST node, which is an instance of IDeclarationContainer (AST
     * type of production is IDeclarationContainer).
     */
    public abstract IDeclarationContainer computeAstFor_AModelModelDeclaration(IDeclarationContainer myAst, Heritage nodeHrtg,
        IModelReference astModelDesc,
        IMetamodelReference astMetamodelDesc) throws AttrEvalException;

    public final IMetamodelReference caseAMetamodelDesc(AMetamodelDesc node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TPackageName childPackageName = node.getPackageName();
        ITokenAS astPackageName = null;
        if( childPackageName != null) {
            if (verbose) System.out.println("   descending into child 'PackageName' of alternative AMetamodelDesc... ");
            astPackageName = (ITokenAS) childPackageName.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'PackageName'.");
        }
        // create AST node for current CST node here.
        IMetamodelReference myAst = (IMetamodelReference) factory.createNode("IMetamodelReference");
        myAst = computeAstFor_AMetamodelDesc(myAst, nodeHrtg,
            astPackageName);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PMetamodelDesc:AMetamodelDesc.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astPackageName a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of IMetamodelReference (AST
     * type of production is IMetamodelReference).
     */
    public abstract IMetamodelReference computeAstFor_AMetamodelDesc(IMetamodelReference myAst, Heritage nodeHrtg,
        ITokenAS astPackageName) throws AttrEvalException;

    public final IModelReference caseAModelDesc(AModelDesc node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TStringLiteral childStringLiteral = node.getStringLiteral();
        ITokenAS astStringLiteral = null;
        if( childStringLiteral != null) {
            if (verbose) System.out.println("   descending into child 'StringLiteral' of alternative AModelDesc... ");
            astStringLiteral = (ITokenAS) childStringLiteral.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'StringLiteral'.");
        }
        // create AST node for current CST node here.
        IModelReference myAst = (IModelReference) factory.createNode("IModelReference");
        myAst = computeAstFor_AModelDesc(myAst, nodeHrtg,
            astStringLiteral);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PModelDesc:AModelDesc.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astStringLiteral a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of IModelReference (AST
     * type of production is IModelReference).
     */
    public abstract IModelReference computeAstFor_AModelDesc(IModelReference myAst, Heritage nodeHrtg,
        ITokenAS astStringLiteral) throws AttrEvalException;

    public final ITestcaseElement caseATestcaseElement(ATestcaseElement node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PTestcasename childTestcasename = node.getTestcasename();
        ITokenAS astTestcasename = null;
        if( childTestcasename != null) {
            if (verbose) System.out.println("   descending into child 'Testcasename' of alternative ATestcaseElement... ");
            astTestcasename = (ITokenAS) childTestcasename.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Testcasename'.");
        }
        POclExpression childOclExpression = node.getOclExpression();
        ITokenAS astOclExpression = null;
        if( childOclExpression != null) {
            if (verbose) System.out.println("   descending into child 'OclExpression' of alternative ATestcaseElement... ");
            astOclExpression = (ITokenAS) childOclExpression.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'OclExpression'.");
        }
        PResult childResult = node.getResult();
        IResult astResult = null;
        if( childResult != null) {
            if (verbose) System.out.println("   descending into child 'Result' of alternative ATestcaseElement... ");
            astResult = (IResult) childResult.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Result'.");
        }
        // create AST node for current CST node here.
        ITestcaseElement myAst = (ITestcaseElement) factory.createNode("ITestcaseElement");
        myAst = computeAstFor_ATestcaseElement(myAst, nodeHrtg,
            astTestcasename,
            astOclExpression,
            astResult);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PTestcaseElement:ATestcaseElement.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astTestcasename a reference to an instance of class ITokenAS
     * @param  astOclExpression a reference to an instance of class ITokenAS
     * @param  astResult a reference to an instance of class IResult
     * @return the initialized AST node, which is an instance of ITestcaseElement (AST
     * type of production is ITestcaseElement).
     */
    public abstract ITestcaseElement computeAstFor_ATestcaseElement(ITestcaseElement myAst, Heritage nodeHrtg,
        ITokenAS astTestcasename,
        ITokenAS astOclExpression,
        IResult astResult) throws AttrEvalException;

    public final ITokenAS caseATestcasename(ATestcasename node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TIdent childIdent = node.getIdent();
        ITokenAS astIdent = null;
        if( childIdent != null) {
            if (verbose) System.out.println("   descending into child 'Ident' of alternative ATestcasename... ");
            astIdent = (ITokenAS) childIdent.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Ident'.");
        }
        // create AST node for current CST node here.
        ITokenAS myAst = astIdent;
        return myAst;
    }

    public final ITokenAS caseAOclExpression(AOclExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TOclblock childOclblock = node.getOclblock();
        ITokenAS astOclblock = null;
        if( childOclblock != null) {
            if (verbose) System.out.println("   descending into child 'Oclblock' of alternative AOclExpression... ");
            astOclblock = (ITokenAS) childOclblock.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Oclblock'.");
        }
        // create AST node for current CST node here.
        ITokenAS myAst = astOclblock;
        return myAst;
    }

    public final IAbstractModel caseAAbstractmodelResult(AAbstractmodelResult node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PAbstractModel childAbstractModel = node.getAbstractModel();
        IAbstractModel astAbstractModel = null;
        if( childAbstractModel != null) {
            if (verbose) System.out.println("   descending into child 'AbstractModel' of alternative AAbstractmodelResult... ");
            astAbstractModel = (IAbstractModel) childAbstractModel.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'AbstractModel'.");
        }
        // create AST node for current CST node here.
        IAbstractModel myAst = astAbstractModel;
        return myAst;
    }

    public final IErrorElement caseAErrorResult(AErrorResult node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TError childError = node.getError();
        ITokenAS astError = null;
        if( childError != null) {
            if (verbose) System.out.println("   descending into child 'Error' of alternative AErrorResult... ");
            astError = (ITokenAS) childError.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Error'.");
        }
        // create AST node for current CST node here.
        IErrorElement myAst = (IErrorElement) factory.createNode("IErrorElement");
        myAst = computeAstFor_AErrorResult(myAst, nodeHrtg,
            astError);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PResult:AErrorResult.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astError a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of IErrorElement (AST
     * type of production is IResult).
     */
    public abstract IErrorElement computeAstFor_AErrorResult(IErrorElement myAst, Heritage nodeHrtg,
        ITokenAS astError) throws AttrEvalException;

    public final IAbstractModel caseAAbstractModel(AAbstractModel node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TAbstractmodel childAbstractmodel = node.getAbstractmodel();
        ITokenAS astAbstractmodel = null;
        if( childAbstractmodel != null) {
            if (verbose) System.out.println("   descending into child 'Abstractmodel' of alternative AAbstractModel... ");
            astAbstractmodel = (ITokenAS) childAbstractmodel.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Abstractmodel'.");
        }
        TFirstName childFirstName = node.getFirstName();
        ITokenAS astFirstName = null;
        if( childFirstName != null) {
            if (verbose) System.out.println("   descending into child 'FirstName' of alternative AAbstractModel... ");
            astFirstName = (ITokenAS) childFirstName.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'FirstName'.");
        }
        PModelExpression childModelExpression = node.getModelExpression();
        IModelExpression astModelExpression = null;
        if( childModelExpression != null) {
            if (verbose) System.out.println("   descending into child 'ModelExpression' of alternative AAbstractModel... ");
            astModelExpression = (IModelExpression) childModelExpression.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'ModelExpression'.");
        }
        List astListAssignment = new java.util.LinkedList(); // contains IVariable instances
        {
            PAssignment childAssignment = null;
            IVariable astAssignment = null;
            Object temp[] = node.getAssignment().toArray();
            for(int i = 0; i < temp.length; i++) {
                childAssignment = (PAssignment) temp[i];
                if (verbose) System.out.println("   descending into child 'Assignment' of alternative AAbstractModel... ");
                astAssignment = (IVariable) childAssignment.apply(this, nodeHrtg.copy());
                if (verbose) System.out.println("   back from 'Assignment'.");
                astListAssignment.add(astAssignment);
            }
        }
        // create AST node for current CST node here.
        IAbstractModel myAst = (IAbstractModel) factory.createNode("IAbstractModel");
        myAst = computeAstFor_AAbstractModel(myAst, nodeHrtg,
            astAbstractmodel,
            astFirstName,
            astModelExpression,
            astListAssignment);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PAbstractModel:AAbstractModel.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astAbstractmodel a reference to an instance of class ITokenAS
     * @param  astFirstName a reference to an instance of class ITokenAS
     * @param  astModelExpression a reference to an instance of class IModelExpression
     * @param  astListAssignment a reference to a List of IVariable instances
     * @return the initialized AST node, which is an instance of IAbstractModel (AST
     * type of production is IAbstractModel).
     */
    public abstract IAbstractModel computeAstFor_AAbstractModel(IAbstractModel myAst, Heritage nodeHrtg,
        ITokenAS astAbstractmodel,
        ITokenAS astFirstName,
        IModelExpression astModelExpression,
        List astListAssignment) throws AttrEvalException;

    public final IVariable caseAAssignment(AAssignment node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TIdent childIdent = node.getIdent();
        ITokenAS astIdent = null;
        if( childIdent != null) {
            if (verbose) System.out.println("   descending into child 'Ident' of alternative AAssignment... ");
            astIdent = (ITokenAS) childIdent.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Ident'.");
        }
        PModelExpression childModelExpression = node.getModelExpression();
        IModelExpression astModelExpression = null;
        if( childModelExpression != null) {
            if (verbose) System.out.println("   descending into child 'ModelExpression' of alternative AAssignment... ");
            astModelExpression = (IModelExpression) childModelExpression.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'ModelExpression'.");
        }
        // create AST node for current CST node here.
        IVariable myAst = (IVariable) factory.createNode("IVariable");
        myAst = computeAstFor_AAssignment(myAst, nodeHrtg,
            astIdent,
            astModelExpression);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PAssignment:AAssignment.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astIdent a reference to an instance of class ITokenAS
     * @param  astModelExpression a reference to an instance of class IModelExpression
     * @return the initialized AST node, which is an instance of IVariable (AST
     * type of production is IVariable).
     */
    public abstract IVariable computeAstFor_AAssignment(IVariable myAst, Heritage nodeHrtg,
        ITokenAS astIdent,
        IModelExpression astModelExpression) throws AttrEvalException;

    public final IModelExpression caseAModelelementModelExpression(AModelelementModelExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TIdent childIdent = node.getIdent();
        ITokenAS astIdent = null;
        if( childIdent != null) {
            if (verbose) System.out.println("   descending into child 'Ident' of alternative AModelelementModelExpression... ");
            astIdent = (ITokenAS) childIdent.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Ident'.");
        }
        PParameters childParameters = node.getParameters();
        List astParameters = null;
        if( childParameters != null) {
            if (verbose) System.out.println("   descending into child 'Parameters' of alternative AModelelementModelExpression... ");
            astParameters = (List) childParameters.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Parameters'.");
        }
        // create AST node for current CST node here.
        IModelExpression myAst = computeAstFor_AModelelementModelExpression(nodeHrtg,
            astIdent,
            astParameters);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PModelExpression:AModelelementModelExpression.
     * The implementation of this method must create an AST node of the correct
     * type <b>and</b> set all attributes and associations as required by the OCL
     * specification.
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astIdent a reference to an instance of class ITokenAS
     * @param  astParameters a reference to an instance of class List
     * @return the initialized AST node, which is an instance of IModelExpression (AST
     * type of production is IModelExpression).
     */
    public abstract IModelExpression computeAstFor_AModelelementModelExpression(Heritage nodeHrtg,
        ITokenAS astIdent,
        List astParameters) throws AttrEvalException;

    public final IVariable caseAIdentModelExpression(AIdentModelExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TIdent childIdent = node.getIdent();
        ITokenAS astIdent = null;
        if( childIdent != null) {
            if (verbose) System.out.println("   descending into child 'Ident' of alternative AIdentModelExpression... ");
            astIdent = (ITokenAS) childIdent.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Ident'.");
        }
        // create AST node for current CST node here.
        IVariable myAst = (IVariable) factory.createNode("IVariable");
        myAst = computeAstFor_AIdentModelExpression(myAst, nodeHrtg,
            astIdent);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PModelExpression:AIdentModelExpression.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astIdent a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of IVariable (AST
     * type of production is IModelExpression).
     */
    public abstract IVariable computeAstFor_AIdentModelExpression(IVariable myAst, Heritage nodeHrtg,
        ITokenAS astIdent) throws AttrEvalException;

    public final INullElement caseANullModelExpression(ANullModelExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TNull childNull = node.getNull();
        ITokenAS astNull = null;
        if( childNull != null) {
            if (verbose) System.out.println("   descending into child 'Null' of alternative ANullModelExpression... ");
            astNull = (ITokenAS) childNull.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Null'.");
        }
        // create AST node for current CST node here.
        INullElement myAst = (INullElement) factory.createNode("INullElement");
        myAst = computeAstFor_ANullModelExpression(myAst, nodeHrtg,
            astNull);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PModelExpression:ANullModelExpression.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astNull a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of INullElement (AST
     * type of production is IModelExpression).
     */
    public abstract INullElement computeAstFor_ANullModelExpression(INullElement myAst, Heritage nodeHrtg,
        ITokenAS astNull) throws AttrEvalException;

    public final ISimpleElement caseASimpleModelExpression(ASimpleModelExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PSimpleExpression childSimpleExpression = node.getSimpleExpression();
        ISimpleElement astSimpleExpression = null;
        if( childSimpleExpression != null) {
            if (verbose) System.out.println("   descending into child 'SimpleExpression' of alternative ASimpleModelExpression... ");
            astSimpleExpression = (ISimpleElement) childSimpleExpression.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'SimpleExpression'.");
        }
        // create AST node for current CST node here.
        ISimpleElement myAst = astSimpleExpression;
        return myAst;
    }

    public final IModelExpression caseANewModelExpression(ANewModelExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TIdent childIdent = node.getIdent();
        ITokenAS astIdent = null;
        if( childIdent != null) {
            if (verbose) System.out.println("   descending into child 'Ident' of alternative ANewModelExpression... ");
            astIdent = (ITokenAS) childIdent.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Ident'.");
        }
        PParameters childParameters = node.getParameters();
        List astParameters = null;
        if( childParameters != null) {
            if (verbose) System.out.println("   descending into child 'Parameters' of alternative ANewModelExpression... ");
            astParameters = (List) childParameters.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Parameters'.");
        }
        // create AST node for current CST node here.
        IModelExpression myAst = computeAstFor_ANewModelExpression(nodeHrtg,
            astIdent,
            astParameters);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PModelExpression:ANewModelExpression.
     * The implementation of this method must create an AST node of the correct
     * type <b>and</b> set all attributes and associations as required by the OCL
     * specification.
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astIdent a reference to an instance of class ITokenAS
     * @param  astParameters a reference to an instance of class List
     * @return the initialized AST node, which is an instance of IModelExpression (AST
     * type of production is IModelExpression).
     */
    public abstract IModelExpression computeAstFor_ANewModelExpression(Heritage nodeHrtg,
        ITokenAS astIdent,
        List astParameters) throws AttrEvalException;

    public final IRealElement caseARealSimpleExpression(ARealSimpleExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TRealValue childRealValue = node.getRealValue();
        ITokenAS astRealValue = null;
        if( childRealValue != null) {
            if (verbose) System.out.println("   descending into child 'RealValue' of alternative ARealSimpleExpression... ");
            astRealValue = (ITokenAS) childRealValue.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'RealValue'.");
        }
        // create AST node for current CST node here.
        IRealElement myAst = (IRealElement) factory.createNode("IRealElement");
        myAst = computeAstFor_ARealSimpleExpression(myAst, nodeHrtg,
            astRealValue);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PSimpleExpression:ARealSimpleExpression.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astRealValue a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of IRealElement (AST
     * type of production is ISimpleElement).
     */
    public abstract IRealElement computeAstFor_ARealSimpleExpression(IRealElement myAst, Heritage nodeHrtg,
        ITokenAS astRealValue) throws AttrEvalException;

    public final IIntegerElement caseAIntegerSimpleExpression(AIntegerSimpleExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TIntegerValue childIntegerValue = node.getIntegerValue();
        ITokenAS astIntegerValue = null;
        if( childIntegerValue != null) {
            if (verbose) System.out.println("   descending into child 'IntegerValue' of alternative AIntegerSimpleExpression... ");
            astIntegerValue = (ITokenAS) childIntegerValue.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'IntegerValue'.");
        }
        // create AST node for current CST node here.
        IIntegerElement myAst = (IIntegerElement) factory.createNode("IIntegerElement");
        myAst = computeAstFor_AIntegerSimpleExpression(myAst, nodeHrtg,
            astIntegerValue);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PSimpleExpression:AIntegerSimpleExpression.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astIntegerValue a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of IIntegerElement (AST
     * type of production is ISimpleElement).
     */
    public abstract IIntegerElement computeAstFor_AIntegerSimpleExpression(IIntegerElement myAst, Heritage nodeHrtg,
        ITokenAS astIntegerValue) throws AttrEvalException;

    public final IStringElement caseAStringSimpleExpression(AStringSimpleExpression node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        TStringLiteral childStringLiteral = node.getStringLiteral();
        ITokenAS astStringLiteral = null;
        if( childStringLiteral != null) {
            if (verbose) System.out.println("   descending into child 'StringLiteral' of alternative AStringSimpleExpression... ");
            astStringLiteral = (ITokenAS) childStringLiteral.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'StringLiteral'.");
        }
        // create AST node for current CST node here.
        IStringElement myAst = (IStringElement) factory.createNode("IStringElement");
        myAst = computeAstFor_AStringSimpleExpression(myAst, nodeHrtg,
            astStringLiteral);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PSimpleExpression:AStringSimpleExpression.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astStringLiteral a reference to an instance of class ITokenAS
     * @return the initialized AST node, which is an instance of IStringElement (AST
     * type of production is ISimpleElement).
     */
    public abstract IStringElement computeAstFor_AStringSimpleExpression(IStringElement myAst, Heritage nodeHrtg,
        ITokenAS astStringLiteral) throws AttrEvalException;

    public final IModelExpression caseAElementParameter(AElementParameter node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PParameter childParameter = node.getParameter();
        IModelExpression astParameter = null;
        if( childParameter != null) {
            if (verbose) System.out.println("   descending into child 'Parameter' of alternative AElementParameter... ");
            astParameter = (IModelExpression) childParameter.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Parameter'.");
        }
        // create AST node for current CST node here.
        IModelExpression myAst = astParameter;
        return myAst;
    }

    public final List caseASingleParameters(ASingleParameters node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PParameter childParameter = node.getParameter();
        IModelExpression astParameter = null;
        if( childParameter != null) {
            if (verbose) System.out.println("   descending into child 'Parameter' of alternative ASingleParameters... ");
            astParameter = (IModelExpression) childParameter.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Parameter'.");
        }
        // create AST node for current CST node here.
        List myAst = (List) factory.createNode("List");
        myAst = computeAstFor_ASingleParameters(myAst, nodeHrtg,
            astParameter);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PParameters:ASingleParameters.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astParameter a reference to an instance of class IModelExpression
     * @return the initialized AST node, which is an instance of List (AST
     * type of production is List).
     */
    public abstract List computeAstFor_ASingleParameters(List myAst, Heritage nodeHrtg,
        IModelExpression astParameter) throws AttrEvalException;

    public final List caseAMultipleParameters(AMultipleParameters node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PParameter childParameter = node.getParameter();
        IModelExpression astParameter = null;
        if( childParameter != null) {
            if (verbose) System.out.println("   descending into child 'Parameter' of alternative AMultipleParameters... ");
            astParameter = (IModelExpression) childParameter.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Parameter'.");
        }
        PParameters childParameters = node.getParameters();
        List astParameters = null;
        if( childParameters != null) {
            if (verbose) System.out.println("   descending into child 'Parameters' of alternative AMultipleParameters... ");
            astParameters = (List) childParameters.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'Parameters'.");
        }
        // create AST node for current CST node here.
        List myAst = (List) factory.createNode("List");
        myAst = computeAstFor_AMultipleParameters(myAst, nodeHrtg,
            astParameter,
            astParameters);
        return myAst;
    }
    
    /**
     * Constructs AST node for alternative PParameters:AMultipleParameters.
     * The  parser  passes  an  empty AST  node  of  the  correct  type  and the
     * implementation of this method must  set all  attributes and  associations
     * as required by the OCL specification.
     * @param myAst the prepared AST node, which has to be filled by the 
     *        implementation
     * @param nodeHrtg the inherited attributes inherited from the parent node,
     *        contained in an instance of type Heritage
     * @param  astParameter a reference to an instance of class IModelExpression
     * @param  astParameters a reference to an instance of class List
     * @return the initialized AST node, which is an instance of List (AST
     * type of production is List).
     */
    public abstract List computeAstFor_AMultipleParameters(List myAst, Heritage nodeHrtg,
        IModelExpression astParameter,
        List astParameters) throws AttrEvalException;

    public final IModelExpression caseAExpressionParameter(AExpressionParameter node, Object param) throws AttrEvalException { 
        Heritage nodeHrtg = (Heritage) param;
        Heritage childHrtg = null;

        PModelExpression childModelExpression = node.getModelExpression();
        IModelExpression astModelExpression = null;
        if( childModelExpression != null) {
            if (verbose) System.out.println("   descending into child 'ModelExpression' of alternative AExpressionParameter... ");
            astModelExpression = (IModelExpression) childModelExpression.apply(this, nodeHrtg.copy());
            if (verbose) System.out.println("   back from 'ModelExpression'.");
        }
        // create AST node for current CST node here.
        IModelExpression myAst = astModelExpression;
        return myAst;
    }

    public final String caseTTick(TTick node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTNew(TNew node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final ITokenAS caseTNull(TNull node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TNull(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TNull(TNull node, Heritage nodeHrtg) throws AttrEvalException;

    public final String caseTNewLine(TNewLine node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTBlank(TBlank node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTPackage(TPackage node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTMetamodel(TMetamodel node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTModel(TModel node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTInclude(TInclude node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTTestname(TTestname node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTSuitename(TSuitename node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTBraceOpen(TBraceOpen node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTBraceClose(TBraceClose node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final ITokenAS caseTError(TError node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TError(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TError(TError node, Heritage nodeHrtg) throws AttrEvalException;

    public final String caseTAssign(TAssign node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTComma(TComma node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final ITokenAS caseTFirstName(TFirstName node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TFirstName(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TFirstName(TFirstName node, Heritage nodeHrtg) throws AttrEvalException;

    public final String caseTColon(TColon node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTOpenparen(TOpenparen node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTCloseparen(TCloseparen node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTTestcase(TTestcase node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final ITokenAS caseTAbstractmodel(TAbstractmodel node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TAbstractmodel(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TAbstractmodel(TAbstractmodel node, Heritage nodeHrtg) throws AttrEvalException;

    public final String caseTOclexpression(TOclexpression node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final ITokenAS caseTRealValue(TRealValue node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TRealValue(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TRealValue(TRealValue node, Heritage nodeHrtg) throws AttrEvalException;

    public final ITokenAS caseTIntegerValue(TIntegerValue node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TIntegerValue(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TIntegerValue(TIntegerValue node, Heritage nodeHrtg) throws AttrEvalException;

    public final ITokenAS caseTIdent(TIdent node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TIdent(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TIdent(TIdent node, Heritage nodeHrtg) throws AttrEvalException;

    public final ITokenAS caseTPackageName(TPackageName node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TPackageName(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TPackageName(TPackageName node, Heritage nodeHrtg) throws AttrEvalException;

    public final String caseTCommentblock(TCommentblock node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final String caseTCommentline(TCommentline node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.println("default token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        return node.getText();
    }

    public final ITokenAS caseTOclblock(TOclblock node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TOclblock(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TOclblock(TOclblock node, Heritage nodeHrtg) throws AttrEvalException;

    public final ITokenAS caseTStringLiteral(TStringLiteral node, Object param) throws AttrEvalException {
        Token curTk = (Token) node;
        if (verbose) System.out.print("custom token: '" + curTk.getText() + "', at " + curTk.getLine() + ":" + curTk.getPos() +"...  ");
        this.setCurrentToken(curTk);
        ITokenAS result = createNodeFor_TStringLiteral(node, (Heritage) param);
        if (verbose) System.out.println("token node created.");
        return result;
    }
    public abstract ITokenAS createNodeFor_TStringLiteral(TStringLiteral node, Heritage nodeHrtg) throws AttrEvalException;
}
