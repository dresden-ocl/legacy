\section{Lessons Learnt}
\label{sec:lessons}

  In this section we highlight some problems that occurred during the design
  and implementation of our generic adaptation architecture for DresdenOCL.
  We present our solutions to these challenges and possible improvements.

	\paragraph{Type Matching}
	As models and model instances are only loosely 
	coupled, model instance elements must be matched to a model type
	when they are imported into DresdenOCL. Currently, this type matching is realised by a simple type name match (including the names of 
	their enclosing namespaces where possible). E.g., the Java class \texttt{LoyaltyAccount} is
	matched to the UML class \texttt{LoyaltyAccount} in the royal and loyal class diagram.
	This matching algorithm can be rather complex and often information is hidden inside the adapters that could be 
	used to improve the matching. E.g., when adapting an instance of an EMF 
	Ecore model, one could use the \emph{Generator Model} provided by Ecore to
	retrieve further type matching information. We plan to improve this process
	that is currently scattered over multiple classes of each model instance 
	adapter component by introducing type matching strategies that 
	can be implemented using the \emph{Chain of Responsibility} 
	pattern \cite{gamma:dp}. The chain could start by trying to match the 
	types using an implementation specific matcher and end by trying to 
	simply match the type names as currently done.
	
	\paragraph{Element Unwrapping}
	Another problem when using adapters for Model Instance Types 
	is the unwrapping mechanism of adapted elements when invoking operations 
	on the \texttt{ModelInstanceElements}. E.g., to invoke an operation of a Java 
	implementation we require \texttt{java.lang.Objects} as parameters instead of 
	\texttt{ModelInstanceElements}. This unwrapping mechanism is easy 
	for elements that have been adapted before, as they simply can be unwrapped 
	again. Unfortunately, during interpretation of OCL constraints, 
	new instances of primitive types or new collections can be created 
	by the standard library (e.g., when invoking the OCL operation \texttt{size()} on a collection that 
	returns an \texttt{Integer} instance). Thus, a 
	model instance adapter has to provide operations to reconvert 
	primitive types and collections into elements of the adapted model 
	instances. In some cases this can become rather complicated as 
	the adaptation between types of the instance and the model 
	instance type interfaces has not to be bijective. For 
	example, Java \texttt{ints} and \texttt{java.lang.Integers} are 
	both mapped to \texttt{ModelInstaceIntegers}. During unwrapping, 
	the Java model instance adapter component has to reflect 
	whether the method to invoke requires an \texttt{int}, an 
	\texttt{Integer} or another Java integer-like type instance.
	The unwrapping mechanism of an adapted instance 
	can be considered as the most complicated and error-prone part 
	of the complete model instance adaptation.
	Fortunately, model instances providing only structural information do not
	need this unwrapping mechanism as operations do not exist at all.

	\paragraph{Automated Adapter Creation}
	The adaptation process of models and model 
	instances contains parts that are similar 
	for each adaptation and thus can be automated.
	To improve the model adaptation process, we developed a code generator 
	for the adaptation of model adapter components. The code 
	generator requires an annotated meta-model describing
	the relation of meta-model concepts to the Model Types (e.g., the UML2 meta-class
	\texttt{Classifier} is annotated as a \texttt{Type}). 
	The code generator generates the skeleton code for all required 
	adapters that has to be completed manually.
	For the Model Instance Types, such a code generator is currently 
	missing, but could be implemented as well.
	
	\paragraph{Adaptation Testing}
	We developed two generic JUnit test suites, 
	that can be used to test the adaptation of a model 
	or model instance, respectively. 
	The test suites are initialised with a model or model instance that
	contains all the adapted concepts that shall be tested.
	The test suites then check if all required methods to 
	retrieve \texttt{Types}, \texttt{Operations}, \texttt{Properties} for the variation point VP1 are implemented appropriately.
	The reflection mechanism provided by variation point VP2 is tested as well.
	These generic test suites helped us to ensure 
	that all existing adaptations behave in the same expected manner
	and to easily detect wrong adaptations of some elements.
	Furthermore, these test suites can be used to ensure the absence of specific
	bugs in all adaptations by adding new test cases if such a bug is detected in one of the adaptations.