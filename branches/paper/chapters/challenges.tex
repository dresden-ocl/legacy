\section{Challenges \change{in Generic}{of a Variable} OCL Infrastructure\remove{s}}

\note{Michael: Is it a ``generic adapter architecture'' or do we have another name including ``variability''?}
  In this section we highlight some problems that occurred during the design
  and implementation of our generic adapter architecture for an OCL infrastructure.
  We also present some solutions to these challenges.

	\paragraph{Type Matching}
	As \remove{mentioned above, }models and model implementations are only loosely 
	coupled\change{. M}{, m}odel instance elements must be matched to a model type
	when they are imported into DresdenOCL. Currently, this type matching is realised by \change{simply 
	matching the names of the types}{a simple type name match} (including the names of 
	their enclosing namespaces where possible). E.g., the Java class \texttt{LoyaltyAccount} is
	matched to the class \texttt{LoyaltyAccount} in the royal and loyal class diagram.
	Often, this solution is error prone \note{Michael: this sounds a little bit exaggerated} and further information is hidden behind the adapters that could be 
	used to improve the matching. E.g., when adapting an instance of an EMF 
	Ecore model, one could use the reflection mechanisms provided by Ecore to
	retrieve the types of EObjects. We plan to improve our matching
	that is currently scattered over multiple classes of each model instance 
	adapter component \remove{and }by introducing type matching strategies that 
	can be implemented using the \emph{Chain of Responsibility} 
	pattern \cite{gamma:dp}. The chain could start by trying to match the 
	types using an implementation specific matcher and end by trying to 
	simply match the type names as currently done.
	
	\paragraph{Element Unwrapping}
	Another problem when using adapters for model instance types 
	is the unwrapping mechanism of adapted elements when invoking operations 
	on the \texttt{ModelInstanceElements}. E.g., to invoke an operation of a Java 
	implementation we require \texttt{java.lang.Objects} as parameters instead of 
	\texttt{ModelInstanceElements}. This unwrapping mechanism is easy 
	where elements that have been adapted before are simply unwrapped 
	again. Unfortunately, during interpretation of OCL constraints, 
	new instances of primitive types or new collections can be created 
	(e.g., when invoking the OCL operation \texttt{size() \add{on a collection}} that 
	returns an \texttt{Integer} instance). Thus, a 
	model instance adapter has to provide operations to reconvert 
	primitive types and collections to elements of the adapted model 
	instances. In some cases this can become rather complicated because 
	the adaptation between types of the instance and the model 
	instance type interfaces has not to be bijective. For 
	example, Java \texttt{ints} and \texttt{java.lang.Integers} are 
	both mapped to \texttt{ModelInstaceIntegers}. During unwrapping, 
	the Java model instance adapter component has to reflect 
	whether the method to invoke requires an \texttt{int}, an 
	\texttt{Integer} or another Java integer-like type instance.
	The unwrapping mechanism of an adapted instance 
	can be considered as the most complicated and error-prone part 
	of the complete model instance adaptation.

	\paragraph{Automated Adapter Creation}
	\remove{Adapting different types of meta-models, models, and model
	instances enables the reuse of DrescenOCL for various combinations
	of modelling and implementation languages.}
	\change{Nevertheless, the}{The} adaptation process \add{of models and model 
	instances} contains parts that are similar 
	for each adaptation and thus can be automated.
	To improve the model adaptation process, we developed a code generator 
	for the adaptation of meta-models to the model type concepts. The code 
	generator requires an annotated meta-model describing
	the relation of meta-model concepts to the model type concepts.
	E.g., the UML2 meta-class \texttt{Classifier} is annotated as a \texttt{Type} concept. 
	The code generator generates the skeleton code for all required 
	adapters and thus avoids manual implementation of these adapters. 
	For the model instance types, such a code generator is currently 
	missing but could be implemented as well.
	
	\paragraph{Adaptation Testing}
	We developed two generic JUnit test suites, 
	that can be used to test the adaptation of a model 
	or model instance, respectively. 
	The test suites are initialized with a model or model instance that
	contains all the adapted concepts that shall be tested.
	The test suites then check if all required methods to 
	retrieve \texttt{Types}, \texttt{Operations}, \texttt{Properties} etc. are implemented 
	appropriately. These generic test suites helped us to ensure 
	that all existing adaptations behave in the same expected manner
	and to easily detect wrong adaptations of some elements.
	Furthermore, these test suites can be used to ensure the absence of specific
	bugs in all adaptations if such a bug is detected in one of the adaptations by adding new test cases.