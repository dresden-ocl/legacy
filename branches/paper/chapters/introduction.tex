\section{Introduction}

	Model-Driven Software Development (MDSD) aims to abstract from concrete 
	software implementations and uses modelling languages to describe 
	software systems. To ensure consistency of models, the Object Constraint Language 
	(OCL) \cite{spec:OCL2-2} has been developed as an extension of the Unified 
	Modelling Language (UML) \cite{spec:UML2-2}. In recent years, OCL has been 
	applied to various 
	%other modelling languages like MOF \cite{oclExample:mof}, 
	%Ecore \cite{oclExample:ecore} 	and 
	Domain Specific Languages (DSLs) \cite{oclExample:DSL}. 

	OCL can be
	defined and used as a constraint language in combination
	with every modeling language that has 
	object-oriented modeling concepts like types and navigable properties.
	When integrating OCL with such a modeling language, the concrete and 
	abstract syntax of OCL is not affected. As OCL is statically
	typed, the abstract syntax only needs access to the types of the model 
	it is defined on. Thus, a generic implementation of an OCL parser
	that relies on an abstraction of the underlying model type system can be
	reused to parse OCL constraints on different types of
	models \cite{braeuerOCL07}.
	%Such a generic architecture for an OCL tool was presented by Matthias Br\"auer 
	%in 2007 \cite{braeuerOCL07}. %Besides the abstract syntax and static semantics, 
	%the OCL specification defines the dynamic OCL semantics as well
	%\cite{spec:OCL2-2}.

	One approach to evaluate OCL constraints on instances 
	of constrained models is \textit{Constraint Compilation} where the constraints are 
	translated and added to the model instance. This approach has some drawbacks. 
	Firstly, the model instance might not offer means to express dynamic semantics with 
	the implication that the constraints cannot be translated. Secondly, 
%	the translated 
%	code	 has to be executed at specific times, e.g., a precondition has to be checked 
%	before the actual method is executed. Thus, 
	instrumentation of the model instance with the translated code might be not possible 
	or far from trivial. Lastly, the whole compilation has to be 	changed for every desired 
	model instance.
	
	OCL constraints can also be evaluated using \textit{Constraint Interpretation} where 
	an OCL interpreter visits nodes of the abstract syntax of the defined constraints and 
	executes their appropriate semantics. Model instances are only read and thus neither 
	need to have dynamic semantic nor instrumentation capabilities. Furthermore, 
	since model instances are only read, the complete OCL semantics remains 
	unaffected from the specifics of model instances and therefore can be reused.
	
	For example, consider business rules for models that are defined using XML Schema. 
	It is impossible to generate code for OCL constraints defined on such 
	a model for XML instances of the model since they solely contain structural information. 
	Another example is a UML model whose model
	instance is defined in C\#. Although it is possible to compile OCL constraints into 
	C\# code, the instrumentation of the constrained code is an issue. The interpretation 
	of OCL constraints is nonetheless possible for both examples. Furthermore, the 
	constraints of the examples can be evaluated using the same OCL interpreter -- 
	they only differ in the way how model instance elements are accessed.

%	\note{Introduce the notion model implementation|instantiation. Motivate why it
%	is good to vary implementation, reference examples}
	% Although OCL is 
	% defined abstractly and independent of specific implementations, 
	% and can be used at different meta levels,\footnote{E.g., OCL can be used to 
	% define \textit{Well-Formedness Rules (WFRs)} on meta-models checked on models.
	% Alternatively, OCL can be used to define business rules on models that are
	% checked on the model's instances.}
	Hence, when interpreting OCL constraints on both model and model 
	instance level, the OCL infrastructure can be reused. The variation points are the 
	ways models or their instances are accessed. However, in practice, OCL 
	interpreters are typically bound 
	to a specific model instance or fixed combinations of models and model instances 
	\note{references?}. Thus, a reimplementation of OCL's dynamic semantics 
	is required for different types of model instances.
%	\remove{Each reimplementation leads to
%	code duplication, limits reuse and makes it more difficult to maintain or extend 
%	the OCL semantics for all types of model instances synchronously.}

	In this paper, we propose an architecture for an OCL
	infrastructure that hides models and model instances behind well-defined interfaces.
	This enables reuse of the complete OCL infrastructure including the parser, 
	standard library and interpreter for various model instances. We present an
	implementation of our approach for \textit{DresdenOCL}
	\cite{WWW:dresdenOCL}. \textit{DresdenOCL} is able to parse OCL
	constraints on different types of models such as UML, EMF Ecore, Java and 
	XML Schema and evalute them for different model instances such as Java 
	objects, XML files or {UML diagrams}.
	
	\textbf{TODO The paper is structured as follows...}