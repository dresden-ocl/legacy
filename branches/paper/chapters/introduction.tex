\section{Introduction}
	\emph{Model-driven software development (MDSD)} aims to abstract from concrete 
	software implementations and uses models to describe software systems. 
	To ensure consistency of models, the Object Constraint Language 
	(OCL) \cite{spec:OCL2-2} has been developed as an extension of the Unified 
	Modelling Language (UML) \cite{spec:UML2-2,warmer:ocl}. In recent years,
	OCL advanced to a constraint language used for various 
	modelling and meta-modelling languages \cite{detaching} like the Meta
	Object Facility (MOF) \cite{UmlMof} or Ecore \cite{WWW:MDT}.

	While OCL constraints are defined on models,
	they are evaluated on instances of these models.
	 Besides instances of constrained models stored in various model repositories
	like MOFLON \cite{MOFLON}, Netbeans MDR~\cite{UmlMof}, or EMF~\cite{WWW:MDT},
	they also can be realised using classic programming languages like
	Java~\cite{demuthRGWS09}, or C\#~\cite{OCLCsharp}, stored in database systems~\cite{OCLRelDB}, or described with XML~\cite{OCLXML}. 
	
	Several OCL tools support \emph{variability at the model level}~\cite{braeuerOCL07,akehurst2003ocl}, i.e., constraint
	definition on different types of models. Yet, \emph{variability at the model
	instance level}, i.e., constraint evaluation on different types of model instances, is not provided. 
	For OCL compilers as presented in
	\cite{UmlMof,demuthRGWS09,OCLCsharp,OCLRelDB} 
	such variability is not possible, as the code generated from OCL constraints 
	needs to be	bound to the technical spaces used at model instance level. 
	However, for OCL interpreters, we argue that a
	decoupling of the semantics evaluation from a concrete model instance type is possible.
	In this paper we propose a \emph{generic adaptation architecture} for OCL
	interpreters that hides models and model instances behind well-defined
	interfaces. This enables reuse of the complete OCL infrastructure including the OCL parser, 
	standard library and interpreter. We implemented such an infrastructure in 
	\emph{DresdenOCL}~\cite{WWW:dresdenOCL}.
	
	The remainder of this paper is structured as follows. In
	Sect.~\ref{sec:foundation} we analyse diverse applications for OCL and 
	motivate two variation points for OCL interpretation. In
	Sect.~\ref{sec:implementation} we discuss the design and implementation of a
	\emph{generic adaptation architecture} for OCL interpreters to realise the
	motivated variation points in DresdenOCL. In Sect.~\ref{sec:caseStudies}
	we document the feasibility and	benefits of our adaptation architecture by
	applying it to three case studies that use OCL with different combinations of models and model
	instances. In Sect.~\ref{sec:lessons} we elaborate on lessons learnt
	during implementation and application of our approach. Finally, we present
	related work in Sect.~\ref{sec:relatedWork} and conclude our contributions in
	Sect.~\ref{sec:conclusion}.
	
% 	 We present an
% 	implementation of our approach for \textit{DresdenOCL}
% 	\cite{WWW:dresdenOCL}.
	
% 	For instance, OCL can be used to define
% 	business rules on a UML model that are checked for model instances including UML object model\remove{ element}s, Java objects or XML files. In another example, OCL can be used to define \textit{Well-Formedness 
% 	Rules (WFRs)} on an \textit{XML Schema Definition (XSD)} that are evaluated for instances 
% 	of the definition, e.g., XML files. Other instances of the XSD model are possible.

% 	There are two variation points that can be identified. Firstly, OCL constraints can 
% 	be defined on different models as long as the model has object-oriented 
% 	modelling concepts like types and navigable properties. When integrating OCL with 
% 	such a model, the concrete and abstract syntax of OCL is not affected. 
% 	As OCL is statically typed, the abstract syntax only needs access to the types of the 
% 	model it is defined on. Thus, a generic implementation of an OCL parser
% 	that relies on an abstraction of the model's underlying type system can be
% 	reused to parse OCL constraints on different types of models \cite{braeuerOCL07}.
% 	Secondly, model instances may vary specific kinds of models. As OCL constraints 
% 	are defined on a model and evaluated on elements of the model's instance\add{s}, the variability 
% 	of different model and model instance combinations has to be considered by an 
% 	OCL infrastructure as well.
	
% 	Generally, two approaches exist to evaluate OCL constraints on instances of constraint
% 	models: the \textit{Generative Approach} and the \textit{Interpretative Approach}
% 	\cite{demuthRGWS09}.	
% 	Using the generative approach, constraints are 
% 	translated \add{into queries or executable code} and added to the model instance. 
% 	This approach has some drawbacks. 
% 	Firstly, the model instance might not offer means to express dynamic semantics with 
% 	the implication that the constraints cannot be translated. Secondly, 
%   instrumentation of the model instance with the translated code might be not possible 
% 	or far from trivial. Lastly, variations at model instance level can only be achieved with 
% 	a completely new compilation. Using the interpretative approach, 
% 	an OCL interpreter visits nodes of the constraint's abstract syntax and 
% 	executes their appropriate semantics. Model instances are only 
% 	\change{read}{requested for property values and operation results} and thus neither 
% 	need to have dynamic semantic nor instrumentation capabilities. Furthermore, 
% 	since model instances are only read, the complete OCL semantics remains 
% 	unaffected from the specifics of model instances and therefore can be reused.
	
%	For example, consider business rules for models that are defined using XML Schema. 
%	It is impossible to generate code for OCL constraints defined on such 
%	a model for XML instances of the model since they solely contain structural information. 
%	Another example is a UML model whose model
%	instance is defined in C\#. Although it is possible to compile OCL constraints into 
%	C\# code, the instrumentation of the constrained code is an issue. The interpretation 
%	of OCL constraints is nonetheless possible for both examples. Furthermore, the 
%	constraints of the examples can be evaluated using the same OCL interpreter -- 
%	they only differ in the way how model instance elements are accessed.

%	\note{Introduce the notion model implementation|instantiation. Motivate why it
%	is good to vary implementation, reference examples}
	% Although OCL is 
	% defined abstractly and independent of specific implementations, 
	% and can be used at different meta levels,\footnote{E.g., OCL can be used to 
	% define \textit{Well-Formedness Rules (WFRs)} on meta-models checked on models.
	% Alternatively, OCL can be used to define business rules on models that are
	% checked on the model's instances.}
	
% 	Thus, when interpreting OCL constraints, an OCL infrastructure has to consider two 
% 	variation points. Some OCL infrastructures allow the specification of OCL constraints 
% 	on different types of models. However, in practice, OCL interpreters are typically bound 
% 	to a specific \add{type of} model instance\add{s} or \add{to} fixed combinations of models and model instances 
% 	\note{references?} and hence do not address the second variation point to vary Model Instance Types.
	
  
	
	
	
% 	 We demonstrate \textit{DresdenOCL} is able to parse OCL
% 	constraints on different types of models such as UML, EMF Ecore, Java and 
% 	XML Schema and interpret them for different model instances such as Java 
% 	objects, XML files or {UML diagrams}.
	
%	Hence, when interpreting OCL constraints on both model and model 
%	instance level, the OCL infrastructure can be reused. The variation points are the 
%	ways models or their instances are accessed. However, in practice, OCL 
%	interpreters are typically bound 
%	to a specific model instance or fixed combinations of models and model instances 
%	\note{references?}. Thus, a reimplementation of OCL's dynamic semantics 
%	is required for different types of model instances.
%	\remove{Each reimplementation leads to
%	code duplication, limits reuse and makes it more difficult to maintain or extend 
%	the OCL semantics for all types of model instances synchronously.}
		
% 	\note{TODO The paper is structured as follows...}