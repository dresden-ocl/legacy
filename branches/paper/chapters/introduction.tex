\section{Introduction}

Model-Driven Software Development (MDSD) aims to abstract from concrete software implementations and uses modeling languages to describe software systems. Model languages include the Unified Modeling Language (UML) \cite{spec:UML2-2}, Ecore of the Eclipse Modeling Framework (EMF) \cite{WWW:EMF} and domain-specific modeling languages (DSLs). The Object Constraint Language (OCL) \cite{spec:OCL2-2} was originally designed as an extension of the UML to express structural and functional constraints on UML models in a textual syntax. In recent years, OCL has become a popular constraint language for other modeling languages like EMF Ecore and various DSLs as well. In general, OCL can be defined and used as a constraint language on top of every modeling language, that contains basic modeling concepts like types and navigable properties.

When integrating OCL with such a modeling language, the concrete and abstract syntax of OCL is not altered. As OCL is statically typed, the abstract syntax only needs to have access to the types of the model it is defined on. Thus, a generic implementation of an OCL tool that supports OCL constraints on different types of models can be designed and implemented if there is an abstraction of the underlying model type system. %Such a generic architecture for an OCL tool was presented by Matthias Br\"auer in 2007 \cite{braeuerOCL07}. %Besides the abstract syntax and static semantics, the OCL specification defines the dynamic OCL semantics as well \cite{spec:OCL2-2}. 

One approach to evaluate the dynamic semantics of OCL constraints on instances of constrained models is \textit{Constraint Interpretation}. Although OCL is defined abstractly and independent of specific implementations, %and can be used at different meta levels,\footnote{E.g., OCL can be used to define \textit{Well-Formedness Rules (WFRs)} on meta-models checked on models. Alternatively, OCL can be used to define business rules on models that are checked on the model's instances.} 
OCL interpreters are normally limited to specific programming or modeling languages. Thus, a reimplementation of OCL's dynamic semantics is required for every type of model instantiation. Each reimplementation leads to code duplication, limits reuse and makes it more difficult to maintain or extend the OCL semantics for all types of model instances synchronously.

In this paper, we propose an architecture for an OCL tool that encapsulates meta-models, models and model instantiations behind well-defined interfaces. Thus, it is possible to reuse the complete OCL infrastructure including the parser, standard library and interpreter for every combination of different model and instantiation types. An implementation of the approach is used in our tool \textit{DresdenOCL} \cite{WWW:dresdenOCL}, released in its third version under the name of \textit{Dresden OCL2 for Eclipse}. \textit{DresdenOCL} is able to parse OCL constraints on different types of models such as UML, EMF Ecore, Java and XML Schema and interpret them on different model instantiations such as Java objects, XML files or UML diagrams.

\textbf{TODO The paper is structured as follows...}