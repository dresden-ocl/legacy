\section{Case Studies}

In this section we present three case studies to demonstrate the power of the presented
generic adaptation architecture.


\subsection{The Royal and Loyal System Example}

As a first case study, we modelled and implemented the \textit{Royal and Loyal System Example} 
as defined in \cite{warmer:ocl}. The case study was designed by \textsc{Warmer and Kleppe} to explain 
the Object Constraint Language and can be used to test the interpretation of
various kinds of OCL expressions. The case study consists of 13 UML classes (including inheritance and enumeration types)
and 130 constraints. We modelled the royal and loyal system using the UML2 meta-model of the
Eclipse Model Development Tools (MDT) project \cite{WWW:MDT}.
The model was implemented and instantiated in Java. Consequently
constraints were evaluated on Java objects.

\begin{figure}[!t]
	\centering
		\includegraphics[width=0.60\textwidth]{figures/casestudy01.pdf}
	\caption{In the Royal and Loyal case study, VP1 is bound to the \textit{MDT UML2 Model Adapter}. 
	  Consequently, the Royal and Loyal UML class diagram is adapted as a model at M1.
	  VP2 is bound to the \textit{Java Model Instance Adapter} and thus, each object of the Java 
	  implementation is adapted as a model instance object at M0.}
	\label{fig:casestudy01}
\end{figure}

The required adaptations for the royal and loyal case study are shown in Fig. \ref{fig:casestudy01}.
To parse the Royal and Loyal constraints
in DresdenOCL, a \textit{UML2 Model Adapter} component was implemented, that 
adapts the required meta-model elements from the MDT UML2 meta-model to the model 
types of DresdenOCL at the M2 layer and creates instances of these adapters for all UML models 
loaded into DresdenOCL. 
Consequently, the royal and loyal class diagram was adapted as a model at the M1 layer.
For the Java implementation, a \textit{Java Model Instance Adapter} component was implemented,
that adapts the Java meta-model elements (classes of the package \texttt{java.lang.reflect})
to the model instance types and creates instances of these adapters for all Java objects
loaded into DresdenOCL. Consequently, the objects of the royal and loyal Java implementation
were adapted as \texttt{ModelInstanceElements} in DresdenOCL at the M0 layer. Both, classes from 
the class diagram and from the Java implementation are located at the M1 layer 
because the Java classes are only other representations of the classes described by the 
UML class diagram! 

The Royal and Loyal case study demonstrates that our generic adapter architecture is able to 
support the common interpretation of OCL constraints defined on UML classes for Java objects.


\subsection{SEPA Business Rules}

As a second case study we tried to adapt our generic adaptation architecture to the
area of XML-structured data. Thus, we decided to interpret OCL consistency constraints
defined on an XML schema for an XML instance of this schema in a real, economy-driven
scenario. The company \textsc{Nomos Software} provides a service to check business rules on
financial \textit{Single Euro Payments Area (SEPA)} messages that are 
used in financial transactions of bank offices as defined by the \textit{European
Payment Council (EPC)}, \textit{ISO20022}, and the \textit{Euro Banking Association (EBA)} \cite{spec:UNIFI,spec:EPC}. 
SEPA messages are described and shipped as XML documents.
\textsc{Nomos Software} uses OCL constraints defined on XML schemas
to validate XML documents against a set of business rules that constrain the consistency of
this SEPA messages. We implemented an XSD model and an XML model instance adaptation 
for DresdenOCL and used the XSD and XML files that are 
provided with an online demo of the Nomos service for \textit{Pain.008.001.01} SEPA 
messages.\footnote{http://www.nomos-software.com/demo.html}
We took the about 120 constrains provided by the demo to test our adaptation. 

\begin{figure}[!t]
	\centering
		\includegraphics[width=0.60\textwidth]{figures/casestudy02.pdf}
	\caption{In the SEPA case study, VP1 is bound to the \textit{XSD Model Adapter}. 
	  Consequently, the Pain.008.001.01 schema is adapted as a model at M1.
	  VP2 is bound to the \textit{XML Model Instance Adapter} and thus, each node of the XML
	  instance is adapted as a model instance object at M0.}
	\label{fig:casestudy02}
\end{figure}

The required adaptations for the SEPA case study are shown in Fig. \ref{fig:casestudy02}.
To parse the SEPA constraints
in DresdenOCL, an \textit{XSD Model Adapter} component was implemented, that 
adapts the required meta-model elements from the XSD meta-model to the model 
types of DresdenOCL at the M2 layer and creates instances of these adapters for all XML schemas 
loaded into DresdenOCL. 
Consequently, the \textit{Pain.008.001.01} XML schema was adapted as a model at the M1 layer.
For the XML instances, an \textit{XML Instance Adapter} component was implemented,
that adapts the XML meta-model elements (mainly the class \texttt{org.w3c.dom.Node})
to the model instance types and creates instances of these adapters for all XML node instances
loaded into DresdenOCL. Consequently, the nodes of the Pain.008.001.01 XML messages
were adapted as \texttt{ModelInstanceElements} in DresdenOCL at the M0 layer.

These constraints of the Nomos service demo were evaluated for three different XML files 
and the results have been successfully compared with the results of the Nomos service demo.
This shows that our model implementation adaptation allows DresdenOCL to transparantly interpret
constraints on XML files as well. The OCL2 Interpreter had not to be modified for the SEPA case study!


\subsection{The OCL2.2 Standard Library}
The last case study depicts the ability to load different model instances of one model 
in order to check for inconsistencies between both instances. In this example we 
checked WFRs for the OCL standard library of DresdenOCL. 
DresdenOCL's standard library is explicitly modelled as 
an instance of the model types, describing predefined OCL types like \texttt{Integer}, 
\texttt{OclAny} or \texttt{Sequence} and their associated operations. 
Hence, accessing predefined OCL types is reduced to a simple model 
import while the model can conveniently be queried, validated or altered 
\cite{braeuerOCL07}. The WFRs can be used to check whether all OCL types are 
declared and whether they support all operations that are defined by the 
current OCL specification.

Although modelling the standard library leads to great flexibility, the standard library 
still needs an implementation that provides its dynamic semantics. 
This implementation is provided through Java code. As the \textit{Model Types Editor} of Dresden OCL
does not support code generation, this can lead to inconsistencies between 
the modelled standard library and the according Java interfaces.
We propose to use OCL to check that all modelled types have an equivalent Java 
interface and all modelled operations are also present in the Java interface. Furthermore, 
this approach allows us to check whether the standard library supports all operations that 
are defined in the current OCL standard.

\begin{figure}[!t]
	\centering
		\includegraphics[width=0.60\textwidth]{figures/casestudy03.pdf}
	\caption{In the standard library case study, VP1 is bound to the \textit{EMF Ecore Model Adapter}. 
	  Consequently, the EssentialOcl ecore model is adapted as a model at M2.
	  VP2 is bound to the \textit{XMI Model Instance Adapter} and thus, each element of the modelled Standard Library
	  instance is adapted as a model instance object at M1.}
	\label{fig:casestudy03}
\end{figure}

The required adaptations for the standard library case study are shown in Fig. \ref{fig:casestudy03}.
To parse the WFRs in DresdenOCL, an \textit{EMF Ecore Model Adapter} component was implemented, that 
adapts the required meta-model elements from the ecore meta-model (EMOF) to the model 
types of DresdenOCL at the M3 layer and creates instances of these adapters for all ecore-based
meta-models loaded into DresdenOCL. 
Consequently, the \textit{EssentialOCL} meta-model was adapted as a model at the M2 layer.
For the standard library instance, an \textit{XMI Model Instance Adapter} component was implemented,
that adapts the model istances of ecore-based meta-models (stored as XMI-files)
to the model instance types and creates instances of these adapters for all elements of these models
loaded into DresdenOCL. Consequently, the elements of the standard library
were adapted as \texttt{ModelInstanceElements} in DresdenOCL at the M1 layer.
Thus, we are able to evaluate the WFRs for the standard library model and can prove the correct 
structure of it according to the current OCL specification. 
\note{Claas: Emphasize the model layers used for interpretation here. Big difference to case studies 1 and 2!}

\note{Claas: Do we really have to mention this lack. Lets talk about the interpretation results instead.}
In order to check for inconsistencies with the Java implementation, the Java interfaces 
for predefined OCL types have \add{to} be loaded with the \textit{Java Class Model Instance Adapter}. Then, the same WFRs 
used for the standard library model before can be checked for this instance. 
Unfortunately, the \textit{Java Class Model Instance Adapter} does not exist yet, but will be 
implemented in the near future.


\subsection{Future Case Studies}

For future case studies we plan to adapt meta-model and model implementations for web services (Meta-Model: WSDL, Model Implementation: \note{TODO}), static programming languages such as C\# (Meta-Model: UML2, Model Implementation: C\#), data bases (Meta-Model: SQL-DDL, Model Implementation: SQL). 

