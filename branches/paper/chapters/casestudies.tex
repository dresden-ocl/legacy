\section{Case Studies}
\label{sec:caseStudies}
In this section we present three case studies to demonstrate the benefits of our
generic adaptation architecture. The case studies use different types of models
and model instances located at different layers of the MOF four layer metadata architecture
to illustrate the variability of our approach.


\subsection{The Royal and Loyal System Example}

As a first case study, we modelled and implemented the \textit{royal and loyal system example} 
as defined in \cite{warmer:ocl}. This example was designed by \textsc{Warmer
and Kleppe} to teach the Object Constraint Language. It consists of
13 UML classes (including inheritance and enumeration types) and 130 constraints. 
We specified the royal and loyal system with a UML model (VP1) build with the
Eclipse Model Development Tools (MDT) \cite{WWW:MDT}.
The model was implemented and instantiated in Java (VP2). 
Consequently, constraints were evaluated on Java objects.

\begin{figure}[!t]
	\centering
		\includegraphics[width=0.60\textwidth]{figures/casestudy01.pdf}
	\caption{
	Adapters used in the Royal and Loyal case study
% 	In the Royal and Loyal case study, VP1 is bound to the \textit{MDT UML2 Model Adapter}. 
% 	  Consequently, the Royal and Loyal UML class diagram is adapted as a model at M1.
% 	  VP2 is bound to the \textit{Java Model Instance Adapter} and thus, each object of the Java 
% 	  implementation is adapted as a model instance object at M0.
	  }
	\label{fig:casestudy01}
\end{figure}

The adapters required for the royal and loyal case study are shown in Fig.~\ref{fig:casestudy01}. To parse the royal and loyal constraints
in DresdenOCL, a \textit{UML model adapter} component was implemented. It
adapts the required concepts of the UML meta-model to the \texttt{model\-Types}
of DresdenOCL at the M2 layer. Hence, the royal and loyal class diagram was adapted as a model at the M1 layer.
For the Java implementation, a \textit{Java model instance adapter} component was implemented,
that adapts the Java model elements (classes of the package \texttt{java.lang.reflect})
to the \texttt{model\-Instance\-Types}. Thus, the objects of the royal and loyal Java implementation
were adapted as a model instance in DresdenOCL at the M0 layer. 
Since the Java classes were generated by a model-to-text transformation out of the UML class diagram,
both are located at the M1 layer.

The royal and loyal case study demonstrates that our generic adaptation architecture is able to 
support the common interpretation of OCL constraints defined on UML classes for Java objects.


\subsection{SEPA Business Rules}

In our second case study we interpreted OCL business rules
defined on an XML schema (VP1) for XML documents (VP2)
conforming to this schema. The \textsc{Nomos Software} company provides a
service to check business rules on financial \textit{Single Euro Payments Area (SEPA)} messages that are 
used in financial transactions of bank offices as defined by the \textit{European
Payment Council (EPC)}, \textit{ISO20022}, and the \textit{Euro Banking Association (EBA)} \cite{spec:UNIFI,spec:EPC,WWW:EBA}. 
SEPA messages are described and shipped as XML documents.
\textsc{Nomos Software} uses OCL constraints defined on XML schemas
to validate XML documents against a set of business rules that ensure the consistency of
SEPA messages. We implemented an \emph{XSD model adapter} component and an \emph{XML model
instance adapter} component for DresdenOCL to evaluate about 120 constraints that are provided 
with the online demo.\footnote{http://www.nomos-software.com/demo.html}\note{Claas: Finally, we have to remove the note package to provide correct footnote numbers again.}

\begin{figure}[!t]
	\centering
		\includegraphics[width=0.60\textwidth]{figures/casestudy02.pdf}
	\caption{Adapters used in the SEPA case study
% 	In the SEPA case study, VP1 is bound to the \textit{XSD Model Adapter}. 
% 	  Consequently, the Pain.008.001.01 schema is adapted as a model at M1.
% 	  VP2 is bound to the \textit{XML Model Instance Adapter} and thus, each node of the XML
% 	  instance is adapted as a model instance object at M0.
	  }
	\label{fig:casestudy02}
\end{figure}

The adapters required for the SEPA case study are shown in Fig.
\ref{fig:casestudy02}. To parse the SEPA constraints
into DresdenOCL, the \textit{XSD model adapter} component adapts required concepts of the 
XSD meta-model to the Model 
Types of DresdenOCL at the M2 layer. 
Consequently, the \textit{SEPA} XML schema was adapted as a model at the M1 layer.
The \textit{XML instance adapter} component 
adapts the XML model elements (mainly the class \texttt{org.w3c.dom.Node}) to the \texttt{model\-Instance\-Types}. 
Thus, the nodes of the SEPA messages
were adapted as \texttt{Model\-Instance\-Elements} in DresdenOCL at the M0 layer.

The constraints were evaluated for three different XML files 
and the results have been successfully compared with the results of the \textsc{Nomos} demo.
This shows that our model instance adaptation allows DresdenOCL to transparently interpret
constraints on XML files as well. The OCL2 interpreter had not to be modified for the SEPA case study.


\subsection{The OCL2.2 Standard Library}

\begin{figure}[!t]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/casestudy03.pdf}
	\caption{Adapters used in the Standard Library case study}
	\label{fig:casestudy03}
\end{figure}

The last case study depicts the ability to load different model instances of one model 
in order to check for inconsistencies between these instances. In this example we 
checked well-formedness rules (WFRs) for the OCL standard library of DresdenOCL. 
DresdenOCL's standard library is explicitly modelled as 
an instance of the \texttt{model\-Types}, describing predefined OCL types like \texttt{Integer}, 
\texttt{OclAny} or \texttt{Sequence} and their associated operations. 
Hence, accessing those types is reduced to a simple model 
import while the model can conveniently be queried, validated or altered 
\cite{braeuerOCL07}. The WFRs can be used to check whether all OCL types are 
declared and whether they support all operations that are defined by the 
current OCL specification \cite{spec:OCL2-2}.

Although modelling the standard library leads to great flexibility, the standard library 
still needs an implementation that provides its dynamic semantics. 
This implementation is realised in Java. As there is no code generator for the \texttt{model\-Types}, 
the manual implementation can lead to inconsistencies between 
the modelled standard library and the according Java implementation.
We propose to use OCL to check that all modelled types have an equivalent Java 
implementation and all modelled operations are also present in the Java interfaces.

Since the OCL standard library has been built conforming to the \texttt{model\-Types}, an
\textit{EMF Ecore model adapter} component was required to parse OCL constraints
defined on the \texttt{model\-Types} (cf. Fig.~\ref{fig:casestudy03}, VP1).
To evaluate the constraints on the modelled standard library,
we implemented an \textit{XMI model instance adapter} component for instances of 
Ecore-based meta-models stored as XMI-files (VP2). For the Java-based standard library
a \emph{Java class model instance adapter} component was created. This adapter
allowed us to load Java classes as a model instance (VP2)
and to check for inconsistencies with the modelled standard library. The same WFRs 
used for the modelled standard library were evaluated for this instance. 

This case study shows that the implemented OCL interpreter is not only independent
of specific model realisation techniques, but can also use adapters of different meta layers.
Thus, constraints defined on models, meta-models, and even meta-meta-models can be interpreted.

%The required adaptations for the standard library case study are shown in Fig. \ref{fig:casestudy03}.
%To parse the WFRs in DresdenOCL, an \textit{EMF Ecore Model Adapter} component was implemented, that 
%adapts the required meta-model elements from the ecore meta-model (EMOF) to the Model 
%Types of DresdenOCL at the M3 layer and creates instances of these adapters for all ecore-based
%meta-models loaded into DresdenOCL. 
%Consequently, the \note{Michael: Model Types?} \textit{EssentialOCL} meta-model was adapted as a model at the M2 layer.
%For the standard library instance, an \textit{XMI Model Instance Adapter} component was implemented,
%that adapts the model istances of ecore-based meta-models (stored as XMI-files)
%to the Model Instance Types and creates instances of these adapters for all elements of these models
%loaded into DresdenOCL. Consequently, the elements of the standard library
%were adapted as \texttt{ModelInstanceElements} in DresdenOCL at the M1 layer.
%Thus, we are able to evaluate the WFRs for the standard library model and can prove the correct 
%structure of it according to the current OCL specification. 
%\note{Claas: Emphasize the model layers used for interpretation here. Big difference to case studies 1 and 2!}


\subsection{Future Case Studies}

For future case studies we plan to implement new model adapters for VP1
including \emph{WSDL} and \emph{SQL-DDL}. As further model instance adapters for 
VP2, we intend to support \emph{C\#} and \emph{relational databases}.

