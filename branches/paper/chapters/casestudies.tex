\section{Case Studies}

In this section we present three case studies to demonstrate the benefits of our
\emph{Generic Adaptation Architecture}.


\subsection{The Royal and Loyal System Example}

As a first case study, we modelled and implemented the \textit{Royal and Loyal System Example} 
as defined in \cite{warmer:ocl}. The case study was originally designed by \textsc{Warmer
and Kleppe} to teach the Object Constraint Language. It consists of
13 UML classes (including inheritance and enumeration types) and 130 constraints. 
We specify the royal and loyal system using UML2 (model) of the
Eclipse Model Development Tools (MDT) project \cite{WWW:MDT}.
The model was implemented and instantiated in Java (model instance).
Consequently constraints were evaluated on Java objects.

\begin{figure}[!t]
	\centering
		\includegraphics[width=0.60\textwidth]{figures/casestudy01.pdf}
	\caption{
	Adapters used in the Royals and Loyals case study
% 	In the Royal and Loyal case study, VP1 is bound to the \textit{MDT UML2 Model Adapter}. 
% 	  Consequently, the Royal and Loyal UML class diagram is adapted as a model at M1.
% 	  VP2 is bound to the \textit{Java Model Instance Adapter} and thus, each object of the Java 
% 	  implementation is adapted as a model instance object at M0.
	  }
	\label{fig:casestudy01}
\end{figure}

The adpaters required for the royal and loyal case study are shown in Fig.
\ref{fig:casestudy01}. To parse the Royal and Loyal constraints
in DresdenOCL, a \textit{UML2 Model Adapter} component was implemented, that 
adapts the required meta-model elements from the MDT UML2 meta-model to the model 
types of DresdenOCL at the M2 layer and creates instances of these adapters for all UML models 
loaded into DresdenOCL. 
Consequently, the royal and loyal class diagram was adapted as a model at the M1 layer.
\note{Michael: The next sentence is kind of confusing, as we are on model instance layer and speak of Java meta-models... Isn't java.lang.reflect rather the model of Java?} For the Java implementation, a \textit{Java Model Instance Adapter} component was implemented,
that adapts the Java meta-model elements (classes of the package \texttt{java.lang.reflect})
to the model instance types and creates instances of these adapters for all Java objects
loaded into DresdenOCL. Consequently, the objects of the royal and loyal Java implementation
were adapted as \texttt{ModelInstanceElements} in DresdenOCL at the M0 layer. Both, classes from 
the class diagram and from the Java implementation are located at the M1 layer 
because the Java classes are only other representations of the classes described by the 
UML class diagram! 

The Royal and Loyal case study demonstrates that our generic adapter architecture is able to 
support the common interpretation of OCL constraints defined on UML classes for Java objects.


\subsection{SEPA Business Rules}

In our second case study we interpret OCL consistency constraints
defined on an XML schema (model) for an XML documents (model instance)
conforming to this schema. The \textsc{Nomos Software} company provides a
service to check business rules on financial \textit{Single Euro Payments Area (SEPA)} messages that are 
used in financial transactions of bank offices as defined by the \textit{European
Payment Council (EPC)}, \textit{ISO20022}, and the \textit{Euro Banking Association (EBA)} \cite{spec:UNIFI,spec:EPC,WWW:EBA}. 
SEPA messages are described and shipped as XML documents.
\textsc{Nomos Software} uses OCL constraints defined on XML schemas
to validate XML documents against a set of business rules that constrain the consistency of
these SEPA messages. We implemented an XSD model adapter and an XML model
instance adapter for DresdenOCL to evaluate these constraints on the XSD and
XML files that are provided with an online demo of the Nomos service for \textit{Pain.008.001.01} 
SEPA messages.\footnote{http://www.nomos-software.com/demo.html}
About 120 constrains that are provided by the demo were used to test our
implementation.

\begin{figure}[!t]
	\centering
		\includegraphics[width=0.60\textwidth]{figures/casestudy02.pdf}
	\caption{Adapters used in the SEPA case study
% 	In the SEPA case study, VP1 is bound to the \textit{XSD Model Adapter}. 
% 	  Consequently, the Pain.008.001.01 schema is adapted as a model at M1.
% 	  VP2 is bound to the \textit{XML Model Instance Adapter} and thus, each node of the XML
% 	  instance is adapted as a model instance object at M0.
	  }
	\label{fig:casestudy02}
\end{figure}

The adaptater required for the SEPA case study are shown in Fig.
\ref{fig:casestudy02}. To parse the SEPA constraints
in DresdenOCL, an \textit{XSD Model Adapter} component was implemented, that 
adapts the required meta-model elements from the XSD meta-model to the model 
types of DresdenOCL at the M2 layer and creates instances of these adapters for all 
XML schemas loaded into DresdenOCL. 
Consequently, the \textit{Pain.008.001.01} XML schema was adapted as a model at the M1 layer.
\note{Michael: again: model instance, but speak of XML meta-model} For the XML
documents, an \textit{XML Instance Adapter} component was implemented, that
adapts the XML meta-model elements (mainly the class \texttt{org.w3c.dom.Node}) to the model instance types and creates instances of these adapters for all XML node instances
loaded into DresdenOCL. Consequently, the nodes of the Pain.008.001.01 XML messages
were adapted as \texttt{ModelInstanceElements} in DresdenOCL at the M0 layer.

These constraints of the Nomos service demo were evaluated for three different XML files 
and the results have been successfully compared with the results of the Nomos service demo.
This shows that our model implementation adaptation allows DresdenOCL to transparantly interpret
constraints on XML files as well. The OCL2 Interpreter had not to be modified for the SEPA case study!


\subsection{The OCL2.2 Standard Library}
The last case study depicts the ability to load different model instances of one model 
in order to check for inconsistencies between both instances. In this example we 
checked Well-Formedness Rules (WFRs) for the OCL standard library of DresdenOCL. 
DresdenOCL's standard library is explicitly modelled as 
an instance of the model types, describing predefined OCL types like \texttt{Integer}, 
\texttt{OclAny} or \texttt{Sequence} and their associated operations. 
Hence, accessing predefined OCL types is reduced to a simple model 
import while the model can conveniently be queried, validated or altered 
\cite{braeuerOCL07}. The WFRs can be used to check whether all OCL types are 
declared and whether they support all operations that are defined by the 
current OCL specification.

Although modelling the standard library leads to great flexibility, the standard library 
still needs an implementation that provides its dynamic semantics. 
This implementation is provided through Java code. As the \textit{Model Types Editor} of Dresden OCL
does not support code generation, this can lead to inconsistencies between 
the modelled standard library and the according Java interfaces.
We propose to use OCL to check that all modelled types have an equivalent Java 
interface and all modelled operations are also present in the Java interface. Furthermore, 
this approach allows us to check whether the standard library supports all operations that 
are defined in the current OCL standard.

\begin{figure}[!t]
	\centering
		\includegraphics[width=0.60\textwidth]{figures/casestudy03.pdf}
	\caption{\note{Michael: I know that this is not correct, but we should replace essentialOcl with model types for consistency} 
	In the standard library case study, VP1 is bound to the \textit{EMF Ecore Model Adapter}. 
	  Consequently, the EssentialOcl ecore model is adapted as a model at M2.
	  VP2 is bound to the \textit{XMI Model Instance Adapter} and thus, each element of the modelled Standard Library
	  instance is adapted as a model instance object at M1.}
	\label{fig:casestudy03}
\end{figure}

The required adaptations for the standard library case study are shown in Fig. \ref{fig:casestudy03}.
To parse the WFRs in DresdenOCL, an \textit{EMF Ecore Model Adapter} component was implemented, that 
adapts the required meta-model elements from the ecore meta-model (EMOF) to the model 
types of DresdenOCL at the M3 layer and creates instances of these adapters for all ecore-based
meta-models loaded into DresdenOCL. 
Consequently, the \note{Michael: Model Types?} \textit{EssentialOCL} meta-model was adapted as a model at the M2 layer.
For the standard library instance, an \textit{XMI Model Instance Adapter} component was implemented,
that adapts the model istances of ecore-based meta-models (stored as XMI-files)
to the model instance types and creates instances of these adapters for all elements of these models
loaded into DresdenOCL. Consequently, the elements of the standard library
were adapted as \texttt{ModelInstanceElements} in DresdenOCL at the M1 layer.
Thus, we are able to evaluate the WFRs for the standard library model and can prove the correct 
structure of it according to the current OCL specification. 
\note{Claas: Emphasize the model layers used for interpretation here. Big difference to case studies 1 and 2!}

\note{Claas: Do we really have to mention this lack. Lets talk about the interpretation results instead.}
In order to check for inconsistencies with the Java implementation, the Java interfaces 
for predefined OCL types have \add{to} be loaded with the \textit{Java Class Model Instance Adapter}. Then, the same WFRs 
used for the standard library model before can be checked for this instance. 
Unfortunately, the \textit{Java Class Model Instance Adapter} does not exist yet, but will be 
implemented in the near future.


\subsection{Future Case Studies}

\note{Michael: We claim that we have independent model and model instance and now we propose 
a tight coupling between those?}
For future case studies we plan to adapt meta-model and model implementations for web services (Meta-Model: WSDL, Model Implementation: \note{TODO}), static programming languages such as C\# (Meta-Model: UML2, Model Implementation: C\#), data bases (Meta-Model: SQL-DDL, Model Implementation: SQL). 

