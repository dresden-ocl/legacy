/* Generated by Together */

package com.togethersoft.modules.ocl;

import com.togethersoft.openapi.ide.util.UIComponentService;
import com.togethersoft.openapi.ide.inspector.util.property.RwiInspectorMultipleStringProperty;
import com.togethersoft.openapi.ide.inspector.IdeInspectorComponent;
import com.togethersoft.openapi.rwi.*;
import com.togethersoft.openapi.rwi.enum.*;
import java.awt.Component;
import javax.swing.*;
import javax.swing.event.EventListenerList;
import tudresden.ocl.gui.*;
import tudresden.ocl.gui.events.*;
import tudresden.ocl.parser.*;
import tudresden.ocl.parser.node.*;
import tudresden.ocl.parser.analysis.DepthFirstAdapter;
import tudresden.ocl.check.*;
import tudresden.ocl.*;
import java.util.*;

/**
 * @author Stefan Ocke
 */
class OCLInspectorComponent extends IdeInspectorComponent implements UIComponentService {
    private RwiElement rwiElement;

    /** @directed */
    private TogetherFacade facade;

    /** @link dependency */

    /*#OclTree lnkOclTree;*/

    /** @directed */
    private OCLEditor oclEditor;
    private PropertyOCLEditorModel editorModel;

    /** @link dependency 
     * @stereotype use*/
    /*# OCLConstraintVisibilityCondition lnkOCLConstraintVisibilityCondition; */

    public class PropertyOCLEditorModel implements OCLEditorModel {
        public class PropertyConstraintRepresentation implements ConstraintRepresentation {
            private String m_sName;
            private String m_sData;
            private RwiProperty rwiProperty;
            Map prop2stereo;
            {
                prop2stereo = new HashMap(3);
                prop2stereo.put("invariant", "inv");
                prop2stereo.put("precondition", "pre");
                prop2stereo.put("postcondition", "post");
            }

            private PropertyConstraintRepresentation() {
            }

            public PropertyConstraintRepresentation(RwiProperty rwiProperty) {
                super();
                this.rwiProperty = rwiProperty;
                extractConstraint();
            }

            public PropertyConstraintRepresentation(String name, String data) {
                super();
                this.rwiProperty = null;
                m_sName = name;
                m_sData = data;
                if (m_sData == null) {
                    m_sData = OCLUtil.getContextString(rwiElement);
                }
            }

            //Extract data and name of the constraint out of the rwiProperty
            public void extractConstraint() {
                if (rwiProperty != null) {
                    m_sName = null;
                    m_sData = OCLUtil.getContextString(rwiElement) + " " + prop2stereo.get(rwiProperty.getName()) + " " +
                        rwiProperty.getValue();
                    OclTree tree = null;
                    try {
                        tree = OclTree.createTree(m_sData, facade);
                        m_sName = tree.getConstraintName();
                    } catch (Exception e) {
                        //constraint doesnt  longer match to the model or
                        //was changed directly  in the source code
                        m_sName = "invalidConstraint";
                    }
                }
            }

            public RwiProperty getRwiProperty() {
                return this.rwiProperty;
            }

            public void setRwiProperty(RwiProperty rwiProp) {
                if (rwiProperty == null || !rwiProp.getName().equals(rwiProperty.getName()) ||
                    !rwiProp.getValue().equals(rwiProperty.getValue())) {
                        rwiProperty = rwiProp;
                        String oldData = m_sData;
                        String oldName = m_sName;
                        extractConstraint();
                        fireConstraintDataChanged(m_lcrConstraints.indexOf(this), oldData, this);
                        fireConstraintNameChanged(m_lcrConstraints.indexOf(this), oldName, this);
                } else {
                    rwiProperty = rwiProp;
                }
            }

            /** Get the constraint's body text. */
            public String getData() {
                return m_sData;
            }

            /** Get the constraint's name. */
            public String getName() {
                return ((m_sName != null) ? (m_sName) : ("new_constraint"));
            }

            /**
             * Set the constraint's body text. For the exceptions the detailed message must be human readable.
             * @param sData the new body of the constraint
             * @exception IllegalStateException if the constraint is not in a state to accept body changes.
             * @exception OclParserException if the specified constraint is not syntactically correct.
             * @exception OclTypeException if the specified constraint does not adhere by OCL type rules.
             */
            public void setData(String sData, EditingUtilities euHelper) throws IllegalStateException,
                OclParserException, OclTypeException {
                    if (sData != null) {
                        OclTree tree = null;
                        try {
                            tree = euHelper.parseAndCheckConstraint(sData, facade);
                        } catch (java.io.IOException e) {
                            //ignored
                        }
                        //always do auto-split, because one property holds exactly  one contstraint
                        List constraints = euHelper.splitConstraint(tree);
                        if (constraints.size() == 1) {
                            rwiProperty = writeProperty(tree, rwiProperty);
                            String sOldData = m_sData;
                            m_sData = sData;
                            fireConstraintDataChanged(m_lcrConstraints.indexOf(this), sOldData, this);
                            String sOldName = m_sName;
                            m_sName = tree.getConstraintName();
                            fireConstraintNameChanged(m_lcrConstraints.indexOf(this), sOldName, this);
                        } else {
                            removeConstraintAt(m_lcrConstraints.indexOf(this));
                            Iterator it = constraints.iterator();
                            RwiProperty newRwiProperty;
                            while (it.hasNext()) {
                                tree = (OclTree)it.next();
                                //TO FIX
                                newRwiProperty = writeProperty(tree, null);
                                PropertyConstraintRepresentation newConstraint = new PropertyConstraintRepresentation();
                                newConstraint.m_sData = tree.getExpression();
                                newConstraint.m_sName = tree.getConstraintName();
                                newConstraint.rwiProperty = newRwiProperty;
                                m_lcrConstraints.add(newConstraint);
                                fireConstraintAdded();
                            }
                        }
                    }
            }

            /**
             * Set the constraint's name. For the exceptions the detailed message must be human readable.
             * @param sName the new name of the constraint
             * @exception IllegalStateException if the constraint is not in a state to accept name changes.
             * @exception IllegalArgumentException if the specified name is not a legal name for the constraint.
             */
            public void setName(final String sName, final EditingUtilities euHelper) throws IllegalStateException,
                IllegalArgumentException {
                    if (m_sData == null) {
                        throw new IllegalStateException("Please specify a constraint body first.");
                    }
                    // Check name for consistency with spec
                    if (!euHelper.isValidConstraintName(sName)) {
                        throw new IllegalArgumentException("Please specify a valid name.");
                    }
                    // Set name
                    String sOldName = getName();
                    m_sName = sName;
                    try {
                        OclTree tree = null;
                        tree = euHelper.parseAndCheckConstraint(m_sData, facade);
                        if (tree != null) {
                            tree.apply(
                                new DepthFirstAdapter() {
                                    public void caseAConstraintBody(tudresden.ocl.parser.node.AConstraintBody node) {
                                        node.setName(new tudresden.ocl.parser.node.TName(sName));
                                    }
                                });
                            setData(tree.getExpression(), euHelper);
                        }
                    }
                    catch (Throwable t) {
                        // OK, so that didn't work out... Just ignore any problems and don't
                        // set the name in the constraint body
                    }
                    fireConstraintNameChanged(m_lcrConstraints.indexOf(this), sOldName, this);
            }

            //adds the constraint as a {invariant|precondition|postcondition} property
            //to the model or just changes an already existing poperty
            private RwiProperty writeProperty(OclTree tree, RwiProperty rwiProperty) {
                class PropertyExtractor extends DepthFirstAdapter {
                    public String propName = null;
                    public String propValue = null;
                    //maps the constraint stereotypes to  property names
                    Map stereotypes;
                    {
                        stereotypes = new HashMap(3);
                        stereotypes.put(AInvStereotype.class, "invariant");
                        stereotypes.put(APreStereotype.class, "precondition");
                        stereotypes.put(APostStereotype.class, "postcondition");
                    }

                    public void caseAConstraintBody(AConstraintBody node) {
                        PStereotype stereotype = node.getStereotype();
                        propName = (String)stereotypes.get(stereotype.getClass());
                        TName constrName = node.getName();
                        if (constrName == null) {
                            propValue = ": " + node.getExpression().toString();
                        } else {
                            propValue = constrName.toString() + ": " + node.getExpression().toString();
                        }
                    }
                };
                PropertyExtractor propertyExtractor = new PropertyExtractor();
                tree.apply(propertyExtractor);
                if (rwiProperty == null) {
                    rwiProperty = rwiElement.addProperty(propertyExtractor.propName, propertyExtractor.propValue);
                } else {
                    if (rwiProperty.getName().equals(propertyExtractor.propName)) {
                        rwiProperty.setValue(propertyExtractor.propValue);
                    } else {
                        rwiProperty.setValue(null);
                        rwiProperty = rwiElement.addProperty(propertyExtractor.propName, propertyExtractor.propValue);
                    }
                }
                return rwiProperty;
            }

            public void remove() {
                if (rwiProperty != null) {
                    rwiProperty.setValue(null);
                }
                rwiProperty = null;
                m_sName = null;
                m_sData = null;
            }
        }


        private List m_lcrConstraints = new ArrayList();

        /** List of listeners. */
        private EventListenerList m_ellListeners = new EventListenerList();

        public PropertyOCLEditorModel() {
            m_lcrConstraints = new ArrayList();
            List properties = readProperties();
            for (int i = 0; i < properties.size(); i++) {
                m_lcrConstraints.add(new PropertyConstraintRepresentation((RwiProperty)properties.get(i)));
            }
        }

        private List readProperties() {
            List result = new ArrayList();
            if (rwiElement != null) {
                String[] stereotypes = {"invariant","precondition","postcondition"};
                RwiProperty rwiProp;
                for (int i = 0; i < stereotypes.length; i++) {
                    RwiPropertyEnumeration rwiPropEnum = rwiElement.properties(stereotypes[i]);
                    while (rwiPropEnum.hasMoreElements()) {
                        rwiProp = rwiPropEnum.nextRwiProperty();
                        System.out.println("Read property " + rwiProp + "   " + rwiProp.getName() + " " + rwiProp.getValue());
                        result.add(rwiProp);
                    }
                }
            }
            return result;
        }

        //updates the constraints to reflect changes in the RwiModel
        //(i.e. caused by direct editing in the source code)
        public void updateConstraints() {
            //read the properties again
            List properties = readProperties();
            RwiProperty rwiProp;
            RwiProperty rwiPropOld;
            PropertyConstraintRepresentation pcr;
            for (int i = 0; i < properties.size(); i++) {
                rwiProp = (RwiProperty)properties.get(i);
                if (i < m_lcrConstraints.size()) {
                    pcr = (PropertyConstraintRepresentation)m_lcrConstraints.get(i);
                    pcr.setRwiProperty(rwiProp);
                    System.out.println("Property " + i + " updated");
                } else {
                    oclEditor.setEditMode(false); //avoid errors that occure in edit mode when a constraint is added
                    System.out.println("canceled edit mode");
                    m_lcrConstraints.add(new PropertyConstraintRepresentation(rwiProp));
                    fireConstraintAdded();
                    System.out.println("Property " + i + " added");
                }
            }
            int i = properties.size();
            while (i < m_lcrConstraints.size()) {
                System.out.println("Property " + i + " added");
                pcr = (PropertyConstraintRepresentation)m_lcrConstraints.remove(i);
                fireConstraintRemoved(pcr, i);
                System.out.println("Property " + i + " removed");
            }
        }

        /** Return the number of constraints in this model. */
        public int getConstraintCount() {
            return m_lcrConstraints.size();
        }

        /**
         * Return the constraint with the specified index.
         * @param nIdx the index of the constraint to be returned. 0 <= nIdx < {@link #getConstraintCount}
         */
        public ConstraintRepresentation getConstraintAt(int nIdx) {
            return (ConstraintRepresentation)m_lcrConstraints.get(nIdx);
        }

        /** Add a fresh constraint to the model. */
        public void addConstraint() {
            m_lcrConstraints.add(new PropertyConstraintRepresentation(null, null));
            fireConstraintAdded();
        }

        /**
         * Remove the specified constraint from the model.
         * @param nIdx the index of the constraint to be removed. 0 <= nIdx < {@link #getConstraintCount}
         */
        public void removeConstraintAt(int nIdx) {
            PropertyConstraintRepresentation pcr = (PropertyConstraintRepresentation)m_lcrConstraints.remove(nIdx);
            if (pcr != null) {
                pcr.remove();
                fireConstraintRemoved(pcr, nIdx);
            }
        }

        /**
         * Add a listener to be informed of changes in the model.
         * @param ccl the new listener
         */
        public void addConstraintChangeListener(ConstraintChangeListener ccl) {
            m_ellListeners.add(ConstraintChangeListener.class, ccl);
        }

        /**
         * Remove a listener to be informed of changes in the model.
         * @param ccl the listener to be removed
         */
        public void removeConstraintChangeListener(ConstraintChangeListener ccl) {
            m_ellListeners.remove(ConstraintChangeListener.class, ccl);
        }

        protected void fireConstraintRemoved(ConstraintRepresentation cr, int nIdx) {
            // Guaranteed to return a non-null array
            Object[] listeners = m_ellListeners.getListenerList();
            ConstraintChangeEvent cce = null;
            // Process the listeners last to first, notifying
            // those that are interested in this event
            for (int i = listeners.length - 2; i >= 0; i -= 2) {
                if (listeners[i] == ConstraintChangeListener.class) {
                    // Lazily create the event:
                    if (cce == null) {
                        cce = new ConstraintChangeEvent(this, nIdx, cr, null);
                    }
                    ((ConstraintChangeListener)listeners[i + 1]).constraintRemoved(cce);
                }
            }
        }

        protected void fireConstraintAdded() {
            // Guaranteed to return a non-null array
            Object[] listeners = m_ellListeners.getListenerList();
            ConstraintChangeEvent cce = null;
            // Process the listeners last to first, notifying
            // those that are interested in this event
            for (int i = listeners.length - 2; i >= 0; i -= 2) {
                if (listeners[i] == ConstraintChangeListener.class) {
                    // Lazily create the event:
                    if (cce == null) {
                        int nIdx = m_lcrConstraints.size() - 1;
                        cce = new ConstraintChangeEvent(this, nIdx, null, getConstraintAt(nIdx));
                    }
                    ((ConstraintChangeListener)listeners[i + 1]).constraintAdded(cce);
                }
            }
        }

        protected void fireConstraintDataChanged(int nIdx, String sOldConstraint, ConstraintRepresentation crNew) {
            // Guaranteed to return a non-null array
            Object[] listeners = m_ellListeners.getListenerList();
            ConstraintChangeEvent cce = null;
            // Process the listeners last to first, notifying
            // those that are interested in this event
            for (int i = listeners.length - 2; i >= 0; i -= 2) {
                if (listeners[i] == ConstraintChangeListener.class) {
                    // Lazily create the event:
                    if (cce == null) {
                        cce = new ConstraintChangeEvent(this, nIdx,
                            new PropertyConstraintRepresentation(crNew.getName(), sOldConstraint), crNew);
                    }
                    ((ConstraintChangeListener)listeners[i + 1]).constraintDataChanged(cce);
                }
            }
        }

        protected void fireConstraintNameChanged(int nIdx, String sOldName, ConstraintRepresentation crNew) {
            // Guaranteed to return a non-null array
            Object[] listeners = m_ellListeners.getListenerList();
            ConstraintChangeEvent cce = null;
            // Process the listeners last to first, notifying
            // those that are interested in this event
            for (int i = listeners.length - 2; i >= 0; i -= 2) {
                if (listeners[i] == ConstraintChangeListener.class) {
                    // Lazily create the event:
                    if (cce == null) {
                        cce = new ConstraintChangeEvent(this, nIdx,
                            new PropertyConstraintRepresentation(sOldName, crNew.getData()), crNew);
                    }
                    ((ConstraintChangeListener)listeners[i + 1]).constraintNameChanged(cce);
                }
            }
        }
    }


    public void update() {
        System.err.println("uuuupdate");
        if (editorModel != null) {
            editorModel.updateConstraints();
        }
    }

    public OCLInspectorComponent() {
        setName("OCL Constraints");
        setService(UIComponentService.class, this);
        oclEditor = new OCLEditor();
        rwiElement = null;
    }

    public void setContext(RwiElement rwiElement) {
        System.out.println("setContext" + rwiElement.getProperty(RwiProperty.NAME));
        if (rwiElement != this.rwiElement) {
            this.rwiElement = rwiElement;
            facade = new TogetherFacade(rwiElement);
            editorModel = new PropertyOCLEditorModel();
            oclEditor.setModel(editorModel);
        }
    }

    public Component getUIComponent() {
        return oclEditor;
    }
}
