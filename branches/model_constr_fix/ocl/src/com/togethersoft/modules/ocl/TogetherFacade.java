/* Generated by Together */package com.togethersoft.modules.ocl;import tudresden.ocl.check.OclTypeException;import tudresden.ocl.check.types.Any;import tudresden.ocl.check.types.DefaultReflectionAdapter;import tudresden.ocl.check.types.ReflectionFacade;import tudresden.ocl.lib.SimpleNameAdapter;import com.togethersoft.openapi.rwi.RwiContainer;import com.togethersoft.openapi.rwi.RwiElement;import com.togethersoft.openapi.rwi.RwiMember;import com.togethersoft.openapi.rwi.RwiModel;import com.togethersoft.openapi.rwi.RwiModelAccess;import com.togethersoft.openapi.rwi.RwiNode;import com.togethersoft.openapi.rwi.RwiPackage;import com.togethersoft.openapi.rwi.RwiProperty;import com.togethersoft.openapi.rwi.RwiPropertyMap;import com.togethersoft.openapi.rwi.RwiShapeType;import com.togethersoft.openapi.rwi.RwiVisitorAdapter;import com.togethersoft.openapi.rwi.enum.RwiNodeEnumeration;import com.togethersoft.openapi.rwi.enum.RwiPackageEnumeration;import com.togethersoft.openapi.rwi.enum.RwiPropertyEnumeration;/** * Conveys model information from Together projects  to the OCL compiler. * @see tudresden.ocl.check.types.ReflectionFacade * @author Christian Nill  */public class TogetherFacade implements tudresden.ocl.check.types.ModelFacade {	/**	 * Usually represents the classifier that is selected on the Together diagram pane	 */	protected RwiElement context;	// DEBUG	// private DebugHelper dh = new DebugHelper();	/** @link dependency 	 * @label <<create>>*/	/*# TogetherAny lnkTogetherAny; */	/**	 * The constructor checks the RwiElement and initializes TogetherFacade with it, if it is a classifier or an operation.	 * @param context The element in the model to originate all searching operations from.*/	public TogetherFacade(RwiElement context) {		if (context != null			&& (context.getProperty(RwiProperty.SHAPE_TYPE) == RwiShapeType.CLASS				|| context.getProperty(RwiProperty.SHAPE_TYPE)					== RwiShapeType.OPERATION)) {			this.context = context;		}	}	/**	 * getter for context : RwiElement	 */	public RwiElement getContext() {		return context;	}	/**	 * setter for context : RwiElement	 */	public void setContext(RwiElement e) {		this.context = e;	}	/**	 * Searches the current project for the classifier given as parameter.	 * 	 * The operation will search in the current Together model in the following order:	 * 	 * <ul>	 * <li>Classifier encapsulated in {@link #context context}	 * <li>Other classifiers in the same package	 * <li>Imported classes (e.g. from the JFC)	 * <li>Rest of the project	 * </ul>	 * 	 * <b>Note:</b> Also, if the parameter is fully specified, the search order remains unchanged and fully specified names <it>might</it> cause problems elsewhere in the Toolset.	 * @param name The classifier's name. Can also be fully specified, e.g. <code>some.model.SomeClass</code>	 * @exception OclTypeException if classifier could not be retrieved.*/	public Any getClassifier(String name) throws OclTypeException {		Any result = null;		SearchForClassifierVisitor classifierVisitor =			new SearchForClassifierVisitor(name);		// Make sure to start search from a context, that represents a classifier.		RwiElement classifierContext;		if (context != null			&& context.getProperty(RwiProperty.SHAPE_TYPE).equals(				RwiShapeType.OPERATION)) {			classifierContext = ((RwiMember) context).getContainingNode();		} else {			classifierContext = context;		}		// if classifierContext already is what is been looked for		if (classifierContext != null			&& (classifierContext.getProperty(RwiProperty.NAME).equals(name)				|| classifierContext.getProperty(RwiProperty.FULL_NAME).equals(					name))) {			return new TogetherAny(classifierContext);		}		// then check rest of package...		if (classifierContext != null) {			RwiPackage currentPackage =				((RwiContainer) classifierContext).getContainingPackage();			// visit the package non-recursively			RwiNode resultNode =				(RwiNode) classifierVisitor.visitPackage(currentPackage, false);			if (resultNode != null) {				return new TogetherAny(resultNode);			}		}		// if still not found and the original context is an operation, check for the		// operation's return type and parameters.		if (context != null			&& context.getProperty(RwiProperty.SHAPE_TYPE).equals(				RwiShapeType.OPERATION)) {			RwiElement targetRwiElement =				findClassifierInOperationContext(name);			// in case, this is an RwiProperty.IMPORTED type, use ReflectionFacade to generate Any			if (targetRwiElement != null) {				// this is not very nice. Instead of "import", it should be RwiProperty.IMPORTED				// or something similar, but all these properties represent differing strings				// RwiProperty.IMPORT == "$import"; RwiProperty.IMPORTED == "$imported"				/*                if (targetRwiElement.getProperty(RwiProperty.MODEL_PART).equals("import")) {				           	        // the array only containing an empty string makes ReflectionFacade only go through /				               	    // the root package, thus retrieving fully specified classes (e.g. "java.util.Date") correctly									ReflectionFacade rf = new ReflectionFacade(new String[]{""}, new DefaultReflectionAdapter(), new SimpleNameAdapter());				                    result = rf.getClassifier(targetRwiElement.getProperty(RwiProperty.FULL_NAME));				   	            }				*/				return (new TogetherAny(targetRwiElement));			}		}		if (result != null)			return result;		// then check whole model, i.e. all existing packages within the project...		// first, obtain all root packages		RwiModel currentModel = RwiModelAccess.getModel();		// maybe, search should be restricted on RwiProperty.MODEL_PART		RwiPackageEnumeration rpe = currentModel.rootPackages(null);		RwiElement foundRwiElement = null;		while (rpe.hasMoreElements() && foundRwiElement == null) {			foundRwiElement =				(RwiNode) classifierVisitor.visitPackage(rpe.nextRwiPackage());		}		if (foundRwiElement != null) {			// Check, whether that node is imported or not			if (foundRwiElement				.getProperty(RwiProperty.MODEL_PART)				.equals("model")) {				return new TogetherAny(foundRwiElement);			}		}		// if it's not in the current model, try it via ReflectionFacade		ReflectionFacade rf =			new ReflectionFacade(				new String[] { "" },				new DefaultReflectionAdapter(),				new SimpleNameAdapter());		try {			result = rf.getClassifier(name);		} catch (Exception e) {			// no success, ignore here		}		if (result != null) {			return result;		} else {			throw new OclTypeException(				"Could not find Classifier " + name + " in the current model");		}	}	// SHOULD BE PRIVATE/PROTECTED, but how to test then?	/**	 *Only to be invoked, if {@link #context context} of current <code>TogetherFacade</code> instance represents an operation (will return <code>null</code> otherwise).	 * 	 * Searches the context operation's return and parameter types for the classifier specified in the parameter.	 * @param name Name of the classifier being looked for	 * @return the Together model's representation of the classifier found; <code>null</code> if none is found.*/	public RwiElement findClassifierInOperationContext(String name) {		if (context			.getProperty(RwiProperty.SHAPE_TYPE)			.equals(RwiShapeType.OPERATION)) {			// check return type first			if (context.getProperty(RwiProperty.RETURN_TYPE).equals(name)) {				RwiModel myModel = RwiModelAccess.getModel();				RwiElement foundElement =					myModel.findElement(						context.getProperty(							RwiProperty.RETURN_TYPE_REFERENCED_ELEMENT));				return foundElement;			}			// then check parameters			RwiPropertyEnumeration rpe =				context.properties(RwiProperty.PARAMETER);			while (rpe.hasMoreElements()) {				RwiProperty someParameter = rpe.nextRwiProperty();				RwiPropertyMap subpropertiesContainer =					someParameter.getSubproperties();				if (subpropertiesContainer					.getProperty(RwiProperty.TYPE)					.equals(name)) {					RwiModel myModel = RwiModelAccess.getModel();					RwiElement foundElement =						myModel.findElement(							subpropertiesContainer.getProperty(								RwiProperty.TYPE_REFERENCED_ELEMENT));					// Any someAny = new TogetherAny(foundElement);					// return someAny;					return foundElement;				}			}		}		return null;	}	/**	 * Visitor to search for a classifier in packages recursively.	 * 	 * Needs to be instantiated with the name of the classifier that is being looked for.	 * @author Christian Nill 	 */	class SearchForClassifierVisitor extends RwiVisitorAdapter {		String classifierName;		public SearchForClassifierVisitor(String classifierName) {			this.classifierName = classifierName;		}		/**		 * Shorthand for {@link visitPackage(RwiPackage, boolean) visitPackage(RwiPackage, true)}.		 */		public Object visitPackage(RwiPackage rwiPackage) {			return visitPackage(rwiPackage, true);		}		/**		 * Extension to the standard visitPackage method. Allows to "disable"		 * the recursive nature of the Visitor pattern.		 * @param rwiPackage The package to be visited		 * @param recursing If <code>true</code>, subpackages will be searched recursively.		 * @return the <code>RwiNode</code> representing the classifier, that is being searched.		 */		public Object visitPackage(RwiPackage rwiPackage, boolean recursing) {			// Search for the right class first			RwiNodeEnumeration rne = rwiPackage.nodes();			while (rne.hasMoreElements()) {				RwiNode someRwiNode = rne.nextRwiNode();				if (someRwiNode					.getProperty(RwiProperty.NAME)					.equals(classifierName)					|| someRwiNode.getProperty(RwiProperty.FULL_NAME).equals(						classifierName)) {					return someRwiNode;				}			}			// if nothing found and recursing is desired, check for subpackages			RwiElement result = null;			if (recursing) {				RwiPackageEnumeration rpe = rwiPackage.subpackages();				while (rpe.hasMoreElements() && result == null) {					RwiPackage someRwiPackage = rpe.nextRwiPackage();					result = (RwiNode) visitPackage(someRwiPackage);				}			}			return result;		}	}}