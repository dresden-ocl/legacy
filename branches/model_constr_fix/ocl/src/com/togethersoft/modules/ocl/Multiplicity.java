/* Generated by Together */

package com.togethersoft.modules.ocl;

import java.util.*;

/*
*  Parses an UML multiplicity. An empty String is interpreted as default multiplicity which is 0..1
*/

/**
 * Utility class to read multiplicities of association links.
 * 
 * This class has simply been <b>copied</b> from its original package <code>tudresden.uml2sql</code>. It is used by {@link TogetherAny TogetherAny}, when navigating via associations.
 * @author Stefan Ocke 
 */
public class Multiplicity {
    private int lowerBound;
    private int upperBound;
    private List ranges;

    public class MultiplicityException extends Exception {
        private MultiplicityException(String msg) {
            super(msg);
        }
    }


    public class InvalidRangeException extends MultiplicityException {
        private InvalidRangeException(String rangeString) {
            super("Invalid multiplicity range: " + ((rangeString == null || rangeString.trim().length() == 0) ?
                "<empty>" : rangeString));
        }
    }


    public class ZeroException extends MultiplicityException {
        private ZeroException() {
            super("0 or 0..0 multiplicities are meaningless.");
        }
    }


    public class RangeOverlapException extends MultiplicityException {
        private RangeOverlapException(Multiplicity.Range range1, Multiplicity.Range range2) {
            super("Overlapping multiplicity ranges: " + range1 + " and " + range2);
        }
    }


    public class Range implements Comparable {
        private int lowerBound;
        private int upperBound;

        private Range(int lowerBound, int upperBound) {
            this.lowerBound = lowerBound;
            this.upperBound = upperBound;
        }

        private Range(String rangeString) throws Multiplicity.InvalidRangeException {
            if (rangeString == null || rangeString.trim().length() == 0) {
                throw new InvalidRangeException(rangeString);
            }
            int dotDotPos = rangeString.indexOf("..");
            if (dotDotPos == -1) {
                //a single star
                if (rangeString.trim().equals("*")) {
                    lowerBound = 0;
                    upperBound = -1;
                } else {
                    try {
                        int bound = Integer.parseInt(rangeString.trim());
                        if (bound < 0) {
                            throw new InvalidRangeException(rangeString);
                        }
                        lowerBound = bound;
                        upperBound = bound;
                    } catch (NumberFormatException e) {
                        throw new InvalidRangeException(rangeString);
                    }
                }
            } else {
                String lowerStr = rangeString.substring(0, dotDotPos).trim();
                try {
                    lowerBound = Integer.parseInt(lowerStr.trim());
                    if (lowerBound < 0) {
                        throw new InvalidRangeException(rangeString);
                    }
                } catch (NumberFormatException e) {
                    throw new InvalidRangeException(rangeString);
                }
                String upperStr = rangeString.substring(dotDotPos + 2).trim();
                if (upperStr.equals("*")) {
                    upperBound = -1;
                } else {
                    try {
                        upperBound = Integer.parseInt(upperStr.trim());
                        if (upperBound < 0) {
                            throw new InvalidRangeException(rangeString);
                        }
                    } catch (NumberFormatException e) {
                        throw new InvalidRangeException(rangeString);
                    }
                }
            }
            //check if upper bound is greater or equal lower bound
            if (upperBound != -1 && upperBound < lowerBound) {
                throw new InvalidRangeException(rangeString);
            }
        }

        public int getLowerBound() { return lowerBound; }

        public int getUpperBound() { return upperBound; }

        public boolean isUnlimited() { return (upperBound == -1); }

        public boolean isOverlapping(Multiplicity.Range other) {
            return ((other.lowerBound <= this.upperBound || this.upperBound == -1) &&
                (this.lowerBound <= other.upperBound || other.upperBound == -1));
        }

        //order by lower bounds
        public int compareTo(Object other) {
            Range otherRange = (Range)other;
            if (this.lowerBound < otherRange.lowerBound) {
                return -1;
            } else if (this.lowerBound == otherRange.lowerBound) {
                return 0;
            } else {
                return 1;
            }
        }

        public String toString() {
            if (lowerBound == upperBound) {
                if (lowerBound == -1) {
                    return "*";
                } else {
                    return String.valueOf(lowerBound);
                }
            } else {
                if (upperBound == -1) {
                    return lowerBound + "..*";
                } else {
                    return lowerBound + ".." + upperBound;
                }
            }
        }
    }


    public class RangeIterator {
        Iterator it;

        private RangeIterator(Collection ranges) {
            it = ranges.iterator();
        }

        public boolean hasNext() { return it.hasNext(); }

        public Multiplicity.Range nextRange() { return (Range)it.next(); }
    }


    public Multiplicity() {
        defaultInit();
    }

    public Multiplicity(String multiplString) throws MultiplicityException {
        if (multiplString == null || multiplString.trim().length() == 0) {
            defaultInit();
        } else {
            //split up the comma-separated multiplicity ranges
            ranges = new ArrayList();
            StringTokenizer intervalSeparator = new StringTokenizer(multiplString, ",");
            Range range;
            while (intervalSeparator.hasMoreTokens()) {
                range = new Range(intervalSeparator.nextToken());
                Range otherRange;
                RangeIterator rit = ranges();
                while (rit.hasNext()) {
                    otherRange = rit.nextRange();
                    if (range.isOverlapping(otherRange)) {
                        throw new RangeOverlapException(otherRange, range);
                    }
                }
                ranges.add(range);
            }
            //sort ranges
            Collections.sort(ranges);
            lowerBound = ((Range)ranges.get(0)).getLowerBound();
            upperBound = ((Range)ranges.get(ranges.size() - 1)).getUpperBound();
            if (lowerBound == 0 && upperBound == 0) {
                throw new ZeroException();
            }
        }
    }

    private void defaultInit() {
        lowerBound = 0;
        upperBound = 1;
        ranges = new ArrayList();
        ranges.add(new Range(0, 1));
    }

    public int getLowerBound() { return lowerBound; }

    public int getUpperBound() { return upperBound; }

    public boolean isUnlimited() { return (upperBound == -1); }

    public boolean isMultivalued() {
        return upperBound == -1 || upperBound > 1;
    }

    public RangeIterator ranges() {
        return new RangeIterator(ranges);
    }

    public String toString() {
        String result = "";
        RangeIterator rit = ranges();
        while (rit.hasNext()) {
            result += rit.nextRange().toString() + ",";
        }
        result = result.substring(0, result.length() - 1);
        return result;
    }
}
