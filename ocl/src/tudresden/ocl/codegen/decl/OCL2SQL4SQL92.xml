<?xml version="1.0"?>
<!DOCTYPE catalog SYSTEM "MappingRules.dtd">

<catalog name="OCL2SQL">
	<description>
		Describes mapping rules that help to
		generate SQL code out of OCL constraints for SQL92.
	</description>

	<pattern rule="constraint_body">
		<template spec="any" rem="OCL INVARIANT">
                        <li>create assertion <param name="constraint_name"/></li>
                        <li>check (not exists</li>
                        <li>(select * from <param name="context_table"/> SELF</li>
                        <li>where not (<param name="expression"/>)))</li>
		</template>
	</pattern>

	<pattern rule="literal">
		<template spec="string" rem="BASIC TYPE">
			<li><param name="value"/></li>
		</template>
		<template spec="boolean_true" rem="BASIC TYPE">
			<li>(1=1)</li>
		</template>
		<template spec="boolean_false" rem="BASIC TYPE">
			<li>(1=0)</li>
		</template>
		<template spec="enum" rem="BASIC TYPE">
			<li>'<param name="value"/>'</li>
		</template>
	</pattern>

	<pattern rule="parentheses_primary_expression">
		<template spec="any" rem="BASIC TYPE">
			<li>(<param name="expression"/>)</li>
		</template>
	</pattern>

	<pattern rule="if_expression">
		<template spec="any" rem="BASIC TYPE">
			<li>case when <param name="if_branch"/> then <param name="then_branch"/> else <param name="else_branch"/> end</li>
		</template>
	</pattern>

	<pattern rule="logical_expression_tail">
		<template spec="and" rem="BASIC TYPE">
			<li><param name="rel_exp_1"/> and <param name="rel_exp_2"/></li>
		</template>
		<template spec="or" rem="BASIC TYPE">
			<li><param name="rel_exp_1"/> or <param name="rel_exp_2"/></li>
		</template>
		<template spec="xor" rem="BASIC TYPE">
			<li>(<param name="rel_exp_1"/> or <param name="rel_exp_2"/>) and not (<param name="rel_exp_1"/> and <param name="rel_exp_2"/>)</li>
		</template>
		<template spec="implies" rem="BASIC TYPE">
			<li>NOT <param name="rel_exp_1"/> or <param name="rel_exp_2"/></li>
		</template>
	</pattern>

	<pattern rule="relational_expression_tail">
		<template spec="equal_IntRealStringEnum" rem="BASIC TYPE">
			<li><param name="add_exp_1"/> = <param name="add_exp_2"/></li>
		</template>
		<template spec="equal_Bool" rem="BASIC TYPE">
			<li>((<param name="add_exp_1"/> and <param name="add_exp_2"/>) or (not <param name="add_exp_1"/> and not <param name="add_exp_2"/>))</li>
		</template>
		<template spec="equal_OclAny" rem="BASIC TYPE">
			<li>No support for equals_Any !</li>
		</template>
		<template spec="equal_Set" rem="BASIC TYPE">
			<li>No support for equals_Set !</li>
		</template>
		<template spec="equal_Bag" rem="BASIC TYPE">
			<li>No support for equals_Bag !</li>
		</template>
		<template spec="equal_Sequence" rem="BASIC TYPE">
			<li>No support for equals_Sequence !</li>
		</template>
		<template spec="nequal_Basic" rem="BASIC TYPE">
			<li><param name="add_exp_1"/> &lt;&gt; <param name="add_exp_2"/></li>
		</template>
                <template spec="nequal_OclAny" rem="BASIC TYPE">
			<li>No support for equals_OclAny !</li>
		</template>
		<template spec="gt" rem="BASIC TYPE">
			<li><param name="add_exp_1"/> &gt; <param name="add_exp_2"/></li>
		</template>
		<template spec="lt" rem="BASIC TYPE">
			<li><param name="add_exp_1"/> &lt; <param name="add_exp_2"/></li>
		</template>
		<template spec="gteq" rem="BASIC TYPE">
			<li><param name="add_exp_1"/> &gt;= <param name="add_exp_2"/></li>
		</template>
		<template spec="lteq" rem="BASIC TYPE">
			<li><param name="add_exp_1"/> &lt;= <param name="add_exp_2"/></li>
		</template>
	</pattern>

	<pattern rule="additive_expression_tail">
		<template spec="plus" rem="BASIC TYPE">
			<li><param name="mult_exp_1"/> + <param name="mult_exp_2"/></li>
		</template>
		<template spec="minus" rem="BASIC TYPE">
			<li><param name="mult_exp_1"/> - <param name="mult_exp_2"/></li>
		</template>
	</pattern>

	<pattern rule="multiplicative_expression_tail">
		<template spec="mult" rem="BASIC TYPE">
			<li><param name="un_exp_1"/> * <param name="un_exp_2"/></li>
		</template>
		<template spec="div" rem="BASIC TYPE">
			<li><param name="un_exp_1"/> / <param name="un_exp_2"/></li>
		</template>
	</pattern>

	<pattern rule="unary_expression">
		<template spec="minus" rem="BASIC TYPE">
			<li>-<param name="un_exp"/></li>
		</template>
		<template spec="not" rem="BASIC TYPE" >
			<li>NOT (<param name="un_exp"/>)</li>
		</template>
	</pattern>

	<pattern rule="feature_call">

		<template spec="attribute_context" rem="CLASS AND ATTRIBUTE">
			<li><param name="context_alias"/>.<param name="column"/></li>
		</template>
		<template spec="attribute_navigation" rem="CLASS AND ATTRIBUTE">
			<li>select <param name="column1"/> from <param name="table1"/> where <param name="column2"/> in </li>
			<li>(<param name="table2"/>)</li>
		</template>
                <template spec="attribute_inherited" rem="CLASS AND ATTRIBUTE">
			<li>select <param name="column1"/> from <param name="table1"/> where <param name="column2"/> = <param name="context_alias"/>.<param name="column2"/></li>
		</template>
		<template spec="allInstances" rem="CLASS AND ATTRIBUTE">
			<li>select <param name="column"/> from <param name="table"/></li>
		</template>

		<template spec="nested_context" rem="NAVIGATION">
			<li>select <param name="column1"/> from <param name="table"/> where <param name="column2"/>=<param name="context_alias"/>.<param name="context_key"/></li>
		</template>
		<template spec="nested" rem="NAVIGATION">
			<li>select <param name="column1"/> from <param name="table"/> where <param name="column2"/> in </li>
			<li>(<param name="nested_select"/>)</li>
		</template>

		<template spec="forAll" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li>not exists</li>
			<li>(select <param name="column"/></li>
			<li>from (<param name="table1"/>)</li>
			<li>where <param name="column"/> in</li>
			<li>(select <param name="column"/></li>
			<li>from <param name="table2"/></li>
			<li>where not (<param name="expression"/>)))</li>
		</template>
		<template spec="includes" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li><param name="element"/> in select <param name="column"/></li>
			<li>from (<param name="table"/>)</li>
		</template>
		<template spec="excludes" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li><param name="element"/> not in select <param name="column"/></li>
			<li>from (<param name="table"/>)</li>
		</template>
		<template spec="includesAll" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li>not exists</li>
			<li>select <param name="column"/></li>
			<li>from (<param name="table1"/>)</li>
			<li>where <param name="column"/> not in select <param name="column"/> from (<param name="table2"/>)</li>
		</template>
		<template spec="excludesAll" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li>not exists</li>
			<li>select <param name="column"/></li>
			<li>from (<param name="table1"/>)</li>
			<li>where <param name="column"/> in select <param name="column"/> from (<param name="table2"/>)</li>
		</template>
		<template spec="isEmpty" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li>not exists (<param name="table"/>)</li>
		</template>
		<template spec="notEmpty" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li>exists (<param name="table"/>)</li>
		</template>
		<template spec="exists" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li>exists</li>
			<li>select <param name="column"/></li>
			<li>from (<param name="table1"/>)</li>
			<li>where (<param name="expression"/>)</li>
		</template>
		<template spec="isUnique" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li>unique</li>
                        <li>select <param name="column"/></li>
                        <li>from (<param name="table1"/>)</li>
                        <li>where (<param name="expression"/>)</li>
		</template>
		<template spec="sortedby" rem="COMPLEX PREDICATE">
			<li connector="true">and</li>
			<li>No support for sortedby !</li>
		</template>

		<template spec="sum" rem="BASIC VALUE">
			<li connector="true"> + </li>
			<li>select case when sum(<param name="column"/>) is null then 0 else sum(<param name="column"/>)</li>
			<li>from (<param name="table"/>)</li>
		</template>
		<template spec="size" rem="BASIC VALUE">
			<li connector="true"> + </li>
			<li>select case when count(<param name="column"/>) is null then 0 else count(<param name="column"/>)</li>
			<li>from (<param name="table"/>)</li>
		</template>
		<template spec="count" rem="BASIC VALUE">
			<li connector="true"> + </li>
			<li>select case when count(<param name="column"/>) is null then 0 else count(<param name="column"/>)</li>
			<li>from (<param name="table"/>)</li>
			<li>where <param name="key"/> = <param name="expression"/></li>
		</template>

		<template spec="select" rem="QUERY">
			<li>select <param name="key"/> from</li>
			<li>(<param name="table1"/>)</li>
			<li>where <param name="key"/> in</li>
			<li>(select <param name="key"/> from <param name="table2"/></li>
			<li>where <param name="expression"/>)</li>
		</template>
		<template spec="reject" rem="QUERY">
			<li connector="true"> union </li>
			<li>select <param name="key"/> from</li>
			<li>(<param name="table1"/>)</li>
			<li>where <param name="key"/> in</li>
			<li>(select <param name="key"/> from <param name="table2"/></li>
			<li>where not (<param name="expression"/>))</li>
		</template>
		<template spec="set_intersection" rem="QUERY">
			<li> (<param name="coll1"/>) intersect (<param name="coll2"/>)</li>
		</template>
		<template spec="bag_intersection" rem="QUERY">
			<li> (<param name="coll1"/>) intersect all (<param name="coll2"/>)</li>
		</template>
		<template spec="set_including" rem="QUERY">
			<li><param name="coll"/></li>
			<li>union</li>
			<li>select elem = <param name="element"/></li>
		</template>
		<template spec="bag_including" rem="QUERY">
			<li><param name="coll"/></li>
			<li>union all</li>
			<li>SELECT elem = <param name="element"/></li>
		</template>
		<template spec="sequence_including" rem="QUERY">
			<li>select * from (<param name="coll"/>)</li>
			<li>union</li>
			<li>select elem = <param name="element"/>, snr = (select MAX(snr)+1 from (<param name="coll"/>)</li>
		</template>
		<template spec="excluding" rem="QUERY">
			<li>select * from (<param name="coll"/>)</li>
			<li>where not (<param name="column"/> = <param name="element"/>)</li>
		</template>
		<template spec="set_union" rem="QUERY">
			<li> (<param name="coll1"/>) union (<param name="coll2"/>)</li>
		</template>
		<template spec="bag_union" rem="QUERY">
			<li> (<param name="coll1"/>) union all (<param name="coll2"/>)</li>
		</template>
		<template spec="sequence_union" rem="QUERY">
			<li>No support for sequence union !</li>
		</template>
		<template spec="symmetricDifference" rem="QUERY">
			<li>((<param name="coll1"/>) except (<param name="coll2"/>)) union ((<param name="coll1"/>) except (<param name="coll2"/>))</li>
		</template>
		<template spec="collect" rem="QUERY">
			<li>select <param name="column"/></li>
			<li>from <param name="table"/></li>
		</template>

		<template spec="basic_size" rem="BASIC VALUE">
			<li>length (<param name="operand"/>)</li>
		</template>
		<template spec="basic_concat" rem="BASIC VALUE">
			<li><param name="operand1"/> + <param name="operand2"/></li>
		</template>
		<template spec="basic_toUpper" rem="BASIC VALUE">
			<li>upper (<param name="operand"/>)</li>
		</template>
		<template spec="basic_toLower" rem="BASIC VALUE">
			<li>lower (<param name="operand"/>)</li>
		</template>
		<template spec="basic_substring" rem="BASIC VALUE">
			<li>substring(<param name="operand"/>, <param name="start"/>, <param name="end"/> - <param name="start"/> + 1)</li>
		</template>

		<template spec="basic_abs" rem="BASIC VALUE">
			<li>abs (<param name="operand"/>)</li>
		</template>
		<template spec="basic_floor" rem="BASIC VALUE">
			<li>floor (<param name="operand"/>)</li>
		</template>
		<template spec="basic_max" rem="BASIC VALUE">
			<li>case when <param name="operand1"/> &gt; <param name="operand2"/> then <param name="operand1"/> else <param name="operand2"/> end</li>
		</template>
		<template spec="basic_min" rem="BASIC VALUE">
			<li>case when <param name="operand1"/> &lt; <param name="operand2"/> then <param name="operand1"/> else <param name="operand2"/> end</li>
		</template>
		<template spec="basic_round" rem="BASIC VALUE">
			<li>round (<param name="operand"/>)</li>
		</template>
		<template spec="basic_div" rem="BASIC VALUE">
			<li><param name="operand1"/> / <param name="operand2"/></li>
		</template>
		<template spec="basic_mod" rem="BASIC VALUE">
			<li><param name="operand1"/> - ((<param name="operand1"/> / <param name="operand2"/>) * <param name="operand2"/></li>
		</template>
	</pattern>

	<pattern rule="literal_collection">
		<template spec="set" rem="QUERY">
			<li connector="true">union</li>
			<li>select elem = <param name="value"/></li>
		</template>
		<template spec="bag" rem="QUERY">
			<li connector="true">union all</li>
			<li>select elem = <param name="value"/></li>
		</template>
		<template spec="sequence" rem="QUERY">
			<li connector="true">union</li>
			<li>select elem = <param name="value"/>, snr = <param name="seqnr"/></li>
		</template>
	</pattern>

</catalog>
